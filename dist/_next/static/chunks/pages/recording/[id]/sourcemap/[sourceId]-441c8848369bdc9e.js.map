{"version":3,"file":"static/chunks/pages/recording/[id]/sourcemap/[sourceId]-441c8848369bdc9e.js","mappings":"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","sources":["webpack://_N_E/./packages/third-party/sourcemap-visualizer/sourcemapVisualizer.js","webpack://_N_E/./pages/recording/[id]/sourcemap/[sourceId].tsx","webpack://_N_E/?961b"],"sourcesContent":["// modified from https://github.com/evanw/source-map-visualization/blob/7faaca23c7b673e329b884b4dc218fe2369565e9/code.js\nexport default function renderSourcemap(source, sourcemap, url, document) {\n  ////////////////////////////////////////////////////////////////////////////////\n  // Loading\n\n  const toolbar = document.getElementById('toolbar');\n  const statusBar = document.getElementById('statusBar');\n  const originalStatus = document.getElementById('originalStatus');\n  const generatedStatus = document.getElementById('generatedStatus');\n\n  // Accelerate VLQ decoding with a lookup table\n  const vlqTable = new Uint8Array(128);\n  const vlqChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n  for (let i = 0; i < vlqTable.length; i++) vlqTable[i] = 0xFF;\n  for (let i = 0; i < vlqChars.length; i++) vlqTable[vlqChars.charCodeAt(i)] = i;\n\n  function decodeMappings(mappings, sourcesCount, namesCount) {\n    const n = mappings.length;\n    let data = new Int32Array(1024);\n    let dataLength = 0;\n    let generatedLine = 0;\n    let generatedLineStart = 0;\n    let generatedColumn = 0;\n    let originalSource = 0;\n    let originalLine = 0;\n    let originalColumn = 0;\n    let originalName = 0;\n    let needToSortGeneratedColumns = false;\n    let i = 0;\n\n    function decodeError(text) {\n      const error = `Invalid VLQ data at index ${i}: ${text}`;\n      showLoadingError(`The \"mappings\" field of the imported source map contains invalid data. ${error}.`);\n      throw new Error(error);\n    }\n\n    function decodeVLQ() {\n      let shift = 0;\n      let vlq = 0;\n\n      // Scan over the input\n      while (true) {\n        // Read a byte\n        if (i >= mappings.length) decodeError('Unexpected early end of mapping data');\n        const c = mappings.charCodeAt(i);\n        if ((c & 0x7F) !== c) decodeError(`Invalid mapping character: ${JSON.stringify(String.fromCharCode(c))}`);\n        const index = vlqTable[c & 0x7F];\n        if (index === 0xFF) decodeError(`Invalid mapping character: ${JSON.stringify(String.fromCharCode(c))}`);\n        i++;\n\n        // Decode the byte\n        vlq |= (index & 31) << shift;\n        shift += 5;\n\n        // Stop if there's no continuation bit\n        if ((index & 32) === 0) break;\n      }\n\n      // Recover the signed value\n      return vlq & 1 ? -(vlq >> 1) : vlq >> 1;\n    }\n\n    while (i < n) {\n      let c = mappings.charCodeAt(i);\n\n      // Handle a line break\n      if (c === 59 /* ; */) {\n        // The generated columns are very rarely out of order. In that case,\n        // sort them with insertion since they are very likely almost ordered.\n        if (needToSortGeneratedColumns) {\n          for (let j = generatedLineStart + 6; j < dataLength; j += 6) {\n            const genL = data[j];\n            const genC = data[j + 1];\n            const origS = data[j + 2];\n            const origL = data[j + 3];\n            const origC = data[j + 4];\n            const origN = data[j + 5];\n            let k = j - 6;\n            for (; k >= generatedLineStart && data[k + 1] > genC; k -= 6) {\n              data[k + 6] = data[k];\n              data[k + 7] = data[k + 1];\n              data[k + 8] = data[k + 2];\n              data[k + 9] = data[k + 3];\n              data[k + 10] = data[k + 4];\n              data[k + 11] = data[k + 5];\n            }\n            data[k + 6] = genL;\n            data[k + 7] = genC;\n            data[k + 8] = origS;\n            data[k + 9] = origL;\n            data[k + 10] = origC;\n            data[k + 11] = origN;\n          }\n        }\n\n        generatedLine++;\n        generatedColumn = 0;\n        generatedLineStart = dataLength;\n        needToSortGeneratedColumns = false;\n        i++;\n        continue;\n      }\n\n      // Ignore stray commas\n      if (c === 44 /* , */) {\n        i++;\n        continue;\n      }\n\n      // Read the generated column\n      const generatedColumnDelta = decodeVLQ();\n      if (generatedColumnDelta < 0) needToSortGeneratedColumns = true;\n      generatedColumn += generatedColumnDelta;\n      if (generatedColumn < 0) decodeError(`Invalid generated column: ${generatedColumn}`);\n\n      // It's valid for a mapping to have 1, 4, or 5 variable-length fields\n      let isOriginalSourceMissing = true;\n      let isOriginalNameMissing = true;\n      if (i < n) {\n        c = mappings.charCodeAt(i);\n        if (c === 44 /* , */) {\n          i++;\n        } else if (c !== 59 /* ; */) {\n          isOriginalSourceMissing = false;\n\n          // Read the original source\n          const originalSourceDelta = decodeVLQ();\n          originalSource += originalSourceDelta;\n          if (originalSource < 0 || originalSource >= sourcesCount) decodeError(`Original source index ${originalSource} is invalid (there are ${sourcesCount} sources)`);\n\n          // Read the original line\n          const originalLineDelta = decodeVLQ();\n          originalLine += originalLineDelta;\n          if (originalLine < 0) decodeError(`Invalid original line: ${originalLine}`);\n\n          // Read the original column\n          const originalColumnDelta = decodeVLQ();\n          originalColumn += originalColumnDelta;\n          if (originalColumn < 0) decodeError(`Invalid original column: ${originalColumn}`);\n\n          // Check for the optional name index\n          if (i < n) {\n            c = mappings.charCodeAt(i);\n            if (c === 44 /* , */) {\n              i++;\n            } else if (c !== 59 /* ; */) {\n              isOriginalNameMissing = false;\n\n              // Read the optional name index\n              const originalNameDelta = decodeVLQ();\n              originalName += originalNameDelta;\n              if (originalName < 0 || originalName >= namesCount) decodeError(`Original name index ${originalName} is invalid (there are ${namesCount} names)`);\n\n              // Handle the next character\n              if (i < n) {\n                c = mappings.charCodeAt(i);\n                if (c === 44 /* , */) {\n                  i++;\n                } else if (c !== 59 /* ; */) {\n                  decodeError(`Invalid character after mapping: ${JSON.stringify(String.fromCharCode(c))}`);\n                }\n              }\n            }\n          }\n        }\n      }\n\n      // Append the mapping to the typed array\n      if (dataLength + 6 > data.length) {\n        const newData = new Int32Array(data.length << 1);\n        newData.set(data);\n        data = newData;\n      }\n      data[dataLength] = generatedLine;\n      data[dataLength + 1] = generatedColumn;\n      if (isOriginalSourceMissing) {\n        data[dataLength + 2] = -1;\n        data[dataLength + 3] = -1;\n        data[dataLength + 4] = -1;\n      } else {\n        data[dataLength + 2] = originalSource;\n        data[dataLength + 3] = originalLine;\n        data[dataLength + 4] = originalColumn;\n      }\n      data[dataLength + 5] = isOriginalNameMissing ? -1 : originalName;\n      dataLength += 6;\n    }\n\n    return data.subarray(0, dataLength);\n  }\n\n  function generateInverseMappings(sources, data) {\n    let longestDataLength = 0;\n\n    // Scatter the mappings to the individual sources\n    for (let i = 0, n = data.length; i < n; i += 6) {\n      const originalSource = data[i + 2];\n      if (originalSource === -1) continue;\n\n      const source = sources[originalSource];\n      let inverseData = source.data;\n      let j = source.dataLength;\n\n      // Append the mapping to the typed array\n      if (j + 6 > inverseData.length) {\n        const newLength = inverseData.length << 1;\n        const newData = new Int32Array(newLength > 1024 ? newLength : 1024);\n        newData.set(inverseData);\n        source.data = inverseData = newData;\n      }\n      inverseData[j] = data[i];\n      inverseData[j + 1] = data[i + 1];\n      inverseData[j + 2] = originalSource;\n      inverseData[j + 3] = data[i + 3];\n      inverseData[j + 4] = data[i + 4];\n      inverseData[j + 5] = data[i + 5];\n      j += 6;\n      source.dataLength = j;\n      if (j > longestDataLength) longestDataLength = j;\n    }\n\n    // Sort the mappings for each individual source\n    const temp = new Int32Array(longestDataLength);\n    for (const source of sources) {\n      const data = source.data.subarray(0, source.dataLength);\n\n      // Sort lazily for performance\n      let isSorted = false;\n      Object.defineProperty(source, 'data', {\n        get() {\n          if (!isSorted) {\n            temp.set(data);\n            topDownSplitMerge(temp, 0, data.length, data);\n            isSorted = true;\n          }\n          return data;\n        },\n      })\n    }\n\n    // From: https://en.wikipedia.org/wiki/Merge_sort\n    function topDownSplitMerge(B, iBegin, iEnd, A) {\n      if (iEnd - iBegin <= 6) return;\n      const iMiddle = ((iEnd / 6 + iBegin / 6) >> 1) * 6;\n      topDownSplitMerge(A, iBegin, iMiddle, B);\n      topDownSplitMerge(A, iMiddle, iEnd, B);\n      topDownMerge(B, iBegin, iMiddle, iEnd, A);\n    }\n\n    // From: https://en.wikipedia.org/wiki/Merge_sort\n    function topDownMerge(A, iBegin, iMiddle, iEnd, B) {\n      let i = iBegin, j = iMiddle;\n      for (let k = iBegin; k < iEnd; k += 6) {\n        if (i < iMiddle && (j >= iEnd ||\n          // Compare mappings first by original line (index 3) and then by original column (index 4)\n          A[i + 3] < A[j + 3] ||\n          (A[i + 3] === A[j + 3] && A[i + 4] <= A[j + 4])\n        )) {\n          B[k] = A[i];\n          B[k + 1] = A[i + 1];\n          B[k + 2] = A[i + 2];\n          B[k + 3] = A[i + 3];\n          B[k + 4] = A[i + 4];\n          B[k + 5] = A[i + 5];\n          i += 6;\n        } else {\n          B[k] = A[j];\n          B[k + 1] = A[j + 1];\n          B[k + 2] = A[j + 2];\n          B[k + 3] = A[j + 3];\n          B[k + 4] = A[j + 4];\n          B[k + 5] = A[j + 5];\n          j += 6;\n        }\n      }\n    }\n  }\n\n  function parseSourceMap(json) {\n    try {\n      json = JSON.parse(json);\n    } catch (e) {\n      showLoadingError(`The imported source map contains invalid JSON data: ${e && e.message || e}`);\n      throw e;\n    }\n\n    // if (json.version !== 3) {\n    //   showLoadingError(`The imported source map is invalid. Expected the \"version\" field to contain the number 3.`);\n    //   throw new Error('Invalid source map');\n    // }\n\n    if (!(json.sources instanceof Array) || json.sources.some(x => typeof x !== 'string')) {\n      showLoadingError(`The imported source map is invalid. Expected the \"sources\" field to be an array of strings.`);\n      throw new Error('Invalid source map');\n    }\n\n    if (typeof json.mappings !== 'string') {\n      showLoadingError(`The imported source map is invalid. Expected the \"mappings\" field to be a string.`);\n      throw new Error('Invalid source map');\n    }\n\n    const { sources, sourcesContent, names, mappings } = json;\n    const emptyData = new Int32Array(0);\n    for (let i = 0; i < sources.length; i++) {\n      sources[i] = {\n        name: sources[i],\n        content: sourcesContent && sourcesContent[i] || '',\n        data: emptyData,\n        dataLength: 0,\n      };\n    }\n\n    const data = decodeMappings(mappings, sources.length, names.length);\n    generateInverseMappings(sources, data);\n    return { sources, names, data };\n  }\n\n  const toolbarHeight = 32;\n  const statusBarHeight = 32;\n\n  function finishLoading(code, map) {\n    const startTime = Date.now();\n    toolbar.style.display = 'flex';\n    statusBar.style.display = 'flex';\n    canvas.style.display = 'block';\n    const sm = parseSourceMap(map);\n\n    // Populate the file picker\n    let initialSelectedIndex = -1;\n\n    // REPLAY: We want to display sources in sorted order in the dropdown, but the parsing logic\n    // relies on source indices, and needs those to be _unsorted_. We also need the unsorted\n    // indices while hovering to draw arrows correctly.\n    // Track the original unsorted indices in a map keyed by filename so we can pass those through.\n    const unsortedSourceIndices = new Map();\n    sm.sources.forEach( (source, i) => {\n      unsortedSourceIndices.set(source.name, i);\n    })    \n    const sortedSources = sm.sources.slice().sort( (a, b) => a.name.localeCompare(b.name));\n\n    for (let sources = sortedSources, i = 0, n = sortedSources.length; i < n; i++) {\n      const option = document.createElement('option');\n      option.textContent = sources[i].name;\n      fileList.appendChild(option);\n      if (sources[i].name === url) {\n        initialSelectedIndex = i;\n      }\n    }\n\n    // Update the original text area when the source changes\n    const otherSource = index => index === -1 ? null : sortedSources[index].name;\n    const originalName = index => sm.names[index];\n    originalTextArea = null;\n    if (sortedSources.length > 0) {\n      const updateOriginalSource = () => {\n        const source = sortedSources[fileList.selectedIndex];\n        originalTextArea = createTextArea({\n          sourceIndex: fileList.selectedIndex,\n          unsortedSourceIndex: unsortedSourceIndices.get(source.name),\n          text: source.content,\n          mappings: source.data,\n          mappingsOffset: 3,\n          otherSource,\n          originalName,\n          bounds() {\n            return {\n              x: 0,\n              y: toolbarHeight,\n              width: (innerWidth >>> 1) - (splitterWidth >> 1),\n              height: innerHeight - toolbarHeight - statusBarHeight,\n            };\n          },\n        });\n        isInvalid = true;\n      };\n      setTimeout(() => {\n        if (initialSelectedIndex >= 0) {\n          fileList.selectedIndex = initialSelectedIndex;\n        }\n        fileList.onchange = updateOriginalSource;\n        updateOriginalSource();\n      }, 0);\n    } else {\n      const option = document.createElement('option');\n      option.textContent = `(no original code)`;\n      option.disabled = true;\n      fileList.appendChild(option);\n    }\n    fileList.selectedIndex = 0;\n\n    generatedTextArea = createTextArea({\n      sourceIndex: null,\n      text: code,\n      mappings: sm.data,\n      mappingsOffset: 0,\n      otherSource,\n      originalName,\n      bounds() {\n        const x = (innerWidth >> 1) + ((splitterWidth + 1) >> 1);\n        return {\n          x,\n          y: toolbarHeight,\n          width: innerWidth - x,\n          height: innerHeight - toolbarHeight - statusBarHeight,\n        };\n      },\n    });\n\n    isInvalid = true;\n    const endTime = Date.now();\n    console.log(`Finished loading in ${endTime - startTime}ms`);\n  }\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Drawing\n\n  const originalLineColors = [\n    'rgba(25, 133, 255, 0.3)', // Blue\n    'rgba(174, 97, 174, 0.3)', // Purple\n    'rgba(255, 97, 106, 0.3)', // Red\n    'rgba(250, 192, 61, 0.3)', // Yellow\n    'rgba(115, 192, 88, 0.3)', // Green\n  ];\n\n  // Use a striped pattern for bad mappings (good mappings are solid)\n  const patternContours = [\n    [0, 24, 24, 0, 12, 0, 0, 12, 0, 24],\n    [0, 28, 28, 0, 40, 0, 0, 40, 0, 28],\n    [0, 44, 44, 0, 56, 0, 0, 56, 0, 44],\n    [12, 64, 24, 64, 64, 24, 64, 12, 12, 64],\n    [0, 60, 0, 64, 8, 64, 64, 8, 64, 0, 60, 0, 0, 60],\n    [28, 64, 40, 64, 64, 40, 64, 28, 28, 64],\n    [0, 8, 8, 0, 0, 0, 0, 8],\n    [44, 64, 56, 64, 64, 56, 64, 44, 44, 64],\n    [64, 64, 64, 60, 60, 64, 64, 64],\n  ];\n  const badMappingPatterns = originalLineColors.map(color => {\n    let patternCanvas = document.createElement('canvas');\n    let patternContext = patternCanvas.getContext('2d');\n    let ratio, scale, pattern;\n    return (dx, dy) => {\n      if (devicePixelRatio !== ratio) {\n        ratio = devicePixelRatio;\n        scale = Math.round(64 * ratio) / 64;\n        patternCanvas.width = patternCanvas.height = Math.round(64 * scale);\n        patternContext.scale(scale, scale);\n        patternContext.beginPath();\n        for (const contour of patternContours) {\n          for (let i = 0; i < contour.length; i += 2) {\n            if (i === 0) patternContext.moveTo(contour[i], contour[i + 1]);\n            else patternContext.lineTo(contour[i], contour[i + 1]);\n          }\n        }\n        patternContext.fillStyle = color.replace(' 0.3)', ' 0.2)');\n        patternContext.fill();\n        pattern = c.createPattern(patternCanvas, 'repeat');\n      }\n      pattern.setTransform(new DOMMatrix([1 / scale, 0, 0, 1 / scale, dx, dy]));\n      return pattern;\n    };\n  });\n\n  const canvas = document.createElement('canvas');\n  const c = canvas.getContext('2d');\n  const monospaceFont = '14px monospace';\n  const rowHeight = 21;\n  const splitterWidth = 6;\n  const margin = 64;\n  let isInvalid = true;\n  let originalTextArea;\n  let generatedTextArea;\n  let hover = null;\n\n  function splitTextIntoLinesAndRuns(text) {\n    c.font = monospaceFont;\n    const spaceWidth = c.measureText(' ').width;\n    const spacesPerTab = 2;\n    const lines = text.split(/\\r\\n|\\r|\\n/g);\n    const unicodeWidthCache = new Map();\n    let longestLineInColumns = 0;\n\n    for (let line = 0; line < lines.length; line++) {\n      let raw = lines[line];\n      let runs = [];\n      let i = 0;\n      let n = raw.length + 1; // Add 1 for the extra character at the end\n      let column = 0;\n\n      while (i < n) {\n        let startIndex = i;\n        let startColumn = column;\n        let whitespace = 0;\n        let isSingleChunk = false;\n\n        while (i < n) {\n          let c1 = raw.charCodeAt(i);\n          let c2;\n\n          // Draw each tab into its own run\n          if (c1 === 0x09 /* tab */) {\n            if (i > startIndex) break;\n            isSingleChunk = true;\n            column += spacesPerTab;\n            column -= column % spacesPerTab;\n            i++;\n            whitespace = c1;\n            break;\n          }\n\n          // Draw each newline into its own run\n          if (c1 !== c1 /* end of line */) {\n            if (i > startIndex) break;\n            isSingleChunk = true;\n            column++;\n            i++;\n            whitespace = 0x0A /* newline */;\n            break;\n          }\n\n          // Draw each non-ASCII character into its own run (e.g. emoji)\n          if (c1 < 0x20 || c1 > 0x7E) {\n            if (i > startIndex) break;\n            isSingleChunk = true;\n            i++;\n\n            // Consume another code unit if this code unit is a high surrogate\n            // and the next code point is a low surrogate. This handles code\n            // points that span two UTF-16 code units.\n            if (i < n && c1 >= 0xD800 && c1 <= 0xDBFF && (c2 = raw.charCodeAt(i)) >= 0xDC00 && c2 <= 0xDFFF) {\n              i++;\n            }\n\n            // This contains some logic to handle more complex emoji such as \"👯‍♂️\"\n            // which is [U+1F46F, U+200D, U+2642, U+FE0F].\n            while (i < n) {\n              c1 = raw.charCodeAt(i);\n\n              // Consume another code unit if the next code point is a variation selector\n              if ((c1 & ~0xF) === 0xFE00) {\n                i++;\n              }\n\n              // Consume another code unit if the next code point is a skin tone modifier\n              else if (c1 === 0xD83C && i + 1 < n && (c2 = raw.charCodeAt(i + 1)) >= 0xDFFB && c2 <= 0xDFFF) {\n                i += 2;\n              }\n\n              // Consume another code unit and stop if the next code point is a zero-width non-joiner\n              else if (c1 === 0x200C) {\n                i++;\n                break;\n              }\n\n              // Consume another code unit if the next code point is a zero-width joiner\n              else if (c1 === 0x200D) {\n                i++;\n\n                // Consume the next code point that is \"joined\" to this one\n                if (i < n) {\n                  c1 = raw.charCodeAt(i);\n                  i++;\n                  if (c1 >= 0xD800 && c1 <= 0xDBFF && i < n && (c2 = raw.charCodeAt(i)) >= 0xDC00 && c2 <= 0xDFFF) {\n                    i++;\n                  }\n                }\n              }\n\n              else {\n                break;\n              }\n            }\n\n            const key = raw.slice(startIndex, i);\n            let width = unicodeWidthCache.get(key);\n            if (width === void 0) {\n              width = Math.round(c.measureText(key).width / spaceWidth);\n              if (width < 1) width = 1;\n              unicodeWidthCache.set(key, width);\n            }\n            column += width;\n            break;\n          }\n\n          // Draw runs of spaces in their own run\n          if (c1 === 0x20 /* space */) {\n            if (i === startIndex) whitespace = c1;\n            else if (!whitespace) break;\n          } else {\n            if (whitespace) break;\n          }\n\n          column++;\n          i++;\n        }\n\n        runs.push({\n          whitespace,\n          startIndex, endIndex: i,\n          startColumn, endColumn: column,\n          isSingleChunk,\n          text:\n            !whitespace ? raw.slice(startIndex, i) :\n              whitespace === 0x20 /* space */ ? '·'.repeat(i - startIndex) :\n                whitespace === 0x0A /* newline */ ? line + 1 === lines.length ? '∅' : '↵' :\n                  '→' /* tab */,\n        });\n      }\n\n      lines[line] = { raw, runs, endIndex: i, endColumn: column };\n      longestLineInColumns = Math.max(longestLineInColumns, column);\n    }\n\n    return { lines, longestLineInColumns };\n  }\n\n  function createTextArea({ sourceIndex, unsortedSourceIndex, text, mappings, mappingsOffset, otherSource, originalName, bounds }) {\n    const shadowWidth = 16;\n    const textPaddingX = 5;\n    const textPaddingY = 1;\n    const scrollbarThickness = 16;\n    let { lines, longestLineInColumns } = splitTextIntoLinesAndRuns(text);\n    let animate = null;\n    let lastLineIndex = lines.length - 1;\n    let scrollX = 0;\n    let scrollY = 0;\n\n    for (let i = 0, n = mappings.length; i < n; i += 6) {\n      let line = mappings[i + mappingsOffset];\n      let column = mappings[i + mappingsOffset + 1];\n      if (line < lines.length) {\n        const { endIndex, endColumn } = lines[line]\n\n        // Take into account tabs tops and surrogate pairs\n        if (column > endColumn) {\n          column = column - endIndex + endColumn;\n        }\n      } else if (line > lastLineIndex) {\n        lastLineIndex = line;\n      }\n      if (column > longestLineInColumns) {\n        longestLineInColumns = column;\n      }\n    }\n\n    function computeScrollbarsAndClampScroll() {\n      let { width, height } = bounds();\n      c.font = '14px monospace';\n      let columnWidth = c.measureText(' '.repeat(64)).width / 64;\n      let maxScrollX = Math.round(longestLineInColumns * columnWidth + textPaddingX * 2 + margin + scrollbarThickness - width);\n      let maxScrollY = Math.round(lastLineIndex * rowHeight);\n      let scrollbarX = null;\n      let scrollbarY = null;\n\n      scrollX = Math.max(0, Math.min(scrollX, maxScrollX));\n      scrollY = Math.max(0, Math.min(scrollY, maxScrollY));\n\n      if (maxScrollX > 0) {\n        const trackLength = width - margin - scrollbarThickness / 2;\n        scrollbarX = {\n          trackLength,\n          thumbLength: Math.max(scrollbarThickness * 2, trackLength / (1 + maxScrollX / trackLength)),\n        };\n      }\n\n      if (maxScrollY > 0) {\n        const trackLength = height - scrollbarThickness / 2;\n        scrollbarY = {\n          trackLength,\n          thumbLength: Math.max(scrollbarThickness * 2, trackLength / (1 + maxScrollY / trackLength)),\n        };\n      }\n\n      return { columnWidth, maxScrollX, maxScrollY, scrollbarX, scrollbarY };\n    }\n\n    const emptyArray = [];\n\n    function analyzeLine(row, column, fractionalColumn, tabStopBehavior) {\n      let index = column;\n      let firstRun = 0;\n      let nearbyRun = 0;\n      let runs = row < lines.length ? lines[row].runs : emptyArray;\n      let runCount = runs.length;\n      let endOfLineIndex = 0;\n      let endOfLineColumn = 0;\n      let beforeNewlineIndex = 0;\n      let hasTrailingNewline = false;\n\n      if (runCount > 0) {\n        let lastRun = runs[runCount - 1];\n        endOfLineIndex = lastRun.endIndex;\n        endOfLineColumn = lastRun.endColumn;\n        beforeNewlineIndex = lastRun.startIndex;\n        hasTrailingNewline = lastRun.whitespace === 0x0A /* newline */;\n\n        // Binary search to find the first run\n        firstRun = 0;\n        while (runCount > 0) {\n          let step = runCount >> 1;\n          let it = firstRun + step;\n          if (runs[it].endColumn < column) {\n            firstRun = it + 1;\n            runCount -= step + 1;\n          } else {\n            runCount = step;\n          }\n        }\n\n        // Use the last run if we're past the end of the line\n        if (firstRun >= runs.length) firstRun--;\n\n        // Convert column to index\n        nearbyRun = firstRun;\n        while (runs[nearbyRun].startColumn > column && nearbyRun > 0) nearbyRun--;\n        while (runs[nearbyRun].endColumn < column && nearbyRun + 1 < runs.length) nearbyRun++;\n        let run = runs[nearbyRun];\n        if (run.isSingleChunk && column <= run.endColumn) {\n          // A special case for single-character blocks such as tabs and emoji\n          if (\n            (tabStopBehavior === 'round' && fractionalColumn >= (run.startColumn + run.endColumn) / 2) ||\n            (tabStopBehavior === 'floor' && fractionalColumn >= run.endColumn)\n          ) {\n            index = run.endIndex;\n            column = run.endColumn;\n          } else {\n            index = run.startIndex;\n            column = run.startColumn;\n          }\n        } else {\n          index = run.startIndex + column - run.startColumn;\n        }\n      }\n\n      // Binary search to find the first mapping that is >= index\n      let firstMapping = 0;\n      let mappingCount = mappings.length;\n      while (mappingCount > 0) {\n        let step = ((mappingCount / 6) >> 1) * 6;\n        let it = firstMapping + step;\n        let mappingLine = mappings[it + mappingsOffset];\n        if (mappingLine < row || (mappingLine === row && mappings[it + mappingsOffset + 1] < index)) {\n          firstMapping = it + 6;\n          mappingCount -= step + 6;\n        } else {\n          mappingCount = step;\n        }\n      }\n\n      // Back up to the previous mapping if we're at the end of the line or the mapping we found is after us\n      if (firstMapping > 0 && mappings[firstMapping - 6 + mappingsOffset] === row && (\n        firstMapping >= mappings.length ||\n        mappings[firstMapping + mappingsOffset] > row ||\n        mappings[firstMapping + mappingsOffset + 1] > index\n      )) {\n        firstMapping -= 6;\n      }\n\n      // Seek to the first of any duplicate mappings\n      const current = mappings[firstMapping + mappingsOffset + 1];\n      while (firstMapping > 0 && mappings[firstMapping - 6 + mappingsOffset] === row && mappings[firstMapping - 6 + mappingsOffset + 1] === current) {\n        firstMapping -= 6;\n      }\n\n      function columnToIndex(column) {\n        // If there is no underlying line, just use one index per column\n        let index = column;\n        if (runs.length > 0) {\n          while (runs[nearbyRun].startColumn > column && nearbyRun > 0) nearbyRun--;\n          while (runs[nearbyRun].endColumn < column && nearbyRun + 1 < runs.length) nearbyRun++;\n          let run = runs[nearbyRun];\n          index = column === run.endColumn ? run.endIndex : run.endIndex + column - run.startColumn;\n        }\n        return index;\n      }\n\n      function indexToColumn(index) {\n        // If there is no underlying line, just use one column per index\n        let column = index;\n        if (runs.length > 0) {\n          while (runs[nearbyRun].startIndex > index && nearbyRun > 0) nearbyRun--;\n          while (runs[nearbyRun].endIndex < index && nearbyRun + 1 < runs.length) nearbyRun++;\n          let run = runs[nearbyRun];\n          column = index === run.endIndex ? run.endColumn : run.startColumn + index - run.startIndex;\n        }\n        return column;\n      }\n\n      function rangeOfMapping(map) {\n        if (mappings[map + mappingsOffset] !== row) return null;\n        let startIndex = mappings[map + mappingsOffset + 1];\n        let endIndex =\n          startIndex > endOfLineIndex ? startIndex :\n            hasTrailingNewline && startIndex < beforeNewlineIndex ? beforeNewlineIndex :\n              endOfLineIndex;\n        let isLastMappingInLine = false;\n\n        // Ignore subsequent duplicate mappings\n        if (map > 0 && mappings[map - 6 + mappingsOffset] === row && mappings[map - 6 + mappingsOffset + 1] === startIndex) {\n          return null;\n        }\n\n        // Skip past any duplicate mappings after us so we can get to the next non-duplicate mapping\n        while (map + 6 < mappings.length && mappings[map + 6 + mappingsOffset] === row && mappings[map + 6 + mappingsOffset + 1] === startIndex) {\n          map += 6;\n        }\n\n        // Extend this mapping up to the next mapping if it's on the same line\n        if (map + 6 < mappings.length && mappings[map + 6 + mappingsOffset] === row) {\n          endIndex = mappings[map + 6 + mappingsOffset + 1];\n        } else if (endIndex === startIndex) {\n          isLastMappingInLine = true;\n        }\n\n        return {\n          startIndex, startColumn: indexToColumn(startIndex),\n          endIndex, endColumn: indexToColumn(endIndex),\n          isLastMappingInLine,\n        };\n      }\n\n      return {\n        index,\n        column,\n        firstRun,\n        runs,\n        firstMapping,\n        endOfLineIndex,\n        endOfLineColumn,\n        columnToIndex,\n        indexToColumn,\n        rangeOfMapping,\n      };\n    }\n\n    function boxForRange(x, y, row, columnWidth, { startColumn, endColumn }) {\n      const x1 = Math.round(x - scrollX + margin + textPaddingX + startColumn * columnWidth + 1);\n      const x2 = Math.round(x - scrollX + margin + textPaddingX + (startColumn === endColumn ? startColumn * columnWidth + 4 : endColumn * columnWidth) - 1);\n      const y1 = Math.round(y + textPaddingY - scrollY + row * rowHeight + 2);\n      const y2 = Math.round(y + textPaddingY - scrollY + (row + 1) * rowHeight - 2);\n      return [x1, y1, x2, y2];\n    }\n\n    return {\n      sourceIndex,\n      unsortedSourceIndex,\n      bounds,\n\n      getHoverRect() {\n        const row = sourceIndex === null ? hover.mapping.generatedLine : hover.mapping.originalLine;\n        const index = sourceIndex === null ? hover.mapping.generatedColumn : hover.mapping.originalColumn;\n        const column = analyzeLine(row, index, index, 'floor').indexToColumn(index);\n        const { firstMapping, rangeOfMapping } = analyzeLine(row, column, column, 'floor');\n        const range = rangeOfMapping(firstMapping);\n        if (!range) return null;\n        const { x, y } = bounds();\n        const { columnWidth } = computeScrollbarsAndClampScroll();\n        const [x1, y1, x2, y2] = boxForRange(x, y, row, columnWidth, range);\n        return [x1, y1, x2 - x1, y2 - y1];\n      },\n\n      onwheel(e) {\n        let { x, y, width, height } = bounds();\n        if (e.pageX >= x && e.pageX < x + width && e.pageY >= y && e.pageY < y + height) {\n          scrollX = Math.round(scrollX + e.deltaX);\n          scrollY = Math.round(scrollY + e.deltaY);\n          computeScrollbarsAndClampScroll();\n          isInvalid = true;\n          this.onmousemove(e);\n        }\n      },\n\n      onmousemove(e) {\n        const { x, y, width, height } = bounds();\n\n        if (e.pageX >= x + margin && e.pageX < x + width && e.pageY >= y && e.pageY < y + height) {\n          const { columnWidth } = computeScrollbarsAndClampScroll();\n          const fractionalColumn = (e.pageX - x - margin - textPaddingX + scrollX) / columnWidth;\n          const roundedColumn = Math.round(fractionalColumn);\n\n          if (roundedColumn >= 0) {\n            const row = Math.floor((e.pageY - y - textPaddingY + scrollY) / rowHeight);\n\n            if (row >= 0) {\n              const flooredColumn = Math.floor(fractionalColumn);\n              const { index: snappedRoundedIndex, column: snappedRoundedColumn } = analyzeLine(row, roundedColumn, fractionalColumn, 'round');\n              const { index: snappedFlooredIndex, firstMapping, rangeOfMapping } = analyzeLine(row, flooredColumn, fractionalColumn, 'floor');\n\n              // Check to see if this nearest mapping is being hovered\n              let mapping = null;\n              const range = rangeOfMapping(firstMapping);\n              if (range !== null && (\n                // If this is a zero-width mapping, hit-test with the caret\n                (range.isLastMappingInLine && range.startIndex === snappedRoundedIndex) ||\n\n                // Otherwise, determine the bounding-box and hit-test against that\n                (snappedFlooredIndex >= range.startIndex && snappedFlooredIndex < range.endIndex)\n              )) {\n                mapping = {\n                  generatedLine: mappings[firstMapping],\n                  generatedColumn: mappings[firstMapping + 1],\n                  originalSource: mappings[firstMapping + 2],\n                  originalLine: mappings[firstMapping + 3],\n                  originalColumn: mappings[firstMapping + 4],\n                  originalName: mappings[firstMapping + 5],\n                };\n              }\n\n              hover = { sourceIndex, row, column: snappedRoundedColumn, index: snappedRoundedIndex, mapping };\n            }\n          }\n        }\n      },\n\n      onmousedown(e) {\n        const { x, y, width, height } = bounds();\n        const px = e.pageX - x;\n        const py = e.pageY - y;\n        if (px < 0 || py < 0 || px >= width || py >= height) return;\n        const { maxScrollX, maxScrollY, scrollbarX, scrollbarY } = computeScrollbarsAndClampScroll();\n\n        // Handle scrollbar dragging\n        let mousemove;\n        if (scrollbarX && py > height - scrollbarThickness) {\n          let originalScrollX = scrollX;\n          mousemove = e => {\n            scrollX = Math.round(originalScrollX + (e.pageX - x - px) * maxScrollX / (scrollbarX.trackLength - scrollbarX.thumbLength));\n            computeScrollbarsAndClampScroll();\n            isInvalid = true;\n          };\n        } else if (scrollbarY && px > width - scrollbarThickness) {\n          let originalScrollY = scrollY;\n          mousemove = e => {\n            scrollY = Math.round(originalScrollY + (e.pageY - y - py) * maxScrollY / (scrollbarY.trackLength - scrollbarY.thumbLength));\n            computeScrollbarsAndClampScroll();\n            isInvalid = true;\n          };\n        } else {\n          // Scroll to the hover target on click\n          if (hover && hover.mapping) {\n            if (sourceIndex !== null) {\n              generatedTextArea.scrollTo(hover.mapping.generatedColumn, hover.mapping.generatedLine);\n            } else {\n              if (originalTextArea.unsortedSourceIndex !== hover.mapping.originalSource) {\n                fileList.selectedIndex = hover.mapping.originalSource;\n                fileList.onchange();\n              }\n              originalTextArea.scrollTo(hover.mapping.originalColumn, hover.mapping.originalLine);\n            }\n          }\n          return;\n        }\n\n        let mouseup = () => {\n          document.removeEventListener('mousemove', mousemove);\n          document.removeEventListener('mouseup', mouseup);\n        };\n        document.addEventListener('mousemove', mousemove);\n        document.addEventListener('mouseup', mouseup);\n        e.preventDefault();\n      },\n\n      scrollTo(index, row) {\n        const start = Date.now();\n        const startX = scrollX;\n        const startY = scrollY;\n        const { width, height } = bounds();\n        const { columnWidth } = computeScrollbarsAndClampScroll();\n        const { indexToColumn } = analyzeLine(row, index, index, 'floor');\n        const column = indexToColumn(index);\n        const { firstMapping, rangeOfMapping } = analyzeLine(row, column, column, 'floor');\n        const range = rangeOfMapping(firstMapping);\n        const targetColumn = range ? range.startColumn + Math.min((range.endColumn - range.startColumn) / 2, (width - margin) / 4 / columnWidth) : column;\n        const endX = Math.max(0, Math.round(targetColumn * columnWidth - (width - margin) / 2));\n        const endY = Math.max(0, Math.round((row + 0.5) * rowHeight - height / 2));\n        if (startX === endX && startY === endY) return;\n        const duration = 250;\n        animate = () => {\n          isInvalid = true;\n          const current = Date.now();\n          let t = (current - start) / duration;\n          if (t >= 1) {\n            scrollX = endX;\n            scrollY = endY;\n            animate = null;\n          } else {\n            t *= t * (3 - 2 * t); // Use an ease-in-out curve\n            scrollX = startX + (endX - startX) * t;\n            scrollY = startY + (endY - startY) * t;\n          }\n        };\n        animate();\n      },\n\n      draw(bodyStyle) {\n        if (animate) animate();\n\n        const { x, y, width, height } = bounds();\n        const textColor = bodyStyle.color;\n        const backgroundColor = bodyStyle.backgroundColor;\n        const { columnWidth, maxScrollX, maxScrollY, scrollbarX, scrollbarY } = computeScrollbarsAndClampScroll();\n\n        const firstColumn = Math.max(0, Math.floor((scrollX - textPaddingX) / columnWidth));\n        const lastColumn = Math.max(0, Math.ceil((scrollX - textPaddingX + width - margin) / columnWidth));\n        const firstRow = Math.max(0, Math.floor((scrollY - textPaddingY) / rowHeight));\n        const lastRow = Math.max(0, Math.ceil((scrollY - textPaddingY + height) / rowHeight));\n\n        // Populate batches for the text\n        const hoverBoxes = [];\n        const hoveredMapping = hover && hover.mapping;\n        const mappingBatches = [];\n        const badMappingBatches = [];\n        const whitespaceBatch = [];\n        const textBatch = [];\n        let hoveredName = null;\n        for (let i = 0; i < originalLineColors.length; i++) {\n          mappingBatches.push([]);\n          badMappingBatches.push([]);\n        }\n        for (let row = firstRow; row <= lastRow; row++) {\n          let dx = x - scrollX + margin + textPaddingX;\n          let dy = y - scrollY + textPaddingY;\n          dy += (row + 0.7) * rowHeight;\n          const { firstRun, runs, firstMapping, endOfLineColumn, rangeOfMapping, columnToIndex } = analyzeLine(row, firstColumn, firstColumn, 'floor');\n          const lastIndex = columnToIndex(lastColumn);\n\n          // Don't draw any text if the whole line is offscreen\n          if (firstRun < runs.length) {\n            // Scan to find the last run\n            let lastRun = firstRun;\n            while (lastRun + 1 < runs.length && runs[lastRun + 1].startColumn < lastColumn) {\n              lastRun++;\n            }\n\n            // Draw the runs\n            let currentColumn = firstColumn;\n            for (let run = firstRun; run <= lastRun; run++) {\n              let { whitespace, text, startColumn, endColumn, isSingleChunk } = runs[run];\n\n              // Limit the run to the visible columns (but only for ASCII runs)\n              if (!isSingleChunk) {\n                if (startColumn < currentColumn) {\n                  text = text.slice(currentColumn - startColumn);\n                  startColumn = currentColumn;\n                }\n                if (endColumn > lastColumn) {\n                  text = text.slice(0, lastColumn - startColumn);\n                  endColumn = lastColumn;\n                }\n              }\n\n              // Draw whitespace in a separate batch\n              (whitespace ? whitespaceBatch : textBatch).push(text, dx + startColumn * columnWidth, dy);\n              currentColumn = endColumn;\n            }\n          }\n\n          // Draw the mappings\n          for (let map = firstMapping; map < mappings.length; map += 6) {\n            if (mappings[map + mappingsOffset] !== row || mappings[map + mappingsOffset + 1] >= lastIndex) break;\n            if (mappings[map + 2] === -1) continue;\n\n            // Get the bounds of this mapping, which may be empty if it's ignored\n            const range = rangeOfMapping(map);\n            if (range === null) continue;\n            const { startColumn, endColumn } = range;\n            const color = mappings[map + 3] % originalLineColors.length;\n            const [x1, y1, x2, y2] = boxForRange(x, y, row, columnWidth, range);\n\n            // Check if this mapping is hovered\n            let isHovered = false;\n            if (hoveredMapping) {\n              const isGenerated = sourceIndex === null;\n              const hoverIsGenerated = hover.sourceIndex === null;\n              const matchesGenerated =\n                mappings[map] === hoveredMapping.generatedLine &&\n                mappings[map + 1] === hoveredMapping.generatedColumn;\n              const matchesOriginal =\n                mappings[map + 2] === hoveredMapping.originalSource &&\n                mappings[map + 3] === hoveredMapping.originalLine &&\n                mappings[map + 4] === hoveredMapping.originalColumn;\n              isHovered = hoveredMapping && (isGenerated !== hoverIsGenerated\n                // If this is on the opposite pane from the mouse, show all\n                // mappings that match the hovered mapping instead of showing\n                // an exact match.\n                ? matchesGenerated || matchesOriginal\n                // If this is on the same pane as the mouse, only show the exact\n                // mapping instead of showing everything that matches the target\n                // so hovering isn't confusing.\n                : isGenerated ? matchesGenerated : matchesOriginal);\n              if (isGenerated && matchesGenerated && hoveredMapping.originalName !== -1) {\n                hoveredName = {\n                  text: originalName(hoveredMapping.originalName),\n                  x: Math.round(x - scrollX + margin + textPaddingX + range.startColumn * columnWidth - 2),\n                  y: Math.round(y + textPaddingY - scrollY + (row + 1.2) * rowHeight),\n                };\n              }\n            }\n\n            // Add a rectangle to that color's batch\n            if (isHovered) {\n              hoverBoxes.push({ color, rect: [x1 - 2, y1 - 2, x2 - x1 + 4, y2 - y1 + 4] });\n            } else if (row >= lines.length || startColumn > endOfLineColumn) {\n              badMappingBatches[color].push(x1, y1, x2 - x1, y2 - y1);\n            } else if (endColumn > endOfLineColumn) {\n              let x12 = Math.round(x1 + (endOfLineColumn - startColumn) * columnWidth);\n              mappingBatches[color].push(x1, y1, x12 - x1, y2 - y1);\n              badMappingBatches[color].push(x12, y1, x2 - x12, y2 - y1);\n            } else {\n              mappingBatches[color].push(x1, y1, x2 - x1, y2 - y1);\n            }\n          }\n        }\n\n        c.save();\n        c.beginPath();\n        c.rect(x, y, width, height);\n        c.clip();\n\n        // Flush batches for mappings\n        for (let i = 0; i < mappingBatches.length; i++) {\n          let batch = mappingBatches[i];\n          if (batch.length > 0) {\n            c.fillStyle = originalLineColors[i];\n            for (let j = 0; j < batch.length; j += 4) {\n              c.fillRect(batch[j], batch[j + 1], batch[j + 2], batch[j + 3]);\n            }\n          }\n          batch = badMappingBatches[i];\n          if (batch.length > 0) {\n            c.fillStyle = badMappingPatterns[i](-scrollX, -scrollY);\n            for (let j = 0; j < batch.length; j += 4) {\n              c.fillRect(batch[j], batch[j + 1], batch[j + 2], batch[j + 3]);\n            }\n          }\n        }\n\n        let status = '';\n\n        // Draw the hover box for all text areas\n        if (hoverBoxes.length > 0) {\n          // Draw the glows\n          c.shadowBlur = 20;\n          c.fillStyle = 'black';\n          for (const { rect: [rx, ry, rw, rh], color } of hoverBoxes) {\n            c.shadowColor = originalLineColors[color].replace(' 0.3)', ' 1)');\n            c.fillRect(rx - 1, ry - 1, rw + 2, rh + 2);\n          }\n          c.shadowColor = 'transparent';\n\n          // Hollow out the boxes and draw a border around each one\n          for (const { rect: [rx, ry, rw, rh] } of hoverBoxes) {\n            c.clearRect(rx, ry, rw, rh);\n          }\n          c.strokeStyle = textColor;\n          c.lineWidth = 2;\n          for (const { rect: [rx, ry, rw, rh] } of hoverBoxes) {\n            c.strokeRect(rx, ry, rw, rh);\n          }\n\n          // Hollow out the boxes again. This is necessary to remove overlapping\n          // borders from adjacent boxes due to duplicate mappings.\n          for (const { rect: [rx, ry, rw, rh] } of hoverBoxes) {\n            c.clearRect(rx + 2, ry + 1, rw - 4, rh - 2);\n          }\n        }\n\n        // Draw the hover caret, but only for this text area\n        else if (hover && hover.sourceIndex === sourceIndex) {\n          const caretX = Math.round(x - scrollX + margin + textPaddingX + hover.column * columnWidth);\n          const caretY = Math.round(y - scrollY + textPaddingY + hover.row * rowHeight);\n          c.fillStyle = textColor;\n          c.globalAlpha = 0.5;\n          c.fillRect(caretX, caretY, 1, rowHeight);\n          c.globalAlpha = 1;\n          status = `Line ${hover.row + 1}, Offset ${hover.index}`;\n        }\n\n        // Update the status bar\n        if (hoveredMapping && hoveredMapping.originalColumn !== -1) {\n          if (sourceIndex === null) {\n            status = `Line ${hoveredMapping.generatedLine + 1}, Offset ${hoveredMapping.generatedColumn}`;\n          } else {\n            status = `Line ${hoveredMapping.originalLine + 1}, Offset ${hoveredMapping.originalColumn}`;\n            if (hoveredMapping.originalSource !== sourceIndex) {\n              status += ` in ${otherSource(hoveredMapping.originalSource)}`;\n            }\n          }\n        }\n        (sourceIndex === null ? generatedStatus : originalStatus).textContent = status;\n\n        // Flush batches for the text\n        c.textBaseline = 'alphabetic';\n        c.textAlign = 'left';\n        if (whitespaceBatch.length > 0) {\n          c.fillStyle = 'rgba(150, 150, 150, 0.4)';\n          for (let j = 0; j < whitespaceBatch.length; j += 3) {\n            c.fillText(whitespaceBatch[j], whitespaceBatch[j + 1], whitespaceBatch[j + 2]);\n          }\n        }\n        if (textBatch.length > 0) {\n          c.fillStyle = textColor;\n          for (let j = 0; j < textBatch.length; j += 3) {\n            c.fillText(textBatch[j], textBatch[j + 1], textBatch[j + 2]);\n          }\n        }\n\n        // Draw the original name tooltip\n        if (hoveredName) {\n          const { text, x, y } = hoveredName;\n          const w = 2 * textPaddingX + c.measureText(text).width;\n          const h = rowHeight;\n          const r = 4;\n          c.beginPath();\n          c.arc(x + r, y + r, r, - Math.PI, -Math.PI / 2, false);\n          c.arc(x + w - r, y + r, r, -Math.PI / 2, 0, false);\n          c.arc(x + w - r, y + h - r, r, 0, Math.PI / 2, false);\n          c.arc(x + r, y + h - r, r, Math.PI / 2, Math.PI, false);\n          c.save();\n          c.shadowColor = 'rgba(0, 0, 0, 0.5)';\n          c.shadowOffsetY = 3;\n          c.shadowBlur = 10;\n          c.fillStyle = textColor;\n          c.fill();\n          c.restore();\n          c.fillStyle = backgroundColor;\n          c.fillText(text, x + textPaddingX, y + 0.7 * rowHeight);\n        }\n\n        // Draw the margin shadow\n        if (scrollX > 0) {\n          let gradient = c.createLinearGradient(x + margin, 0, x + margin + shadowWidth, 0);\n          for (let i = 0; i <= 10; i++) {\n            let t = i / 10;\n            gradient.addColorStop(t, `rgba(0, 0, 0, ${(1 - t) * (1 - t) * 0.2})`);\n          }\n          c.fillStyle = gradient;\n          c.fillRect(x + margin, y, shadowWidth, height);\n        }\n\n        // Draw the scrollbars\n        if (scrollbarX) {\n          let dx = x + margin + scrollX / maxScrollX * (scrollbarX.trackLength - scrollbarX.thumbLength);\n          let dy = y + height - scrollbarThickness;\n          c.fillStyle = 'rgba(127, 127, 127, 0.5)';\n          c.beginPath();\n          c.arc(dx + scrollbarThickness / 2, dy + scrollbarThickness / 2, scrollbarThickness / 4, Math.PI / 2, Math.PI * 3 / 2, false);\n          c.arc(dx + scrollbarX.thumbLength - scrollbarThickness / 2, dy + scrollbarThickness / 2, scrollbarThickness / 4, -Math.PI / 2, Math.PI / 2, false);\n          c.fill();\n        }\n        if (scrollbarY) {\n          let dx = x + width - scrollbarThickness;\n          let dy = y + scrollY / maxScrollY * (scrollbarY.trackLength - scrollbarY.thumbLength);\n          c.fillStyle = 'rgba(127, 127, 127, 0.5)';\n          c.beginPath();\n          c.arc(dx + scrollbarThickness / 2, dy + scrollbarThickness / 2, scrollbarThickness / 4, -Math.PI, 0, false);\n          c.arc(dx + scrollbarThickness / 2, dy + scrollbarY.thumbLength - scrollbarThickness / 2, scrollbarThickness / 4, 0, Math.PI, false);\n          c.fill();\n        }\n\n        // Draw the margin\n        c.fillStyle = backgroundColor;\n        c.fillRect(x, y, margin, height);\n        c.fillStyle = 'rgba(127, 127, 127, 0.1)';\n        c.fillRect(x, y, margin, height);\n        c.fillStyle = 'rgba(127, 127, 127, 0.5)';\n        c.fillRect(x + margin - 1, y, 1, height);\n        c.textAlign = 'right';\n        c.fillStyle = textColor;\n        c.font = '11px monospace';\n        for (let row = firstRow; row <= lastRow && row <= lastLineIndex; row++) {\n          let dx = x + margin - textPaddingX;\n          let dy = y - scrollY + textPaddingY;\n          dy += (row + 0.6) * rowHeight;\n          c.globalAlpha = row < lines.length ? 0.625 : 0.25;\n          c.fillText((row + 1).toString(), dx, dy);\n        }\n        c.font = monospaceFont;\n        c.globalAlpha = 1;\n\n        c.restore();\n      },\n    };\n  }\n\n  function draw() {\n    requestAnimationFrame(draw);\n    if (!isInvalid) return;\n    isInvalid = false;\n\n    c.clearRect(0, 0, innerWidth, innerHeight);\n    if (!generatedTextArea) return;\n\n    const bodyStyle = getComputedStyle(document.body);\n    if (originalTextArea) originalTextArea.draw(bodyStyle);\n    generatedTextArea.draw(bodyStyle);\n\n    // Draw the splitter\n    c.fillStyle = 'rgba(127, 127, 127, 0.2)';\n    c.fillRect((innerWidth >>> 1) - (splitterWidth >> 1), toolbarHeight, splitterWidth, innerHeight - toolbarHeight - statusBarHeight);\n\n    // Draw the arrow between the two hover areas\n    if (hover && hover.mapping && originalTextArea && originalTextArea.unsortedSourceIndex === hover.mapping.originalSource) {\n      const originalHoverRect = originalTextArea.getHoverRect();\n      const generatedHoverRect = generatedTextArea.getHoverRect();\n      if (originalHoverRect && generatedHoverRect) {\n        const textColor = bodyStyle.color;\n        const originalBounds = originalTextArea.bounds();\n        const generatedBounds = generatedTextArea.bounds();\n        const originalArrowHead = hover.sourceIndex === generatedTextArea.unsortedSourceIndex;\n        const generatedArrowHead = hover.sourceIndex === originalTextArea.unsortedSourceIndex;\n        const [ox, oy, ow, oh] = originalHoverRect;\n        const [gx, gy, , gh] = generatedHoverRect;\n        const x1 = Math.min(ox + ow, originalBounds.x + originalBounds.width) + (originalArrowHead ? 10 : 2);\n        const x2 = Math.max(gx, generatedBounds.x + margin) - (generatedArrowHead ? 10 : 2);\n        const y1 = oy + oh / 2;\n        const y2 = gy + gh / 2;\n\n        c.save();\n        c.beginPath();\n        c.rect(0, toolbarHeight, innerWidth, innerHeight - toolbarHeight - statusBarHeight);\n        c.clip();\n\n        // Draw the curve\n        c.beginPath();\n        c.moveTo(x1, y1);\n        c.bezierCurveTo(\n          (x1 + 2 * x2) / 3 + margin / 2, y1,\n          (x1 * 2 + x2) / 3 - margin / 2, y2,\n          x2, y2);\n        c.strokeStyle = textColor;\n        c.lineWidth = 2;\n        c.stroke();\n\n        // Draw the arrow heads\n        c.beginPath();\n        if (originalArrowHead) {\n          c.moveTo(x1 - 10, y1);\n          c.lineTo(x1, y1 + 5);\n          c.lineTo(x1, y1 - 5);\n        }\n        if (generatedArrowHead) {\n          c.moveTo(x2 + 10, y2);\n          c.lineTo(x2, y2 + 5);\n          c.lineTo(x2, y2 - 5);\n        }\n        c.fillStyle = textColor;\n        c.fill();\n\n        c.restore();\n      }\n    }\n  }\n\n  document.onmousemove = e => {\n    let oldHover = hover;\n    hover = null;\n\n    if (originalTextArea) originalTextArea.onmousemove(e);\n    if (generatedTextArea) generatedTextArea.onmousemove(e);\n\n    if (JSON.stringify(hover) !== JSON.stringify(oldHover)) {\n      isInvalid = true;\n    }\n  };\n\n  document.onmousedown = e => {\n    if (originalTextArea) originalTextArea.onmousedown(e);\n    if (generatedTextArea) generatedTextArea.onmousedown(e);\n  };\n\n  onblur = () => {\n    if (hover) {\n      hover = null;\n      isInvalid = true;\n    }\n  };\n\n  canvas.addEventListener('wheel', e => {\n    e.preventDefault();\n    if (originalTextArea) originalTextArea.onwheel(e);\n    if (generatedTextArea) generatedTextArea.onwheel(e);\n  }, { passive: false });\n\n  onresize = () => {\n    let width = innerWidth;\n    let height = innerHeight;\n    let ratio = devicePixelRatio;\n    canvas.style.width = width + 'px';\n    canvas.style.height = height + 'px';\n    canvas.width = Math.round(width * ratio);\n    canvas.height = Math.round(height * ratio);\n    c.scale(ratio, ratio);\n    isInvalid = true;\n  };\n\n  document.body.appendChild(canvas);\n  onresize();\n  draw(); \n\n  let query = matchMedia('(prefers-color-scheme: dark)');\n  try {\n    query.addEventListener('change', () => isInvalid = true);\n  } catch (e) {\n    query.addListener(() => isInvalid = true);\n  }\n\n  finishLoading(source, sourcemap, url);\n}\n","import { useRouter } from \"next/router\";\nimport React, { useEffect, useState } from \"react\";\n\n// eslint-disable-next-line no-restricted-imports\nimport { client, initSocket } from \"protocol/socket\";\nimport renderSourcemap from \"third-party/sourcemap-visualizer/sourcemapVisualizer\";\nimport { UIStore } from \"ui/actions\";\nimport { onUnprocessedRegions, setAppMode } from \"ui/actions/app\";\nimport { getAccessibleRecording } from \"ui/actions/session\";\nimport { ExpectedErrorScreen } from \"ui/components/shared/Error\";\nimport LoadingScreen from \"ui/components/shared/LoadingScreen\";\nimport { useGetRecordingId } from \"ui/hooks/recordings\";\nimport { useAppDispatch, useAppStore } from \"ui/setup/hooks\";\nimport { ExpectedError } from \"ui/state/app\";\nimport tokenManager from \"ui/utils/tokenManager\";\n\ntype SourcemapResult =\n  | {\n      source: string;\n      map: string | undefined;\n      url: string | undefined;\n    }\n  | {\n      error: string;\n    };\n\nasync function loadSourceMap(\n  recordingId: string,\n  sourceId: string,\n  store: UIStore\n): Promise<SourcemapResult> {\n  try {\n    const recording = await store.dispatch(getAccessibleRecording(recordingId));\n    if (!recording) {\n      return { error: \"The recording is not accessible\" };\n    }\n\n    const dispatchUrl =\n      new URL(location.href).searchParams.get(\"dispatch\") || process.env.NEXT_PUBLIC_DISPATCH_URL!;\n\n    const socket = initSocket(dispatchUrl);\n    if (typeof window !== \"undefined\") {\n      if (window.app != null) {\n        // @ts-ignore\n        window.app.socket = socket;\n      }\n    }\n\n    const token = await tokenManager.getToken();\n    if (token.token) {\n      await client.Authentication.setAccessToken({ accessToken: token.token });\n    }\n    const { sessionId } = await client.Recording.createSession({ recordingId });\n\n    // this will show a progress bar in the LoadingScreen, note that the\n    // sourcemap visualizer is shown as soon as the requested source and its sourcemap\n    // have been loaded, which may happen before the progress bar reaches 100%\n    client.Session.ensureProcessed({ level: \"basic\" }, sessionId);\n    client.Session.addUnprocessedRegionsListener(regions =>\n      store.dispatch(onUnprocessedRegions(regions))\n    );\n\n    // find the requested source\n    const result = await Promise.race([\n      client.Debugger.findSources({}, sessionId),\n      new Promise<{ id: string; url?: string }>(resolve => {\n        client.Debugger.addNewSourceListener(newSource => {\n          if (newSource.sourceId === sourceId) {\n            if (newSource.generatedSourceIds?.length) {\n              const url = newSource.url ? decodeURI(newSource.url) : undefined;\n              resolve({ id: newSource.generatedSourceIds[0], url });\n            } else {\n              resolve({ id: sourceId });\n            }\n          }\n        });\n      }),\n    ]);\n    if (!(\"id\" in result)) {\n      return { error: \"Source not found\" };\n    }\n\n    // load the requested source's contents and sourcemap\n    const { id: generatedSourceId, url } = result;\n    const { contents: source } = await client.Debugger.getSourceContents(\n      { sourceId: generatedSourceId },\n      sessionId\n    );\n    const { contents: map } = await client.Debugger.getSourceMap(\n      { sourceId: generatedSourceId },\n      sessionId\n    );\n    return { source, map, url };\n  } catch (error: any) {\n    return { error: error.message || \"Failed to load sourcemap\" };\n  }\n}\n\nfunction SourcemapVisualizer({\n  source,\n  map,\n  url,\n}: {\n  source: string;\n  map: string;\n  url: string | undefined;\n}) {\n  const dispatch = useAppDispatch();\n\n  // TODO [hbenl] Fix react-hooks/exhaustive-deps\n  // Is this really something we only want to do on-mount (even if source/map/url change)?\n  useEffect(() => {\n    document.body.className = \"sourcemap-visualizer\";\n    dispatch(setAppMode(\"sourcemap-visualizer\"));\n    renderSourcemap(source, map, url, document);\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return (\n    <>\n      <div id=\"toolbar\">\n        <div id=\"fileListParent\">\n          <select id=\"fileList\"></select>\n        </div>\n      </div>\n      <div id=\"statusBar\">\n        <section>\n          <div id=\"originalStatus\"></div>\n        </section>\n        <section>\n          <div id=\"generatedStatus\"></div>\n        </section>\n      </div>\n    </>\n  );\n}\n\nexport default function SourceMapLoader() {\n  const store = useAppStore();\n  const recordingId = useGetRecordingId();\n  const sourceId = useRouter().query.sourceId as string;\n  const [sourcemapResult, setSourcemapResult] = useState<SourcemapResult | undefined>();\n\n  useEffect(() => {\n    loadSourceMap(recordingId, sourceId, store).then(setSourcemapResult);\n  }, [recordingId, sourceId, store]);\n\n  if (!sourcemapResult) {\n    return <LoadingScreen fallbackMessage=\"Loading source information...\" />;\n  }\n\n  if (\"error\" in sourcemapResult) {\n    const error: ExpectedError = {\n      message: \"Error\",\n      content: sourcemapResult.error,\n    };\n    return <ExpectedErrorScreen error={error} />;\n  }\n  if (!sourcemapResult.map) {\n    const error: ExpectedError = {\n      message: \"No sourcemap\",\n      content: \"There is no sourcemap for this source\",\n    };\n    return <ExpectedErrorScreen error={error} />;\n  }\n\n  return (\n    <SourcemapVisualizer\n      source={sourcemapResult.source}\n      map={sourcemapResult.map}\n      url={sourcemapResult.url}\n    />\n  );\n}\n","\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/recording/[id]/sourcemap/[sourceId]\",\n      function () {\n        return require(\"private-next-pages/recording/[id]/sourcemap/[sourceId].tsx\");\n      }\n    ]);\n    if(module.hot) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/recording/[id]/sourcemap/[sourceId]\"])\n      });\n    }\n  "],"names":["renderSourcemap","source","sourcemap","url","document","toolbar","getElementById","statusBar","originalStatus","generatedStatus","vlqTable","Uint8Array","vlqChars","i","length","charCodeAt","parseSourceMap","json","JSON","parse","e","showLoadingError","message","sources","Array","some","x","Error","mappings","sourcesContent","names","emptyData","Int32Array","name","content","data","dataLength","sourcesCount","namesCount","n","generatedLine","generatedLineStart","generatedColumn","originalSource","originalLine","originalColumn","originalName","needToSortGeneratedColumns","decodeError","text","error","decodeVLQ","shift","vlq","c","stringify","String","fromCharCode","index","j","genL","genC","origS","origL","origC","origN","k","generatedColumnDelta","isOriginalSourceMissing","isOriginalNameMissing","newData","set","subarray","decodeMappings","longestDataLength","inverseData","newLength","temp","isSorted","Object","defineProperty","get","topDownSplitMerge","B","iBegin","iEnd","A","iMiddle","topDownMerge","generateInverseMappings","toolbarHeight","originalLineColors","patternContours","badMappingPatterns","map","color","ratio","scale","pattern","patternCanvas","createElement","patternContext","getContext","dx","dy","devicePixelRatio","Math","round","width","height","beginPath","contour","moveTo","lineTo","fillStyle","replace","fill","createPattern","setTransform","DOMMatrix","canvas","monospaceFont","rowHeight","splitterWidth","margin","originalTextArea","generatedTextArea","isInvalid","hover","createTextArea","sourceIndex","unsortedSourceIndex","mappingsOffset","otherSource","bounds","scrollbarThickness","lines","longestLineInColumns","font","spaceWidth","measureText","split","unicodeWidthCache","Map","line","raw","runs","column","startIndex","startColumn","whitespace","isSingleChunk","c2","c1","key","slice","push","endIndex","endColumn","repeat","max","splitTextIntoLinesAndRuns","animate","lastLineIndex","scrollX","scrollY","computeScrollbarsAndClampScroll","columnWidth","maxScrollX","textPaddingX","maxScrollY","scrollbarX","scrollbarY","min","trackLength","thumbLength","emptyArray","analyzeLine","row","fractionalColumn","tabStopBehavior","firstRun","nearbyRun","runCount","endOfLineIndex","endOfLineColumn","beforeNewlineIndex","hasTrailingNewline","lastRun","step","it","run","firstMapping","mappingCount","mappingLine","current","indexToColumn","columnToIndex","rangeOfMapping","isLastMappingInLine","boxForRange","y","x1","x2","getHoverRect","mapping","range","y1","y2","onwheel","pageX","pageY","deltaX","deltaY","this","onmousemove","roundedColumn","floor","flooredColumn","snappedRoundedIndex","snappedRoundedColumn","snappedFlooredIndex","onmousedown","px","py","mousemove","originalScrollX","scrollTo","fileList","selectedIndex","onchange","originalScrollY","mouseup","removeEventListener","addEventListener","preventDefault","start","Date","now","startX","startY","targetColumn","endX","endY","t","draw","bodyStyle","textColor","backgroundColor","firstColumn","lastColumn","ceil","firstRow","lastRow","hoverBoxes","hoveredMapping","mappingBatches","badMappingBatches","whitespaceBatch","textBatch","hoveredName","lastIndex","currentColumn","isHovered","isGenerated","hoverIsGenerated","matchesGenerated","matchesOriginal","rect","x12","save","clip","batch","fillRect","status","shadowBlur","rx","ry","rw","rh","shadowColor","clearRect","strokeStyle","lineWidth","strokeRect","caretX","caretY","globalAlpha","textContent","textBaseline","textAlign","fillText","w","h","r","arc","PI","shadowOffsetY","restore","gradient","createLinearGradient","addColorStop","toString","oldHover","onblur","passive","onresize","innerWidth","innerHeight","style","body","appendChild","requestAnimationFrame","getComputedStyle","originalHoverRect","generatedHoverRect","originalBounds","generatedBounds","originalArrowHead","generatedArrowHead","ox","oy","ow","oh","gx","gy","gh","bezierCurveTo","stroke","query","matchMedia","addListener","code","startTime","display","sm","initialSelectedIndex","unsortedSourceIndices","forEach","sortedSources","sort","a","b","localeCompare","option","updateOriginalSource","setTimeout","disabled","endTime","console","log","finishLoading","SourcemapVisualizer","dispatch","useAppDispatch","useEffect","className","setAppMode","id","SourceMapLoader","store","useAppStore","recordingId","useGetRecordingId","sourceId","useRouter","sourcemapResult","setSourcemapResult","useState","async","getAccessibleRecording","dispatchUrl","URL","location","href","searchParams","process","env","NEXT_PUBLIC_DISPATCH_URL","socket","initSocket","window","app","token","tokenManager","client","accessToken","sessionId","level","regions","onUnprocessedRegions","result","Promise","race","resolve","newSource","generatedSourceIds","decodeURI","undefined","generatedSourceId","contents","loadSourceMap","then","LoadingScreen","fallbackMessage","__NEXT_P"],"sourceRoot":""}