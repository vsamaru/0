{"version":3,"file":"static/chunks/109-77c237e13254cee8.js","mappings":"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","sources":["webpack://_N_E/./src/devtools/client/debugger/src/workers/parser/utils/helpers.js","webpack://_N_E/./src/devtools/client/debugger/src/workers/parser/utils/inferClassName.js","webpack://_N_E/./src/devtools/client/debugger/src/workers/parser/utils/simple-path.js","webpack://_N_E/./src/devtools/client/debugger/src/workers/parser/getSymbols.js","webpack://_N_E/./src/devtools/client/debugger/src/workers/parser/utils/getFunctionName.js","webpack://_N_E/./src/devtools/client/debugger/src/workers/parser/sources.js","webpack://_N_E/./src/devtools/client/debugger/src/workers/parser/utils/ast.js","webpack://_N_E/./src/devtools/client/debugger/src/workers/parser/validate.js","webpack://_N_E/./src/devtools/shared/worker-utils.js"],"sourcesContent":["/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */\n\n//\n\nimport generate from \"@babel/generator\";\nimport * as t from \"@babel/types\";\n\nexport function isFunction(node) {\n  return (\n    t.isFunction(node) ||\n    t.isArrowFunctionExpression(node) ||\n    t.isObjectMethod(node) ||\n    t.isClassMethod(node)\n  );\n}\n\nexport function isAwaitExpression(path) {\n  const { node, parent } = path;\n  return (\n    t.isAwaitExpression(node) || t.isAwaitExpression(parent.init) || t.isAwaitExpression(parent)\n  );\n}\n\nexport function isYieldExpression(path) {\n  const { node, parent } = path;\n  return (\n    t.isYieldExpression(node) || t.isYieldExpression(parent.init) || t.isYieldExpression(parent)\n  );\n}\n\nexport function getCode(node) {\n  return generate(node).code;\n}\n\nexport function getComments(ast) {\n  if (!ast || !ast.comments) {\n    return [];\n  }\n  return ast.comments.map(comment => ({\n    name: comment.location,\n    location: comment.loc,\n  }));\n}\n\nexport function getSpecifiers(specifiers) {\n  if (!specifiers) {\n    return [];\n  }\n\n  return specifiers.map(specifier => specifier.local && specifier.local.name);\n}\n\nexport function isComputedExpression(expression) {\n  return /^\\[/m.test(expression);\n}\n\nexport function getMemberExpression(root) {\n  function _getMemberExpression(node, expr) {\n    if (t.isMemberExpression(node)) {\n      expr = [node.property.name].concat(expr);\n      return _getMemberExpression(node.object, expr);\n    }\n\n    if (t.isCallExpression(node)) {\n      return [];\n    }\n\n    if (t.isThisExpression(node)) {\n      return [\"this\"].concat(expr);\n    }\n\n    return [node.name].concat(expr);\n  }\n\n  const expr = _getMemberExpression(root, []);\n  return expr.join(\".\");\n}\n\nexport function getVariables(dec) {\n  if (!dec.id) {\n    return [];\n  }\n\n  if (t.isArrayPattern(dec.id)) {\n    if (!dec.id.elements) {\n      return [];\n    }\n\n    // NOTE: it's possible that an element is empty or has several variables\n    // e.g. const [, a] = arr\n    // e.g. const [{a, b }] = 2\n    return dec.id.elements\n      .filter(element => element)\n      .map(element => ({\n        name: t.isAssignmentPattern(element)\n          ? element.left.name\n          : element.name || (element.argument && element.argument.name),\n        location: element.loc,\n      }))\n      .filter(({ name }) => name);\n  }\n\n  return [\n    {\n      name: dec.id.name,\n      location: dec.loc,\n    },\n  ];\n}\n\nexport function getPatternIdentifiers(pattern) {\n  let items = [];\n  if (t.isObjectPattern(pattern)) {\n    items = pattern.properties.map(({ value }) => value);\n  }\n\n  if (t.isArrayPattern(pattern)) {\n    items = pattern.elements;\n  }\n\n  return getIdentifiers(items);\n}\n\nfunction getIdentifiers(items) {\n  let ids = [];\n  items.forEach(function (item) {\n    if (t.isObjectPattern(item) || t.isArrayPattern(item)) {\n      ids = ids.concat(getPatternIdentifiers(item));\n    } else if (t.isIdentifier(item)) {\n      const { start, end } = item.loc;\n      ids.push({\n        name: item.name,\n        expression: item.name,\n        location: { start, end },\n      });\n    }\n  });\n  return ids;\n}\n\n// Top Level checks the number of \"body\" nodes in the ancestor chain\n// if the node is top-level, then it shoul only have one body.\nexport function isTopLevel(ancestors) {\n  return ancestors.filter(ancestor => ancestor.key == \"body\").length == 1;\n}\n\nexport function nodeLocationKey(a) {\n  const { start, end } = a.location;\n  return `${start.line}:${start.column}:${end.line}:${end.column}`;\n}\n\nexport function getFunctionParameterNames(path) {\n  if (path.node.params != null) {\n    return path.node.params.map(param => {\n      if (param.type !== \"AssignmentPattern\") {\n        return param.name;\n      }\n\n      // Parameter with default value\n      if (param.left.type === \"Identifier\" && param.right.type === \"Identifier\") {\n        return `${param.left.name} = ${param.right.name}`;\n      } else if (param.left.type === \"Identifier\" && param.right.type === \"StringLiteral\") {\n        return `${param.left.name} = ${param.right.value}`;\n      } else if (param.left.type === \"Identifier\" && param.right.type === \"ObjectExpression\") {\n        return `${param.left.name} = {}`;\n      } else if (param.left.type === \"Identifier\" && param.right.type === \"ArrayExpression\") {\n        return `${param.left.name} = []`;\n      } else if (param.left.type === \"Identifier\" && param.right.type === \"NullLiteral\") {\n        return `${param.left.name} = null`;\n      }\n    });\n  }\n  return [];\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */\n\n//\nimport * as t from \"@babel/types\";\n\n// the function class is inferred from a call like\n// createClass or extend\nfunction fromCallExpression(callExpression) {\n  const whitelist = [\"extend\", \"createClass\"];\n  const callee = callExpression.node.callee;\n  if (!callee) {\n    return null;\n  }\n\n  const name = t.isMemberExpression(callee) ? callee.property.name : callee.name;\n\n  if (!whitelist.includes(name)) {\n    return null;\n  }\n\n  const variable = callExpression.findParent(p => t.isVariableDeclarator(p.node));\n  if (variable) {\n    return variable.node.id.name;\n  }\n\n  const assignment = callExpression.findParent(p => t.isAssignmentExpression(p.node));\n\n  if (!assignment) {\n    return null;\n  }\n\n  const left = assignment.node.left;\n\n  if (left.name) {\n    return name;\n  }\n\n  if (t.isMemberExpression(left)) {\n    return left.property.name;\n  }\n\n  return null;\n}\n\n// the function class is inferred from a prototype assignment\n// e.g. TodoClass.prototype.render = function() {}\nfunction fromPrototype(assignment) {\n  const left = assignment.node.left;\n  if (!left) {\n    return null;\n  }\n\n  if (\n    t.isMemberExpression(left) &&\n    left.object &&\n    t.isMemberExpression(left.object) &&\n    left.object.property.identifier === \"prototype\"\n  ) {\n    return left.object.object.name;\n  }\n\n  return null;\n}\n\n// infer class finds an appropriate class for functions\n// that are defined inside of a class like thing.\n// e.g. `class Foo`, `TodoClass.prototype.foo`,\n//      `Todo = createClass({ foo: () => {}})`\nexport function inferClassName(path) {\n  const classDeclaration = path.findParent(p => t.isClassDeclaration(p.node));\n  if (classDeclaration) {\n    return classDeclaration.node.id.name;\n  }\n\n  const callExpression = path.findParent(p => t.isCallExpression(p.node));\n  if (callExpression) {\n    return fromCallExpression(callExpression);\n  }\n\n  const assignment = path.findParent(p => t.isAssignmentExpression(p.node));\n  if (assignment) {\n    return fromPrototype(assignment);\n  }\n\n  return null;\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */\n\n//\n\nexport default function createSimplePath(ancestors) {\n  if (ancestors.length === 0) {\n    return null;\n  }\n\n  // Slice the array because babel-types traverse may continue mutating\n  // the ancestors array in later traversal logic.\n  return new SimplePath(ancestors.slice());\n}\n\n/**\n * Mimics @babel/traverse's NodePath API in a simpler fashion that isn't as\n * heavy, but still allows the ease of passing paths around to process nested\n * AST structures.\n */\nclass SimplePath {\n  _index;\n  _ancestors;\n  _ancestor;\n\n  _parentPath;\n\n  constructor(ancestors, index = ancestors.length - 1) {\n    if (index < 0 || index >= ancestors.length) {\n      console.error(ancestors);\n      throw new Error(\"Created invalid path\");\n    }\n\n    this._ancestors = ancestors;\n    this._ancestor = ancestors[index];\n    this._index = index;\n  }\n\n  get parentPath() {\n    let path = this._parentPath;\n    if (path === undefined) {\n      if (this._index === 0) {\n        path = null;\n      } else {\n        path = new SimplePath(this._ancestors, this._index - 1);\n      }\n      this._parentPath = path;\n    }\n\n    return path;\n  }\n\n  get parent() {\n    return this._ancestor.node;\n  }\n\n  get node() {\n    const { node, key, index } = this._ancestor;\n\n    if (typeof index === \"number\") {\n      return node[key][index];\n    }\n\n    return node[key];\n  }\n\n  get key() {\n    return this._ancestor.key;\n  }\n\n  set node(replacement) {\n    if (this.type !== \"Identifier\") {\n      throw new Error(\n        \"Replacing anything other than leaf nodes is undefined behavior \" + \"in t.traverse()\"\n      );\n    }\n\n    const { node, key, index } = this._ancestor;\n    if (typeof index === \"number\") {\n      node[key][index] = replacement;\n    } else {\n      node[key] = replacement;\n    }\n  }\n\n  get type() {\n    return this.node.type;\n  }\n\n  get inList() {\n    return typeof this._ancestor.index === \"number\";\n  }\n\n  get containerIndex() {\n    const { index } = this._ancestor;\n\n    if (typeof index !== \"number\") {\n      throw new Error(\"Cannot get index of non-array node\");\n    }\n\n    return index;\n  }\n\n  get depth() {\n    return this._index;\n  }\n\n  replace(node) {\n    this.node = node;\n  }\n\n  find(predicate) {\n    for (let path = this; path; path = path.parentPath) {\n      if (predicate(path)) {\n        return path;\n      }\n    }\n    return null;\n  }\n\n  findParent(predicate) {\n    if (!this.parentPath) {\n      throw new Error(\"Cannot use findParent on root path\");\n    }\n\n    return this.parentPath.find(predicate);\n  }\n\n  getSibling(offset) {\n    const { node, key, index } = this._ancestor;\n\n    if (typeof index !== \"number\") {\n      throw new Error(\"Non-array nodes do not have siblings\");\n    }\n\n    const container = node[key];\n\n    const siblingIndex = index + offset;\n    if (siblingIndex < 0 || siblingIndex >= container.length) {\n      return null;\n    }\n\n    return new SimplePath(\n      this._ancestors.slice(0, -1).concat([{ node, key, index: siblingIndex }])\n    );\n  }\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */\n\n//\n\nimport * as t from \"@babel/types\";\n\nimport { traverseAst } from \"./utils/ast\";\nimport getFunctionName from \"./utils/getFunctionName\";\nimport { getCode, getFunctionParameterNames, isFunction } from \"./utils/helpers\";\nimport { inferClassName } from \"./utils/inferClassName\";\nimport createSimplePath from \"./utils/simple-path\";\n\nlet symbolDeclarations = new Map();\n\n// eslint-disable-next-line complexity\nfunction extractSymbol(path, symbols, state) {\n  if (isFunction(path)) {\n    const name = getFunctionName(path.node, path.parent);\n\n    if (!state.fnCounts[name]) {\n      state.fnCounts[name] = 0;\n    }\n    const index = state.fnCounts[name]++;\n\n    symbols.functions.push({\n      name,\n      klass: inferClassName(path),\n      location: path.node.loc,\n      parameterNames: getFunctionParameterNames(path),\n      identifier: path.node.id,\n      // indicates the occurence of the function in a file\n      // e.g { name: foo, ... index: 4 } is the 4th foo function\n      // in the file\n      index,\n    });\n  }\n\n  if (t.isCallExpression(path)) {\n    const name = path.node?.callee?.name;\n    if (name === \"__d\") {\n      const moduleName = path.node.arguments[0]?.value;\n      const loc = path.node.arguments[2]?.loc;\n      const location = {\n        start: { line: loc.start.line + 1, column: 0 },\n        end: loc.end,\n      };\n      symbols.functions.push({\n        name: moduleName,\n        location,\n      });\n    }\n  }\n\n  if (t.isJSXElement(path)) {\n    symbols.hasJsx = true;\n  }\n\n  if (t.isGenericTypeAnnotation(path)) {\n    symbols.hasTypes = true;\n  }\n\n  if (t.isClassDeclaration(path)) {\n    const { loc, superClass } = path.node;\n    symbols.classes.push({\n      name: path.node.id.name,\n      parent: superClass\n        ? {\n            name: t.isMemberExpression(superClass) ? getCode(superClass) : superClass.name,\n            location: superClass.loc,\n          }\n        : null,\n      location: loc,\n    });\n  }\n}\n\nfunction extractSymbols(sourceId) {\n  const symbols = {\n    functions: [],\n    classes: [],\n    hasJsx: false,\n    hasTypes: false,\n    loading: false,\n  };\n\n  const state = {\n    fnCounts: Object.create(null),\n  };\n\n  traverseAst(sourceId, {\n    enter(node, ancestors) {\n      try {\n        const path = createSimplePath(ancestors);\n        if (path) {\n          extractSymbol(path, symbols, state);\n        }\n      } catch (e) {\n        console.error(e);\n      }\n    },\n  });\n\n  return symbols;\n}\n\nexport function clearSymbols() {\n  symbolDeclarations = new Map();\n}\n\nexport function getSymbols(sourceId) {\n  if (symbolDeclarations.has(sourceId)) {\n    const symbols = symbolDeclarations.get(sourceId);\n    if (symbols) {\n      return symbols;\n    }\n  }\n\n  const symbols = extractSymbols(sourceId);\n\n  symbolDeclarations.set(sourceId, symbols);\n  return symbols;\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */\n\n//\nimport * as t from \"@babel/types\";\n\n// Perform ES6's anonymous function name inference for all\n// locations where static analysis is possible.\n// eslint-disable-next-line complexity\nexport default function getFunctionName(node, parent) {\n  if (t.isIdentifier(node.id)) {\n    return node.id.name;\n  }\n\n  if (t.isObjectMethod(node, { computed: false }) || t.isClassMethod(node, { computed: false })) {\n    const key = node.key;\n\n    if (t.isIdentifier(key)) {\n      return key.name;\n    }\n    if (t.isStringLiteral(key)) {\n      return key.value;\n    }\n    if (t.isNumericLiteral(key)) {\n      return `${key.value}`;\n    }\n  }\n\n  if (\n    t.isObjectProperty(parent, { computed: false, value: node }) ||\n    // TODO: Babylon 6 doesn't support computed class props. It is included\n    // here so that it is most flexible. Once Babylon 7 is used, this\n    // can change to use computed: false like ObjectProperty.\n    (t.isClassProperty(parent, { value: node }) && !parent.computed)\n  ) {\n    const key = parent.key;\n\n    if (t.isIdentifier(key)) {\n      return key.name;\n    }\n    if (t.isStringLiteral(key)) {\n      return key.value;\n    }\n    if (t.isNumericLiteral(key)) {\n      return `${key.value}`;\n    }\n  }\n\n  if (t.isAssignmentExpression(parent, { operator: \"=\", right: node })) {\n    if (t.isIdentifier(parent.left)) {\n      return parent.left.name;\n    }\n\n    // This case is not supported in standard ES6 name inference, but it\n    // is included here since it is still a helpful case during debugging.\n    if (t.isMemberExpression(parent.left, { computed: false })) {\n      return parent.left.property.name;\n    }\n  }\n\n  if (t.isAssignmentPattern(parent, { right: node }) && t.isIdentifier(parent.left)) {\n    return parent.left.name;\n  }\n\n  if (t.isVariableDeclarator(parent, { init: node }) && t.isIdentifier(parent.id)) {\n    return parent.id.name;\n  }\n\n  if (\n    t.isExportDefaultDeclaration(parent, { declaration: node }) &&\n    t.isFunctionDeclaration(node)\n  ) {\n    return \"default\";\n  }\n\n  return \"anonymous\";\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */\n\n//\n\nconst cachedSources = new Map();\n\nexport function setSource(source) {\n  cachedSources.set(source.id, source);\n}\n\nexport function getSource(sourceId) {\n  const source = cachedSources.get(sourceId);\n  if (!source) {\n    throw new Error(`Parser: source ${sourceId} was not provided.`);\n  }\n\n  return source;\n}\n\nexport function clearSources() {\n  cachedSources.clear();\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */\n\n//\n\nimport * as babelParser from \"@babel/parser\";\nimport * as t from \"@babel/types\";\nimport isEmpty from \"lodash/isEmpty\";\nimport parseScriptTags from \"parse-script-tags\";\n\nimport { getSource } from \"../sources\";\n\nlet ASTs = new Map();\n\nfunction _parse(code, opts) {\n  return babelParser.parse(code, {\n    ...opts,\n    tokens: true,\n  });\n}\n\nconst sourceOptions = {\n  generated: {\n    sourceType: \"unambiguous\",\n    tokens: true,\n    plugins: [\n      \"jsx\",\n      \"doExpressions\",\n      \"optionalChaining\",\n      \"nullishCoaliescingOperator\",\n      \"decorators-legacy\",\n      \"objectRestSpread\",\n      \"classProperties\",\n      \"asyncGenerators\",\n      \"functionBind\",\n      \"functionSent\",\n      \"react-jsx\",\n    ],\n  },\n  original: {\n    sourceType: \"unambiguous\",\n    tokens: true,\n    plugins: [\n      \"jsx\",\n      \"doExpressions\",\n      \"optionalChaining\",\n      \"nullishCoaliescingOperator\",\n      \"decorators-legacy\",\n      \"objectRestSpread\",\n      \"classProperties\",\n      \"exportDefaultFrom\",\n      \"exportNamespaceFrom\",\n      \"asyncGenerators\",\n      \"functionBind\",\n      \"functionSent\",\n      \"dynamicImport\",\n      \"react-jsx\",\n    ],\n  },\n};\n\nexport function parse(text, opts) {\n  let ast;\n  if (!text) {\n    return;\n  }\n\n  try {\n    ast = _parse(text, opts);\n  } catch (error) {\n    console.error(error);\n    ast = {};\n  }\n\n  return ast;\n}\n\n// Custom parser for parse-script-tags that adapts its input structure to\n// our parser's signature\nfunction htmlParser({ source, line }) {\n  return parse(source, { startLine: line });\n}\n\nconst VUE_COMPONENT_START = /^\\s*</;\nfunction vueParser({ source, line }) {\n  return parse(source, {\n    startLine: line,\n    ...sourceOptions.original,\n  });\n}\nfunction parseVueScript(code) {\n  if (typeof code !== \"string\") {\n    return;\n  }\n\n  let ast;\n\n  // .vue files go through several passes, so while there is a\n  // single-file-component Vue template, there are also generally .vue files\n  // that are still just JS as well.\n  if (code.match(VUE_COMPONENT_START)) {\n    ast = parseScriptTags(code, vueParser);\n    if (t.isFile(ast)) {\n      // parseScriptTags is currently hard-coded to return scripts, but Vue\n      // always expects ESM syntax, so we just hard-code it.\n      ast.program.sourceType = \"module\";\n    }\n  } else {\n    ast = parse(code, sourceOptions.original);\n  }\n  return ast;\n}\n\nexport function parseConsoleScript(text, opts) {\n  try {\n    return _parse(text, {\n      plugins: [\n        \"objectRestSpread\",\n        \"dynamicImport\",\n        \"nullishCoalescingOperator\",\n        \"optionalChaining\",\n      ],\n      ...opts,\n      allowAwaitOutsideFunction: true,\n    });\n  } catch (e) {\n    return null;\n  }\n}\n\nexport function parseScript(text, opts) {\n  return _parse(text, opts);\n}\n\nexport function getAst(sourceId) {\n  if (ASTs.has(sourceId)) {\n    return ASTs.get(sourceId);\n  }\n\n  const source = getSource(sourceId);\n\n  let ast = {};\n  const { contentType } = source;\n  if (contentType == \"text/html\") {\n    ast = parseScriptTags(source.text, htmlParser) || {};\n  } else if (contentType && contentType === \"text/vue\") {\n    ast = parseVueScript(source.text) || {};\n  } else if (\n    contentType &&\n    contentType.match(/(javascript|jsx)/) &&\n    !contentType.match(/typescript-jsx/)\n  ) {\n    const type = source.id.includes(\"original\") ? \"original\" : \"generated\";\n    const options = sourceOptions[type];\n\n    if (source.text.includes(\"@flow\")) {\n      options.plugins.push(\"flow\");\n    } else {\n      options.plugins.push(\"typescript\");\n    }\n\n    ast = parse(source.text, options);\n  } else if (contentType && contentType.match(/typescript/)) {\n    const options = {\n      ...sourceOptions.original,\n      plugins: [\n        ...sourceOptions.original.plugins.filter(\n          p =>\n            p !== \"flow\" &&\n            p !== \"decorators\" &&\n            p !== \"decorators2\" &&\n            (p !== \"jsx\" || contentType.match(/typescript-jsx/))\n        ),\n        \"decorators-legacy\",\n        \"typescript\",\n      ],\n    };\n    ast = parse(source.text, options);\n  }\n\n  ASTs.set(source.id, ast);\n  return ast;\n}\n\nexport function clearASTs() {\n  ASTs = new Map();\n}\n\nexport function traverseAst(sourceId, visitor, state) {\n  const ast = getAst(sourceId);\n  if (isEmpty(ast)) {\n    return null;\n  }\n\n  t.traverse(ast, visitor, state);\n  return ast;\n}\n\nexport function hasNode(rootNode, predicate) {\n  try {\n    t.traverse(rootNode, {\n      enter: (node, ancestors) => {\n        if (predicate(node, ancestors)) {\n          throw new Error(\"MATCH\");\n        }\n      },\n    });\n  } catch (e) {\n    if (e.message === \"MATCH\") {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function replaceNode(ancestors, node) {\n  const parent = ancestors[ancestors.length - 1];\n\n  if (typeof parent.index === \"number\") {\n    if (Array.isArray(node)) {\n      parent.node[parent.key].splice(parent.index, 1, ...node);\n    } else {\n      parent.node[parent.key][parent.index] = node;\n    }\n  } else {\n    parent.node[parent.key] = node;\n  }\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */\n\n//\n\nimport { parseScript } from \"./utils/ast\";\n\nexport function hasSyntaxError(input) {\n  if (!input) {\n    return false;\n  }\n\n  try {\n    parseScript(input);\n    return false;\n  } catch (e) {\n    return `${e.name} : ${e.message}`;\n  }\n}\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */\n\n//\n\nfunction WorkerDispatcher() {\n  this.msgId = 1;\n  this.worker = null;\n}\n\nWorkerDispatcher.prototype = {\n  start(workerFactory, workerName) {\n    this.worker = workerFactory();\n    this.worker.onerror = () => {\n      console.error(`Error in ${workerName} worker`);\n    };\n  },\n\n  stop() {\n    if (!this.worker) {\n      return;\n    }\n\n    this.worker.terminate();\n    this.worker = null;\n  },\n\n  task(method, { queue = false } = {}) {\n    const calls = [];\n    const push = args => {\n      return new Promise((resolve, reject) => {\n        if (queue && calls.length === 0) {\n          Promise.resolve().then(flush);\n        }\n\n        calls.push([args, resolve, reject]);\n\n        if (!queue) {\n          flush();\n        }\n      });\n    };\n\n    const flush = () => {\n      const items = calls.slice();\n      calls.length = 0;\n\n      if (!this.worker) {\n        return;\n      }\n\n      const id = this.msgId++;\n      this.worker.postMessage({\n        id,\n        method,\n        calls: items.map(item => item[0]),\n      });\n\n      const listener = ({ data: result }) => {\n        if (result.id !== id) {\n          return;\n        }\n\n        if (!this.worker) {\n          return;\n        }\n\n        this.worker.removeEventListener(\"message\", listener);\n\n        result.results.forEach((resultData, i) => {\n          const [, resolve, reject] = items[i];\n\n          if (resultData.error) {\n            const err = new Error(resultData.message);\n            err.metadata = resultData.metadata;\n            reject(err);\n          } else {\n            resolve(resultData.response);\n          }\n        });\n      };\n\n      this.worker.addEventListener(\"message\", listener);\n    };\n\n    return (...args) => push(args);\n  },\n\n  invoke(method, ...args) {\n    return this.task(method)(...args);\n  },\n};\n\nfunction workerHandler(publicInterface) {\n  return function (msg) {\n    const { id, method, calls } = msg.data;\n\n    Promise.all(\n      calls.map(args => {\n        try {\n          const response = publicInterface[method].apply(undefined, args);\n          if (response instanceof Promise) {\n            return response.then(\n              val => ({ response: val }),\n              err => asErrorMessage(err)\n            );\n          }\n          return { response };\n        } catch (error) {\n          return asErrorMessage(error);\n        }\n      })\n    ).then(results => {\n      self.postMessage({ id, results });\n    });\n  };\n}\n\nfunction asErrorMessage(error) {\n  if (typeof error === \"object\" && error && \"message\" in error) {\n    // Error can't be sent via postMessage, so be sure to convert to\n    // string.\n    return {\n      error: true,\n      message: error.message,\n      metadata: error.metadata,\n    };\n  }\n\n  return {\n    error: true,\n    message: error == null ? error : error.toString(),\n    metadata: undefined,\n  };\n}\n\nmodule.exports = {\n  WorkerDispatcher,\n  workerHandler,\n};\n"],"names":["getCode","node","generate","code","getFunctionParameterNames","path","params","map","param","type","name","left","right","value","inferClassName","classDeclaration","findParent","p","t","id","callExpression","callee","property","includes","variable","assignment","fromCallExpression","object","identifier","fromPrototype","SimplePath","constructor","ancestors","index","length","console","error","Error","this","_ancestors","_ancestor","_index","parentPath","_parentPath","undefined","parent","key","replacement","inList","containerIndex","depth","replace","find","predicate","getSibling","offset","container","siblingIndex","slice","concat","symbolDeclarations","Map","extractSymbol","symbols","state","computed","operator","init","declaration","getFunctionName","fnCounts","functions","push","klass","location","loc","parameterNames","moduleName","arguments","start","line","column","end","hasJsx","hasTypes","superClass","classes","extractSymbols","sourceId","loading","Object","create","traverseAst","enter","createSimplePath","e","clearSymbols","getSymbols","has","get","set","cachedSources","setSource","source","getSource","clearSources","clear","ASTs","_parse","opts","babelParser","tokens","sourceOptions","generated","sourceType","plugins","original","parse","text","ast","htmlParser","startLine","VUE_COMPONENT_START","vueParser","parseScript","getAst","contentType","parseScriptTags","match","program","parseVueScript","options","filter","clearASTs","visitor","isEmpty","hasSyntaxError","input","message","WorkerDispatcher","msgId","worker","asErrorMessage","metadata","toString","prototype","workerFactory","workerName","onerror","stop","terminate","task","method","queue","calls","flush","items","postMessage","item","listener","data","result","removeEventListener","results","forEach","resultData","i","resolve","reject","err","response","addEventListener","args","Promise","then","invoke","module","exports","workerHandler","publicInterface","msg","all","apply","val","self"],"sourceRoot":""}