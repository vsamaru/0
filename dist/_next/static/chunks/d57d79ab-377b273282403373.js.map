{"version":3,"file":"static/chunks/d57d79ab-377b273282403373.js","mappings":"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,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,IAAK,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,IAAK,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,IAAK,GAAI,IAAK,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,IAAK,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,GAAI,IAAK,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,IAAK,GAAI,IAAK,EAAG,GAAI,IAAK,IAAK,IAAK,GAAI,IAAK,KAAM,GAAI,GAAI,KAAM,KAAM,IAAK,KAAM,IAAK,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,GAAI,IAAK,GAAI,IAAK,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,KAAM,EAAG,KAAM,GAAI,EAAG,KAAM,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,GAAI,EAAG,GAAI,EAAG,EAAG,IAAK,KAAM,IAAK,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,KAAM,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,KAAM,GAAI,IAAK,GAAI,GAAI,EAAG,GAAI,EAAG,IAAK,GAAI,GAAI,GAAI,KAAM,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,IAAK,GAAI,GAAI,EAAG,EAAG,KAAM,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,KAAM,MAAO,GAAI,KAAM,EAAG,IAAK,EAAG,KAAM,GAAI,KAAM,KAAM,IAAK,KAAM,MACv7DC,GAAwB,CAAC,IAAK,EAAG,IAAK,EAAG,IAAK,EAAG,IAAK,EAAG,KAAM,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,IAAK,EAAG,IAAK,EAAG,EAAG,EAAG,IAAK,EAAG,IAAK,GAAI,GAAI,EAAG,IAAK,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,IAAK,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,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","sources":["webpack://_N_E/./node_modules/@babel/parser/lib/index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nclass Position {\n  constructor(line, col, index) {\n    this.line = void 0;\n    this.column = void 0;\n    this.index = void 0;\n    this.line = line;\n    this.column = col;\n    this.index = index;\n  }\n\n}\nclass SourceLocation {\n  constructor(start, end) {\n    this.start = void 0;\n    this.end = void 0;\n    this.filename = void 0;\n    this.identifierName = void 0;\n    this.start = start;\n    this.end = end;\n  }\n\n}\nfunction createPositionWithColumnOffset(position, columnOffset) {\n  const {\n    line,\n    column,\n    index\n  } = position;\n  return new Position(line, column + columnOffset, index + columnOffset);\n}\n\nconst ParseErrorCodes = Object.freeze({\n  SyntaxError: \"BABEL_PARSER_SYNTAX_ERROR\",\n  SourceTypeModuleError: \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\"\n});\n\nconst reflect = (keys, last = keys.length - 1) => ({\n  get() {\n    return keys.reduce((object, key) => object[key], this);\n  },\n\n  set(value) {\n    keys.reduce((item, key, i) => i === last ? item[key] = value : item[key], this);\n  }\n\n});\n\nconst instantiate = (constructor, properties, descriptors) => Object.keys(descriptors).map(key => [key, descriptors[key]]).filter(([, descriptor]) => !!descriptor).map(([key, descriptor]) => [key, typeof descriptor === \"function\" ? {\n  value: descriptor,\n  enumerable: false\n} : typeof descriptor.reflect === \"string\" ? Object.assign({}, descriptor, reflect(descriptor.reflect.split(\".\"))) : descriptor]).reduce((instance, [key, descriptor]) => Object.defineProperty(instance, key, Object.assign({\n  configurable: true\n}, descriptor)), Object.assign(new constructor(), properties));\n\nvar ModuleErrors = (_ => ({\n  ImportMetaOutsideModule: _(`import.meta may appear only with 'sourceType: \"module\"'`, {\n    code: ParseErrorCodes.SourceTypeModuleError\n  }),\n  ImportOutsideModule: _(`'import' and 'export' may appear only with 'sourceType: \"module\"'`, {\n    code: ParseErrorCodes.SourceTypeModuleError\n  })\n}));\n\nconst NodeDescriptions = {\n  ArrayPattern: \"array destructuring pattern\",\n  AssignmentExpression: \"assignment expression\",\n  AssignmentPattern: \"assignment expression\",\n  ArrowFunctionExpression: \"arrow function expression\",\n  ConditionalExpression: \"conditional expression\",\n  ForOfStatement: \"for-of statement\",\n  ForInStatement: \"for-in statement\",\n  ForStatement: \"for-loop\",\n  FormalParameters: \"function parameter list\",\n  Identifier: \"identifier\",\n  ObjectPattern: \"object destructuring pattern\",\n  ParenthesizedExpression: \"parenthesized expression\",\n  RestElement: \"rest element\",\n  UpdateExpression: {\n    true: \"prefix operation\",\n    false: \"postfix operation\"\n  },\n  VariableDeclarator: \"variable declaration\",\n  YieldExpression: \"yield expression\"\n};\n\nconst toNodeDescription = ({\n  type,\n  prefix\n}) => type === \"UpdateExpression\" ? NodeDescriptions.UpdateExpression[String(prefix)] : NodeDescriptions[type];\n\nvar StandardErrors = (_ => ({\n  AccessorIsGenerator: _(({\n    kind\n  }) => `A ${kind}ter cannot be a generator.`),\n  ArgumentsInClass: _(\"'arguments' is only allowed in functions and class methods.\"),\n  AsyncFunctionInSingleStatementContext: _(\"Async functions can only be declared at the top level or inside a block.\"),\n  AwaitBindingIdentifier: _(\"Can not use 'await' as identifier inside an async function.\"),\n  AwaitBindingIdentifierInStaticBlock: _(\"Can not use 'await' as identifier inside a static block.\"),\n  AwaitExpressionFormalParameter: _(\"'await' is not allowed in async function parameters.\"),\n  AwaitNotInAsyncContext: _(\"'await' is only allowed within async functions and at the top levels of modules.\"),\n  AwaitNotInAsyncFunction: _(\"'await' is only allowed within async functions.\"),\n  BadGetterArity: _(\"A 'get' accesor must not have any formal parameters.\"),\n  BadSetterArity: _(\"A 'set' accesor must have exactly one formal parameter.\"),\n  BadSetterRestParameter: _(\"A 'set' accesor function argument must not be a rest parameter.\"),\n  ConstructorClassField: _(\"Classes may not have a field named 'constructor'.\"),\n  ConstructorClassPrivateField: _(\"Classes may not have a private field named '#constructor'.\"),\n  ConstructorIsAccessor: _(\"Class constructor may not be an accessor.\"),\n  ConstructorIsAsync: _(\"Constructor can't be an async function.\"),\n  ConstructorIsGenerator: _(\"Constructor can't be a generator.\"),\n  DeclarationMissingInitializer: _(({\n    kind\n  }) => `Missing initializer in ${kind} declaration.`),\n  DecoratorBeforeExport: _(\"Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.\"),\n  DecoratorConstructor: _(\"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?\"),\n  DecoratorExportClass: _(\"Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.\"),\n  DecoratorSemicolon: _(\"Decorators must not be followed by a semicolon.\"),\n  DecoratorStaticBlock: _(\"Decorators can't be used with a static block.\"),\n  DeletePrivateField: _(\"Deleting a private field is not allowed.\"),\n  DestructureNamedImport: _(\"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\"),\n  DuplicateConstructor: _(\"Duplicate constructor in the same class.\"),\n  DuplicateDefaultExport: _(\"Only one default export allowed per module.\"),\n  DuplicateExport: _(({\n    exportName\n  }) => `\\`${exportName}\\` has already been exported. Exported identifiers must be unique.`),\n  DuplicateProto: _(\"Redefinition of __proto__ property.\"),\n  DuplicateRegExpFlags: _(\"Duplicate regular expression flag.\"),\n  ElementAfterRest: _(\"Rest element must be last element.\"),\n  EscapedCharNotAnIdentifier: _(\"Invalid Unicode escape.\"),\n  ExportBindingIsString: _(({\n    localName,\n    exportName\n  }) => `A string literal cannot be used as an exported binding without \\`from\\`.\\n- Did you mean \\`export { '${localName}' as '${exportName}' } from 'some-module'\\`?`),\n  ExportDefaultFromAsIdentifier: _(\"'from' is not allowed as an identifier after 'export default'.\"),\n  ForInOfLoopInitializer: _(({\n    type\n  }) => `'${type === \"ForInStatement\" ? \"for-in\" : \"for-of\"}' loop variable declaration may not have an initializer.`),\n  ForOfAsync: _(\"The left-hand side of a for-of loop may not be 'async'.\"),\n  ForOfLet: _(\"The left-hand side of a for-of loop may not start with 'let'.\"),\n  GeneratorInSingleStatementContext: _(\"Generators can only be declared at the top level or inside a block.\"),\n  IllegalBreakContinue: _(({\n    type\n  }) => `Unsyntactic ${type === \"BreakStatement\" ? \"break\" : \"continue\"}.`),\n  IllegalLanguageModeDirective: _(\"Illegal 'use strict' directive in function with non-simple parameter list.\"),\n  IllegalReturn: _(\"'return' outside of function.\"),\n  ImportBindingIsString: _(({\n    importName\n  }) => `A string literal cannot be used as an imported binding.\\n- Did you mean \\`import { \"${importName}\" as foo }\\`?`),\n  ImportCallArgumentTrailingComma: _(\"Trailing comma is disallowed inside import(...) arguments.\"),\n  ImportCallArity: _(({\n    maxArgumentCount\n  }) => `\\`import()\\` requires exactly ${maxArgumentCount === 1 ? \"one argument\" : \"one or two arguments\"}.`),\n  ImportCallNotNewExpression: _(\"Cannot use new with import(...).\"),\n  ImportCallSpreadArgument: _(\"`...` is not allowed in `import()`.\"),\n  IncompatibleRegExpUVFlags: _(\"The 'u' and 'v' regular expression flags cannot be enabled at the same time.\"),\n  InvalidBigIntLiteral: _(\"Invalid BigIntLiteral.\"),\n  InvalidCodePoint: _(\"Code point out of bounds.\"),\n  InvalidCoverInitializedName: _(\"Invalid shorthand property initializer.\"),\n  InvalidDecimal: _(\"Invalid decimal.\"),\n  InvalidDigit: _(({\n    radix\n  }) => `Expected number in radix ${radix}.`),\n  InvalidEscapeSequence: _(\"Bad character escape sequence.\"),\n  InvalidEscapeSequenceTemplate: _(\"Invalid escape sequence in template.\"),\n  InvalidEscapedReservedWord: _(({\n    reservedWord\n  }) => `Escape sequence in keyword ${reservedWord}.`),\n  InvalidIdentifier: _(({\n    identifierName\n  }) => `Invalid identifier ${identifierName}.`),\n  InvalidLhs: _(({\n    ancestor\n  }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`),\n  InvalidLhsBinding: _(({\n    ancestor\n  }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`),\n  InvalidNumber: _(\"Invalid number.\"),\n  InvalidOrMissingExponent: _(\"Floating-point numbers require a valid exponent after the 'e'.\"),\n  InvalidOrUnexpectedToken: _(({\n    unexpected\n  }) => `Unexpected character '${unexpected}'.`),\n  InvalidParenthesizedAssignment: _(\"Invalid parenthesized assignment pattern.\"),\n  InvalidPrivateFieldResolution: _(({\n    identifierName\n  }) => `Private name #${identifierName} is not defined.`),\n  InvalidPropertyBindingPattern: _(\"Binding member expression.\"),\n  InvalidRecordProperty: _(\"Only properties and spread elements are allowed in record definitions.\"),\n  InvalidRestAssignmentPattern: _(\"Invalid rest operator's argument.\"),\n  LabelRedeclaration: _(({\n    labelName\n  }) => `Label '${labelName}' is already declared.`),\n  LetInLexicalBinding: _(\"'let' is not allowed to be used as a name in 'let' or 'const' declarations.\"),\n  LineTerminatorBeforeArrow: _(\"No line break is allowed before '=>'.\"),\n  MalformedRegExpFlags: _(\"Invalid regular expression flag.\"),\n  MissingClassName: _(\"A class name is required.\"),\n  MissingEqInAssignment: _(\"Only '=' operator can be used for specifying default value.\"),\n  MissingSemicolon: _(\"Missing semicolon.\"),\n  MissingPlugin: _(({\n    missingPlugin\n  }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map(name => JSON.stringify(name)).join(\", \")}.`),\n  MissingOneOfPlugins: _(({\n    missingPlugin\n  }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map(name => JSON.stringify(name)).join(\", \")}.`),\n  MissingUnicodeEscape: _(\"Expecting Unicode escape sequence \\\\uXXXX.\"),\n  MixingCoalesceWithLogical: _(\"Nullish coalescing operator(??) requires parens when mixing with logical operators.\"),\n  ModuleAttributeDifferentFromType: _(\"The only accepted module attribute is `type`.\"),\n  ModuleAttributeInvalidValue: _(\"Only string literals are allowed as module attribute values.\"),\n  ModuleAttributesWithDuplicateKeys: _(({\n    key\n  }) => `Duplicate key \"${key}\" is not allowed in module attributes.`),\n  ModuleExportNameHasLoneSurrogate: _(({\n    surrogateCharCode\n  }) => `An export name cannot include a lone surrogate, found '\\\\u${surrogateCharCode.toString(16)}'.`),\n  ModuleExportUndefined: _(({\n    localName\n  }) => `Export '${localName}' is not defined.`),\n  MultipleDefaultsInSwitch: _(\"Multiple default clauses.\"),\n  NewlineAfterThrow: _(\"Illegal newline after throw.\"),\n  NoCatchOrFinally: _(\"Missing catch or finally clause.\"),\n  NumberIdentifier: _(\"Identifier directly after number.\"),\n  NumericSeparatorInEscapeSequence: _(\"Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.\"),\n  ObsoleteAwaitStar: _(\"'await*' has been removed from the async functions proposal. Use Promise.all() instead.\"),\n  OptionalChainingNoNew: _(\"Constructors in/after an Optional Chain are not allowed.\"),\n  OptionalChainingNoTemplate: _(\"Tagged Template Literals are not allowed in optionalChain.\"),\n  OverrideOnConstructor: _(\"'override' modifier cannot appear on a constructor declaration.\"),\n  ParamDupe: _(\"Argument name clash.\"),\n  PatternHasAccessor: _(\"Object pattern can't contain getter or setter.\"),\n  PatternHasMethod: _(\"Object pattern can't contain methods.\"),\n  PrivateInExpectedIn: _(({\n    identifierName\n  }) => `Private names are only allowed in property accesses (\\`obj.#${identifierName}\\`) or in \\`in\\` expressions (\\`#${identifierName} in obj\\`).`),\n  PrivateNameRedeclaration: _(({\n    identifierName\n  }) => `Duplicate private name #${identifierName}.`),\n  RecordExpressionBarIncorrectEndSyntaxType: _(\"Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\"),\n  RecordExpressionBarIncorrectStartSyntaxType: _(\"Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\"),\n  RecordExpressionHashIncorrectStartSyntaxType: _(\"Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.\"),\n  RecordNoProto: _(\"'__proto__' is not allowed in Record expressions.\"),\n  RestTrailingComma: _(\"Unexpected trailing comma after rest element.\"),\n  SloppyFunction: _(\"In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.\"),\n  StaticPrototype: _(\"Classes may not have static property named prototype.\"),\n  SuperNotAllowed: _(\"`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?\"),\n  SuperPrivateField: _(\"Private fields can't be accessed on super.\"),\n  TrailingDecorator: _(\"Decorators must be attached to a class element.\"),\n  TupleExpressionBarIncorrectEndSyntaxType: _(\"Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\"),\n  TupleExpressionBarIncorrectStartSyntaxType: _(\"Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\"),\n  TupleExpressionHashIncorrectStartSyntaxType: _(\"Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.\"),\n  UnexpectedArgumentPlaceholder: _(\"Unexpected argument placeholder.\"),\n  UnexpectedAwaitAfterPipelineBody: _('Unexpected \"await\" after pipeline body; await must have parentheses in minimal proposal.'),\n  UnexpectedDigitAfterHash: _(\"Unexpected digit after hash token.\"),\n  UnexpectedImportExport: _(\"'import' and 'export' may only appear at the top level.\"),\n  UnexpectedKeyword: _(({\n    keyword\n  }) => `Unexpected keyword '${keyword}'.`),\n  UnexpectedLeadingDecorator: _(\"Leading decorators must be attached to a class declaration.\"),\n  UnexpectedLexicalDeclaration: _(\"Lexical declaration cannot appear in a single-statement context.\"),\n  UnexpectedNewTarget: _(\"`new.target` can only be used in functions or class properties.\"),\n  UnexpectedNumericSeparator: _(\"A numeric separator is only allowed between two digits.\"),\n  UnexpectedPrivateField: _(\"Unexpected private name.\"),\n  UnexpectedReservedWord: _(({\n    reservedWord\n  }) => `Unexpected reserved word '${reservedWord}'.`),\n  UnexpectedSuper: _(\"'super' is only allowed in object methods and classes.\"),\n  UnexpectedToken: _(({\n    expected,\n    unexpected\n  }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : \"\"}${expected ? `, expected \"${expected}\"` : \"\"}`),\n  UnexpectedTokenUnaryExponentiation: _(\"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.\"),\n  UnsupportedBind: _(\"Binding should be performed on object property.\"),\n  UnsupportedDecoratorExport: _(\"A decorated export must export a class declaration.\"),\n  UnsupportedDefaultExport: _(\"Only expressions, functions or classes are allowed as the `default` export.\"),\n  UnsupportedImport: _(\"`import` can only be used in `import()` or `import.meta`.\"),\n  UnsupportedMetaProperty: _(({\n    target,\n    onlyValidPropertyName\n  }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`),\n  UnsupportedParameterDecorator: _(\"Decorators cannot be used to decorate parameters.\"),\n  UnsupportedPropertyDecorator: _(\"Decorators cannot be used to decorate object literal properties.\"),\n  UnsupportedSuper: _(\"'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).\"),\n  UnterminatedComment: _(\"Unterminated comment.\"),\n  UnterminatedRegExp: _(\"Unterminated regular expression.\"),\n  UnterminatedString: _(\"Unterminated string constant.\"),\n  UnterminatedTemplate: _(\"Unterminated template.\"),\n  VarRedeclaration: _(({\n    identifierName\n  }) => `Identifier '${identifierName}' has already been declared.`),\n  YieldBindingIdentifier: _(\"Can not use 'yield' as identifier inside a generator.\"),\n  YieldInParameter: _(\"Yield expression is not allowed in formal parameters.\"),\n  ZeroDigitNumericSeparator: _(\"Numeric separator can not be used after leading 0.\")\n}));\n\nvar StrictModeErrors = (_ => ({\n  StrictDelete: _(\"Deleting local variable in strict mode.\"),\n  StrictEvalArguments: _(({\n    referenceName\n  }) => `Assigning to '${referenceName}' in strict mode.`),\n  StrictEvalArgumentsBinding: _(({\n    bindingName\n  }) => `Binding '${bindingName}' in strict mode.`),\n  StrictFunction: _(\"In strict mode code, functions can only be declared at top level or inside a block.\"),\n  StrictNumericEscape: _(\"The only valid numeric escape in strict mode is '\\\\0'.\"),\n  StrictOctalLiteral: _(\"Legacy octal literals are not allowed in strict mode.\"),\n  StrictWith: _(\"'with' in strict mode.\")\n}));\n\nconst UnparenthesizedPipeBodyDescriptions = new Set([\"ArrowFunctionExpression\", \"AssignmentExpression\", \"ConditionalExpression\", \"YieldExpression\"]);\nvar PipelineOperatorErrors = (_ => ({\n  PipeBodyIsTighter: _(\"Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.\"),\n  PipeTopicRequiresHackPipes: _('Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option.'),\n  PipeTopicUnbound: _(\"Topic reference is unbound; it must be inside a pipe body.\"),\n  PipeTopicUnconfiguredToken: _(({\n    token\n  }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { \"proposal\": \"hack\", \"topicToken\": \"${token}\" }.`),\n  PipeTopicUnused: _(\"Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.\"),\n  PipeUnparenthesizedBody: _(({\n    type\n  }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({\n    type\n  })}; please wrap it in parentheses.`),\n  PipelineBodyNoArrow: _('Unexpected arrow \"=>\" after pipeline body; arrow function in pipeline body must be parenthesized.'),\n  PipelineBodySequenceExpression: _(\"Pipeline body may not be a comma-separated sequence expression.\"),\n  PipelineHeadSequenceExpression: _(\"Pipeline head should not be a comma-separated sequence expression.\"),\n  PipelineTopicUnused: _(\"Pipeline is in topic style but does not use topic reference.\"),\n  PrimaryTopicNotAllowed: _(\"Topic reference was used in a lexical context without topic binding.\"),\n  PrimaryTopicRequiresSmartPipeline: _('Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option.')\n}));\n\nconst _excluded$1 = [\"toMessage\"];\n\nfunction toParseErrorConstructor(_ref) {\n  let {\n    toMessage\n  } = _ref,\n      properties = _objectWithoutPropertiesLoose(_ref, _excluded$1);\n\n  return function constructor({\n    loc,\n    details\n  }) {\n    return instantiate(SyntaxError, Object.assign({}, properties, {\n      loc\n    }), {\n      clone(overrides = {}) {\n        const loc = overrides.loc || {};\n        return constructor({\n          loc: new Position(\"line\" in loc ? loc.line : this.loc.line, \"column\" in loc ? loc.column : this.loc.column, \"index\" in loc ? loc.index : this.loc.index),\n          details: Object.assign({}, this.details, overrides.details)\n        });\n      },\n\n      details: {\n        value: details,\n        enumerable: false\n      },\n      message: {\n        get() {\n          return `${toMessage(this.details)} (${this.loc.line}:${this.loc.column})`;\n        },\n\n        set(value) {\n          Object.defineProperty(this, \"message\", {\n            value\n          });\n        }\n\n      },\n      pos: {\n        reflect: \"loc.index\",\n        enumerable: true\n      },\n      missingPlugin: \"missingPlugin\" in details && {\n        reflect: \"details.missingPlugin\",\n        enumerable: true\n      }\n    });\n  };\n}\n\nfunction toParseErrorCredentials(toMessageOrMessage, credentials) {\n  return Object.assign({\n    toMessage: typeof toMessageOrMessage === \"string\" ? () => toMessageOrMessage : toMessageOrMessage\n  }, credentials);\n}\nfunction ParseErrorEnum(argument, syntaxPlugin) {\n  if (Array.isArray(argument)) {\n    return toParseErrorCredentialsMap => ParseErrorEnum(toParseErrorCredentialsMap, argument[0]);\n  }\n\n  const partialCredentials = argument(toParseErrorCredentials);\n  const ParseErrorConstructors = {};\n\n  for (const reasonCode of Object.keys(partialCredentials)) {\n    ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({\n      code: ParseErrorCodes.SyntaxError,\n      reasonCode\n    }, syntaxPlugin ? {\n      syntaxPlugin\n    } : {}, partialCredentials[reasonCode]));\n  }\n\n  return ParseErrorConstructors;\n}\nconst Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));\n\nconst {\n  defineProperty\n} = Object;\n\nconst toUnenumerable = (object, key) => defineProperty(object, key, {\n  enumerable: false,\n  value: object[key]\n});\n\nfunction toESTreeLocation(node) {\n  node.loc.start && toUnenumerable(node.loc.start, \"index\");\n  node.loc.end && toUnenumerable(node.loc.end, \"index\");\n  return node;\n}\n\nvar estree = (superClass => class extends superClass {\n  parse() {\n    const file = toESTreeLocation(super.parse());\n\n    if (this.options.tokens) {\n      file.tokens = file.tokens.map(toESTreeLocation);\n    }\n\n    return file;\n  }\n\n  parseRegExpLiteral({\n    pattern,\n    flags\n  }) {\n    let regex = null;\n\n    try {\n      regex = new RegExp(pattern, flags);\n    } catch (e) {}\n\n    const node = this.estreeParseLiteral(regex);\n    node.regex = {\n      pattern,\n      flags\n    };\n    return node;\n  }\n\n  parseBigIntLiteral(value) {\n    let bigInt;\n\n    try {\n      bigInt = BigInt(value);\n    } catch (_unused) {\n      bigInt = null;\n    }\n\n    const node = this.estreeParseLiteral(bigInt);\n    node.bigint = String(node.value || value);\n    return node;\n  }\n\n  parseDecimalLiteral(value) {\n    const decimal = null;\n    const node = this.estreeParseLiteral(decimal);\n    node.decimal = String(node.value || value);\n    return node;\n  }\n\n  estreeParseLiteral(value) {\n    return this.parseLiteral(value, \"Literal\");\n  }\n\n  parseStringLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n\n  parseNumericLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n\n  parseNullLiteral() {\n    return this.estreeParseLiteral(null);\n  }\n\n  parseBooleanLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n\n  directiveToStmt(directive) {\n    const directiveLiteral = directive.value;\n    const stmt = this.startNodeAt(directive.start, directive.loc.start);\n    const expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);\n    expression.value = directiveLiteral.extra.expressionValue;\n    expression.raw = directiveLiteral.extra.raw;\n    stmt.expression = this.finishNodeAt(expression, \"Literal\", directiveLiteral.loc.end);\n    stmt.directive = directiveLiteral.extra.raw.slice(1, -1);\n    return this.finishNodeAt(stmt, \"ExpressionStatement\", directive.loc.end);\n  }\n\n  initFunction(node, isAsync) {\n    super.initFunction(node, isAsync);\n    node.expression = false;\n  }\n\n  checkDeclaration(node) {\n    if (node != null && this.isObjectProperty(node)) {\n      this.checkDeclaration(node.value);\n    } else {\n      super.checkDeclaration(node);\n    }\n  }\n\n  getObjectOrClassMethodParams(method) {\n    return method.value.params;\n  }\n\n  isValidDirective(stmt) {\n    var _stmt$expression$extr;\n\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"Literal\" && typeof stmt.expression.value === \"string\" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);\n  }\n\n  parseBlockBody(node, ...args) {\n    super.parseBlockBody(node, ...args);\n    const directiveStatements = node.directives.map(d => this.directiveToStmt(d));\n    node.body = directiveStatements.concat(node.body);\n    delete node.directives;\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \"ClassMethod\", true);\n\n    if (method.typeParameters) {\n      method.value.typeParameters = method.typeParameters;\n      delete method.typeParameters;\n    }\n\n    classBody.body.push(method);\n  }\n\n  parsePrivateName() {\n    const node = super.parsePrivateName();\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return node;\n      }\n    }\n    return this.convertPrivateNameToPrivateIdentifier(node);\n  }\n\n  convertPrivateNameToPrivateIdentifier(node) {\n    const name = super.getPrivateNameSV(node);\n    node = node;\n    delete node.id;\n    node.name = name;\n    node.type = \"PrivateIdentifier\";\n    return node;\n  }\n\n  isPrivateName(node) {\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return super.isPrivateName(node);\n      }\n    }\n    return node.type === \"PrivateIdentifier\";\n  }\n\n  getPrivateNameSV(node) {\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return super.getPrivateNameSV(node);\n      }\n    }\n    return node.name;\n  }\n\n  parseLiteral(value, type) {\n    const node = super.parseLiteral(value, type);\n    node.raw = node.extra.raw;\n    delete node.extra;\n    return node;\n  }\n\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    super.parseFunctionBody(node, allowExpression, isMethod);\n    node.expression = node.body.type !== \"BlockStatement\";\n  }\n\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    let funcNode = this.startNode();\n    funcNode.kind = node.kind;\n    funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);\n    funcNode.type = \"FunctionExpression\";\n    delete funcNode.kind;\n    node.value = funcNode;\n\n    if (type === \"ClassPrivateMethod\") {\n      node.computed = false;\n    }\n\n    type = \"MethodDefinition\";\n    return this.finishNode(node, type);\n  }\n\n  parseClassProperty(...args) {\n    const propertyNode = super.parseClassProperty(...args);\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return propertyNode;\n      }\n    }\n    propertyNode.type = \"PropertyDefinition\";\n    return propertyNode;\n  }\n\n  parseClassPrivateProperty(...args) {\n    const propertyNode = super.parseClassPrivateProperty(...args);\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return propertyNode;\n      }\n    }\n    propertyNode.type = \"PropertyDefinition\";\n    propertyNode.computed = false;\n    return propertyNode;\n  }\n\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {\n    const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);\n\n    if (node) {\n      node.type = \"Property\";\n      if (node.kind === \"method\") node.kind = \"init\";\n      node.shorthand = false;\n    }\n\n    return node;\n  }\n\n  parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {\n    const node = super.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);\n\n    if (node) {\n      node.kind = \"init\";\n      node.type = \"Property\";\n    }\n\n    return node;\n  }\n\n  isValidLVal(type, ...rest) {\n    return type === \"Property\" ? \"value\" : super.isValidLVal(type, ...rest);\n  }\n\n  isAssignable(node, isBinding) {\n    if (node != null && this.isObjectProperty(node)) {\n      return this.isAssignable(node.value, isBinding);\n    }\n\n    return super.isAssignable(node, isBinding);\n  }\n\n  toAssignable(node, isLHS = false) {\n    if (node != null && this.isObjectProperty(node)) {\n      const {\n        key,\n        value\n      } = node;\n\n      if (this.isPrivateName(key)) {\n        this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);\n      }\n\n      this.toAssignable(value, isLHS);\n    } else {\n      super.toAssignable(node, isLHS);\n    }\n  }\n\n  toAssignableObjectExpressionProp(prop) {\n    if (prop.kind === \"get\" || prop.kind === \"set\") {\n      this.raise(Errors.PatternHasAccessor, {\n        at: prop.key\n      });\n    } else if (prop.method) {\n      this.raise(Errors.PatternHasMethod, {\n        at: prop.key\n      });\n    } else {\n      super.toAssignableObjectExpressionProp(...arguments);\n    }\n  }\n\n  finishCallExpression(node, optional) {\n    super.finishCallExpression(node, optional);\n\n    if (node.callee.type === \"Import\") {\n      node.type = \"ImportExpression\";\n      node.source = node.arguments[0];\n\n      if (this.hasPlugin(\"importAssertions\")) {\n        var _node$arguments$;\n\n        node.attributes = (_node$arguments$ = node.arguments[1]) != null ? _node$arguments$ : null;\n      }\n\n      delete node.arguments;\n      delete node.callee;\n    }\n\n    return node;\n  }\n\n  toReferencedArguments(node) {\n    if (node.type === \"ImportExpression\") {\n      return;\n    }\n\n    super.toReferencedArguments(node);\n  }\n\n  parseExport(node) {\n    super.parseExport(node);\n\n    switch (node.type) {\n      case \"ExportAllDeclaration\":\n        node.exported = null;\n        break;\n\n      case \"ExportNamedDeclaration\":\n        if (node.specifiers.length === 1 && node.specifiers[0].type === \"ExportNamespaceSpecifier\") {\n          node.type = \"ExportAllDeclaration\";\n          node.exported = node.specifiers[0].exported;\n          delete node.specifiers;\n        }\n\n        break;\n    }\n\n    return node;\n  }\n\n  parseSubscript(base, startPos, startLoc, noCalls, state) {\n    const node = super.parseSubscript(base, startPos, startLoc, noCalls, state);\n\n    if (state.optionalChainMember) {\n      if (node.type === \"OptionalMemberExpression\" || node.type === \"OptionalCallExpression\") {\n        node.type = node.type.substring(8);\n      }\n\n      if (state.stop) {\n        const chain = this.startNodeAtNode(node);\n        chain.expression = node;\n        return this.finishNode(chain, \"ChainExpression\");\n      }\n    } else if (node.type === \"MemberExpression\" || node.type === \"CallExpression\") {\n      node.optional = false;\n    }\n\n    return node;\n  }\n\n  hasPropertyAsPrivateName(node) {\n    if (node.type === \"ChainExpression\") {\n      node = node.expression;\n    }\n\n    return super.hasPropertyAsPrivateName(node);\n  }\n\n  isOptionalChain(node) {\n    return node.type === \"ChainExpression\";\n  }\n\n  isObjectProperty(node) {\n    return node.type === \"Property\" && node.kind === \"init\" && !node.method;\n  }\n\n  isObjectMethod(node) {\n    return node.method || node.kind === \"get\" || node.kind === \"set\";\n  }\n\n  finishNodeAt(node, type, endLoc) {\n    return toESTreeLocation(super.finishNodeAt(node, type, endLoc));\n  }\n\n  resetStartLocation(node, start, startLoc) {\n    super.resetStartLocation(node, start, startLoc);\n    toESTreeLocation(node);\n  }\n\n  resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {\n    super.resetEndLocation(node, endLoc);\n    toESTreeLocation(node);\n  }\n\n});\n\nclass TokContext {\n  constructor(token, preserveSpace) {\n    this.token = void 0;\n    this.preserveSpace = void 0;\n    this.token = token;\n    this.preserveSpace = !!preserveSpace;\n  }\n\n}\nconst types = {\n  brace: new TokContext(\"{\"),\n  j_oTag: new TokContext(\"<tag\"),\n  j_cTag: new TokContext(\"</tag\"),\n  j_expr: new TokContext(\"<tag>...</tag>\", true)\n};\n{\n  types.template = new TokContext(\"`\", true);\n}\n\nconst beforeExpr = true;\nconst startsExpr = true;\nconst isLoop = true;\nconst isAssign = true;\nconst prefix = true;\nconst postfix = true;\nclass ExportedTokenType {\n  constructor(label, conf = {}) {\n    this.label = void 0;\n    this.keyword = void 0;\n    this.beforeExpr = void 0;\n    this.startsExpr = void 0;\n    this.rightAssociative = void 0;\n    this.isLoop = void 0;\n    this.isAssign = void 0;\n    this.prefix = void 0;\n    this.postfix = void 0;\n    this.binop = void 0;\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.rightAssociative = !!conf.rightAssociative;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop != null ? conf.binop : null;\n    {\n      this.updateContext = null;\n    }\n  }\n\n}\nconst keywords$1 = new Map();\n\nfunction createKeyword(name, options = {}) {\n  options.keyword = name;\n  const token = createToken(name, options);\n  keywords$1.set(name, token);\n  return token;\n}\n\nfunction createBinop(name, binop) {\n  return createToken(name, {\n    beforeExpr,\n    binop\n  });\n}\n\nlet tokenTypeCounter = -1;\nconst tokenTypes = [];\nconst tokenLabels = [];\nconst tokenBinops = [];\nconst tokenBeforeExprs = [];\nconst tokenStartsExprs = [];\nconst tokenPrefixes = [];\n\nfunction createToken(name, options = {}) {\n  var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;\n\n  ++tokenTypeCounter;\n  tokenLabels.push(name);\n  tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);\n  tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);\n  tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);\n  tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);\n  tokenTypes.push(new ExportedTokenType(name, options));\n  return tokenTypeCounter;\n}\n\nfunction createKeywordLike(name, options = {}) {\n  var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;\n\n  ++tokenTypeCounter;\n  keywords$1.set(name, tokenTypeCounter);\n  tokenLabels.push(name);\n  tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);\n  tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);\n  tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);\n  tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);\n  tokenTypes.push(new ExportedTokenType(\"name\", options));\n  return tokenTypeCounter;\n}\n\nconst tt = {\n  bracketL: createToken(\"[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketHashL: createToken(\"#[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketBarL: createToken(\"[|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketR: createToken(\"]\"),\n  bracketBarR: createToken(\"|]\"),\n  braceL: createToken(\"{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceBarL: createToken(\"{|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceHashL: createToken(\"#{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceR: createToken(\"}\"),\n  braceBarR: createToken(\"|}\"),\n  parenL: createToken(\"(\", {\n    beforeExpr,\n    startsExpr\n  }),\n  parenR: createToken(\")\"),\n  comma: createToken(\",\", {\n    beforeExpr\n  }),\n  semi: createToken(\";\", {\n    beforeExpr\n  }),\n  colon: createToken(\":\", {\n    beforeExpr\n  }),\n  doubleColon: createToken(\"::\", {\n    beforeExpr\n  }),\n  dot: createToken(\".\"),\n  question: createToken(\"?\", {\n    beforeExpr\n  }),\n  questionDot: createToken(\"?.\"),\n  arrow: createToken(\"=>\", {\n    beforeExpr\n  }),\n  template: createToken(\"template\"),\n  ellipsis: createToken(\"...\", {\n    beforeExpr\n  }),\n  backQuote: createToken(\"`\", {\n    startsExpr\n  }),\n  dollarBraceL: createToken(\"${\", {\n    beforeExpr,\n    startsExpr\n  }),\n  templateTail: createToken(\"...`\", {\n    startsExpr\n  }),\n  templateNonTail: createToken(\"...${\", {\n    beforeExpr,\n    startsExpr\n  }),\n  at: createToken(\"@\"),\n  hash: createToken(\"#\", {\n    startsExpr\n  }),\n  interpreterDirective: createToken(\"#!...\"),\n  eq: createToken(\"=\", {\n    beforeExpr,\n    isAssign\n  }),\n  assign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  slashAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  xorAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  moduloAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  incDec: createToken(\"++/--\", {\n    prefix,\n    postfix,\n    startsExpr\n  }),\n  bang: createToken(\"!\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  tilde: createToken(\"~\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  doubleCaret: createToken(\"^^\", {\n    startsExpr\n  }),\n  doubleAt: createToken(\"@@\", {\n    startsExpr\n  }),\n  pipeline: createBinop(\"|>\", 0),\n  nullishCoalescing: createBinop(\"??\", 1),\n  logicalOR: createBinop(\"||\", 1),\n  logicalAND: createBinop(\"&&\", 2),\n  bitwiseOR: createBinop(\"|\", 3),\n  bitwiseXOR: createBinop(\"^\", 4),\n  bitwiseAND: createBinop(\"&\", 5),\n  equality: createBinop(\"==/!=/===/!==\", 6),\n  lt: createBinop(\"</>/<=/>=\", 7),\n  gt: createBinop(\"</>/<=/>=\", 7),\n  relational: createBinop(\"</>/<=/>=\", 7),\n  bitShift: createBinop(\"<</>>/>>>\", 8),\n  bitShiftL: createBinop(\"<</>>/>>>\", 8),\n  bitShiftR: createBinop(\"<</>>/>>>\", 8),\n  plusMin: createToken(\"+/-\", {\n    beforeExpr,\n    binop: 9,\n    prefix,\n    startsExpr\n  }),\n  modulo: createToken(\"%\", {\n    binop: 10,\n    startsExpr\n  }),\n  star: createToken(\"*\", {\n    binop: 10\n  }),\n  slash: createBinop(\"/\", 10),\n  exponent: createToken(\"**\", {\n    beforeExpr,\n    binop: 11,\n    rightAssociative: true\n  }),\n  _in: createKeyword(\"in\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _instanceof: createKeyword(\"instanceof\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _break: createKeyword(\"break\"),\n  _case: createKeyword(\"case\", {\n    beforeExpr\n  }),\n  _catch: createKeyword(\"catch\"),\n  _continue: createKeyword(\"continue\"),\n  _debugger: createKeyword(\"debugger\"),\n  _default: createKeyword(\"default\", {\n    beforeExpr\n  }),\n  _else: createKeyword(\"else\", {\n    beforeExpr\n  }),\n  _finally: createKeyword(\"finally\"),\n  _function: createKeyword(\"function\", {\n    startsExpr\n  }),\n  _if: createKeyword(\"if\"),\n  _return: createKeyword(\"return\", {\n    beforeExpr\n  }),\n  _switch: createKeyword(\"switch\"),\n  _throw: createKeyword(\"throw\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _try: createKeyword(\"try\"),\n  _var: createKeyword(\"var\"),\n  _const: createKeyword(\"const\"),\n  _with: createKeyword(\"with\"),\n  _new: createKeyword(\"new\", {\n    beforeExpr,\n    startsExpr\n  }),\n  _this: createKeyword(\"this\", {\n    startsExpr\n  }),\n  _super: createKeyword(\"super\", {\n    startsExpr\n  }),\n  _class: createKeyword(\"class\", {\n    startsExpr\n  }),\n  _extends: createKeyword(\"extends\", {\n    beforeExpr\n  }),\n  _export: createKeyword(\"export\"),\n  _import: createKeyword(\"import\", {\n    startsExpr\n  }),\n  _null: createKeyword(\"null\", {\n    startsExpr\n  }),\n  _true: createKeyword(\"true\", {\n    startsExpr\n  }),\n  _false: createKeyword(\"false\", {\n    startsExpr\n  }),\n  _typeof: createKeyword(\"typeof\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _void: createKeyword(\"void\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _delete: createKeyword(\"delete\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _do: createKeyword(\"do\", {\n    isLoop,\n    beforeExpr\n  }),\n  _for: createKeyword(\"for\", {\n    isLoop\n  }),\n  _while: createKeyword(\"while\", {\n    isLoop\n  }),\n  _as: createKeywordLike(\"as\", {\n    startsExpr\n  }),\n  _assert: createKeywordLike(\"assert\", {\n    startsExpr\n  }),\n  _async: createKeywordLike(\"async\", {\n    startsExpr\n  }),\n  _await: createKeywordLike(\"await\", {\n    startsExpr\n  }),\n  _from: createKeywordLike(\"from\", {\n    startsExpr\n  }),\n  _get: createKeywordLike(\"get\", {\n    startsExpr\n  }),\n  _let: createKeywordLike(\"let\", {\n    startsExpr\n  }),\n  _meta: createKeywordLike(\"meta\", {\n    startsExpr\n  }),\n  _of: createKeywordLike(\"of\", {\n    startsExpr\n  }),\n  _sent: createKeywordLike(\"sent\", {\n    startsExpr\n  }),\n  _set: createKeywordLike(\"set\", {\n    startsExpr\n  }),\n  _static: createKeywordLike(\"static\", {\n    startsExpr\n  }),\n  _yield: createKeywordLike(\"yield\", {\n    startsExpr\n  }),\n  _asserts: createKeywordLike(\"asserts\", {\n    startsExpr\n  }),\n  _checks: createKeywordLike(\"checks\", {\n    startsExpr\n  }),\n  _exports: createKeywordLike(\"exports\", {\n    startsExpr\n  }),\n  _global: createKeywordLike(\"global\", {\n    startsExpr\n  }),\n  _implements: createKeywordLike(\"implements\", {\n    startsExpr\n  }),\n  _intrinsic: createKeywordLike(\"intrinsic\", {\n    startsExpr\n  }),\n  _infer: createKeywordLike(\"infer\", {\n    startsExpr\n  }),\n  _is: createKeywordLike(\"is\", {\n    startsExpr\n  }),\n  _mixins: createKeywordLike(\"mixins\", {\n    startsExpr\n  }),\n  _proto: createKeywordLike(\"proto\", {\n    startsExpr\n  }),\n  _require: createKeywordLike(\"require\", {\n    startsExpr\n  }),\n  _keyof: createKeywordLike(\"keyof\", {\n    startsExpr\n  }),\n  _readonly: createKeywordLike(\"readonly\", {\n    startsExpr\n  }),\n  _unique: createKeywordLike(\"unique\", {\n    startsExpr\n  }),\n  _abstract: createKeywordLike(\"abstract\", {\n    startsExpr\n  }),\n  _declare: createKeywordLike(\"declare\", {\n    startsExpr\n  }),\n  _enum: createKeywordLike(\"enum\", {\n    startsExpr\n  }),\n  _module: createKeywordLike(\"module\", {\n    startsExpr\n  }),\n  _namespace: createKeywordLike(\"namespace\", {\n    startsExpr\n  }),\n  _interface: createKeywordLike(\"interface\", {\n    startsExpr\n  }),\n  _type: createKeywordLike(\"type\", {\n    startsExpr\n  }),\n  _opaque: createKeywordLike(\"opaque\", {\n    startsExpr\n  }),\n  name: createToken(\"name\", {\n    startsExpr\n  }),\n  string: createToken(\"string\", {\n    startsExpr\n  }),\n  num: createToken(\"num\", {\n    startsExpr\n  }),\n  bigint: createToken(\"bigint\", {\n    startsExpr\n  }),\n  decimal: createToken(\"decimal\", {\n    startsExpr\n  }),\n  regexp: createToken(\"regexp\", {\n    startsExpr\n  }),\n  privateName: createToken(\"#name\", {\n    startsExpr\n  }),\n  eof: createToken(\"eof\"),\n  jsxName: createToken(\"jsxName\"),\n  jsxText: createToken(\"jsxText\", {\n    beforeExpr: true\n  }),\n  jsxTagStart: createToken(\"jsxTagStart\", {\n    startsExpr: true\n  }),\n  jsxTagEnd: createToken(\"jsxTagEnd\"),\n  placeholder: createToken(\"%%\", {\n    startsExpr: true\n  })\n};\nfunction tokenIsIdentifier(token) {\n  return token >= 93 && token <= 128;\n}\nfunction tokenKeywordOrIdentifierIsKeyword(token) {\n  return token <= 92;\n}\nfunction tokenIsKeywordOrIdentifier(token) {\n  return token >= 58 && token <= 128;\n}\nfunction tokenIsLiteralPropertyName(token) {\n  return token >= 58 && token <= 132;\n}\nfunction tokenComesBeforeExpression(token) {\n  return tokenBeforeExprs[token];\n}\nfunction tokenCanStartExpression(token) {\n  return tokenStartsExprs[token];\n}\nfunction tokenIsAssignment(token) {\n  return token >= 29 && token <= 33;\n}\nfunction tokenIsFlowInterfaceOrTypeOrOpaque(token) {\n  return token >= 125 && token <= 127;\n}\nfunction tokenIsLoop(token) {\n  return token >= 90 && token <= 92;\n}\nfunction tokenIsKeyword(token) {\n  return token >= 58 && token <= 92;\n}\nfunction tokenIsOperator(token) {\n  return token >= 39 && token <= 59;\n}\nfunction tokenIsPostfix(token) {\n  return token === 34;\n}\nfunction tokenIsPrefix(token) {\n  return tokenPrefixes[token];\n}\nfunction tokenIsTSTypeOperator(token) {\n  return token >= 117 && token <= 119;\n}\nfunction tokenIsTSDeclarationStart(token) {\n  return token >= 120 && token <= 126;\n}\nfunction tokenLabelName(token) {\n  return tokenLabels[token];\n}\nfunction tokenOperatorPrecedence(token) {\n  return tokenBinops[token];\n}\nfunction tokenIsBinaryOperator(token) {\n  return tokenBinops[token] !== -1;\n}\nfunction tokenIsRightAssociative(token) {\n  return token === 57;\n}\nfunction tokenIsTemplate(token) {\n  return token >= 24 && token <= 25;\n}\nfunction getExportedToken(token) {\n  return tokenTypes[token];\n}\n{\n  tokenTypes[8].updateContext = context => {\n    context.pop();\n  };\n\n  tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = context => {\n    context.push(types.brace);\n  };\n\n  tokenTypes[22].updateContext = context => {\n    if (context[context.length - 1] === types.template) {\n      context.pop();\n    } else {\n      context.push(types.template);\n    }\n  };\n\n  tokenTypes[138].updateContext = context => {\n    context.push(types.j_expr, types.j_oTag);\n  };\n}\n\nlet nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u0870-\\u0887\\u0889-\\u088e\\u08a0-\\u08c9\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c5d\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cdd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u1711\\u171f-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4c\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7ca\\ua7d0\\ua7d1\\ua7d3\\ua7d5-\\ua7d9\\ua7f2-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nlet nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u0898-\\u089f\\u08ca-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3c\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1715\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u180f-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf-\\u1ace\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\nconst nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nconst nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\nconst astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];\nconst astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];\n\nfunction isInAstralSet(code, set) {\n  let pos = 0x10000;\n\n  for (let i = 0, length = set.length; i < length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n\n  return false;\n}\n\nfunction isIdentifierStart(code) {\n  if (code < 65) return code === 36;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  }\n\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\nfunction isIdentifierChar(code) {\n  if (code < 48) return code === 36;\n  if (code < 58) return true;\n  if (code < 65) return false;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\n\nconst reservedWords = {\n  keyword: [\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\"],\n  strict: [\"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\"],\n  strictBind: [\"eval\", \"arguments\"]\n};\nconst keywords = new Set(reservedWords.keyword);\nconst reservedWordsStrictSet = new Set(reservedWords.strict);\nconst reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\nfunction isReservedWord(word, inModule) {\n  return inModule && word === \"await\" || word === \"enum\";\n}\nfunction isStrictReservedWord(word, inModule) {\n  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n}\nfunction isStrictBindOnlyReservedWord(word) {\n  return reservedWordsStrictBindSet.has(word);\n}\nfunction isStrictBindReservedWord(word, inModule) {\n  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);\n}\nfunction isKeyword(word) {\n  return keywords.has(word);\n}\n\nfunction isIteratorStart(current, next, next2) {\n  return current === 64 && next === 64 && isIdentifierStart(next2);\n}\nconst reservedWordLikeSet = new Set([\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\", \"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\", \"eval\", \"arguments\", \"enum\", \"await\"]);\nfunction canBeReservedWord(word) {\n  return reservedWordLikeSet.has(word);\n}\n\nconst SCOPE_OTHER = 0b000000000,\n      SCOPE_PROGRAM = 0b000000001,\n      SCOPE_FUNCTION = 0b000000010,\n      SCOPE_ARROW = 0b000000100,\n      SCOPE_SIMPLE_CATCH = 0b000001000,\n      SCOPE_SUPER = 0b000010000,\n      SCOPE_DIRECT_SUPER = 0b000100000,\n      SCOPE_CLASS = 0b001000000,\n      SCOPE_STATIC_BLOCK = 0b010000000,\n      SCOPE_TS_MODULE = 0b100000000,\n      SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;\nconst BIND_KIND_VALUE = 0b000000000001,\n      BIND_KIND_TYPE = 0b000000000010,\n      BIND_SCOPE_VAR = 0b000000000100,\n      BIND_SCOPE_LEXICAL = 0b000000001000,\n      BIND_SCOPE_FUNCTION = 0b000000010000,\n      BIND_FLAGS_NONE = 0b000001000000,\n      BIND_FLAGS_CLASS = 0b000010000000,\n      BIND_FLAGS_TS_ENUM = 0b000100000000,\n      BIND_FLAGS_TS_CONST_ENUM = 0b001000000000,\n      BIND_FLAGS_TS_EXPORT_ONLY = 0b010000000000,\n      BIND_FLAGS_FLOW_DECLARE_FN = 0b100000000000;\nconst BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS,\n      BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0,\n      BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0,\n      BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0,\n      BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS,\n      BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0,\n      BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM,\n      BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,\n      BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE,\n      BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE,\n      BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM,\n      BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,\n      BIND_FLOW_DECLARE_FN = BIND_FLAGS_FLOW_DECLARE_FN;\nconst CLASS_ELEMENT_FLAG_STATIC = 0b100,\n      CLASS_ELEMENT_KIND_GETTER = 0b010,\n      CLASS_ELEMENT_KIND_SETTER = 0b001,\n      CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;\nconst CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC,\n      CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC,\n      CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER,\n      CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER,\n      CLASS_ELEMENT_OTHER = 0;\n\nclass BaseParser {\n  constructor() {\n    this.sawUnambiguousESM = false;\n    this.ambiguousScriptDifferentAst = false;\n  }\n\n  hasPlugin(pluginConfig) {\n    if (typeof pluginConfig === \"string\") {\n      return this.plugins.has(pluginConfig);\n    } else {\n      const [pluginName, pluginOptions] = pluginConfig;\n\n      if (!this.hasPlugin(pluginName)) {\n        return false;\n      }\n\n      const actualOptions = this.plugins.get(pluginName);\n\n      for (const key of Object.keys(pluginOptions)) {\n        if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }\n\n  getPluginOption(plugin, name) {\n    var _this$plugins$get;\n\n    return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];\n  }\n\n}\n\nfunction setTrailingComments(node, comments) {\n  if (node.trailingComments === undefined) {\n    node.trailingComments = comments;\n  } else {\n    node.trailingComments.unshift(...comments);\n  }\n}\n\nfunction setLeadingComments(node, comments) {\n  if (node.leadingComments === undefined) {\n    node.leadingComments = comments;\n  } else {\n    node.leadingComments.unshift(...comments);\n  }\n}\n\nfunction setInnerComments(node, comments) {\n  if (node.innerComments === undefined) {\n    node.innerComments = comments;\n  } else {\n    node.innerComments.unshift(...comments);\n  }\n}\n\nfunction adjustInnerComments(node, elements, commentWS) {\n  let lastElement = null;\n  let i = elements.length;\n\n  while (lastElement === null && i > 0) {\n    lastElement = elements[--i];\n  }\n\n  if (lastElement === null || lastElement.start > commentWS.start) {\n    setInnerComments(node, commentWS.comments);\n  } else {\n    setTrailingComments(lastElement, commentWS.comments);\n  }\n}\n\nclass CommentsParser extends BaseParser {\n  addComment(comment) {\n    if (this.filename) comment.loc.filename = this.filename;\n    this.state.comments.push(comment);\n  }\n\n  processComment(node) {\n    const {\n      commentStack\n    } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0) return;\n    let i = commentStackLength - 1;\n    const lastCommentWS = commentStack[i];\n\n    if (lastCommentWS.start === node.end) {\n      lastCommentWS.leadingNode = node;\n      i--;\n    }\n\n    const {\n      start: nodeStart\n    } = node;\n\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n\n      if (commentEnd > nodeStart) {\n        commentWS.containingNode = node;\n        this.finalizeComment(commentWS);\n        commentStack.splice(i, 1);\n      } else {\n        if (commentEnd === nodeStart) {\n          commentWS.trailingNode = node;\n        }\n\n        break;\n      }\n    }\n  }\n\n  finalizeComment(commentWS) {\n    const {\n      comments\n    } = commentWS;\n\n    if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {\n      if (commentWS.leadingNode !== null) {\n        setTrailingComments(commentWS.leadingNode, comments);\n      }\n\n      if (commentWS.trailingNode !== null) {\n        setLeadingComments(commentWS.trailingNode, comments);\n      }\n    } else {\n      const {\n        containingNode: node,\n        start: commentStart\n      } = commentWS;\n\n      if (this.input.charCodeAt(commentStart - 1) === 44) {\n        switch (node.type) {\n          case \"ObjectExpression\":\n          case \"ObjectPattern\":\n          case \"RecordExpression\":\n            adjustInnerComments(node, node.properties, commentWS);\n            break;\n\n          case \"CallExpression\":\n          case \"OptionalCallExpression\":\n            adjustInnerComments(node, node.arguments, commentWS);\n            break;\n\n          case \"FunctionDeclaration\":\n          case \"FunctionExpression\":\n          case \"ArrowFunctionExpression\":\n          case \"ObjectMethod\":\n          case \"ClassMethod\":\n          case \"ClassPrivateMethod\":\n            adjustInnerComments(node, node.params, commentWS);\n            break;\n\n          case \"ArrayExpression\":\n          case \"ArrayPattern\":\n          case \"TupleExpression\":\n            adjustInnerComments(node, node.elements, commentWS);\n            break;\n\n          case \"ExportNamedDeclaration\":\n          case \"ImportDeclaration\":\n            adjustInnerComments(node, node.specifiers, commentWS);\n            break;\n\n          default:\n            {\n              setInnerComments(node, comments);\n            }\n        }\n      } else {\n        setInnerComments(node, comments);\n      }\n    }\n  }\n\n  finalizeRemainingComments() {\n    const {\n      commentStack\n    } = this.state;\n\n    for (let i = commentStack.length - 1; i >= 0; i--) {\n      this.finalizeComment(commentStack[i]);\n    }\n\n    this.state.commentStack = [];\n  }\n\n  resetPreviousNodeTrailingComments(node) {\n    const {\n      commentStack\n    } = this.state;\n    const {\n      length\n    } = commentStack;\n    if (length === 0) return;\n    const commentWS = commentStack[length - 1];\n\n    if (commentWS.leadingNode === node) {\n      commentWS.leadingNode = null;\n    }\n  }\n\n  takeSurroundingComments(node, start, end) {\n    const {\n      commentStack\n    } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0) return;\n    let i = commentStackLength - 1;\n\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n      const commentStart = commentWS.start;\n\n      if (commentStart === end) {\n        commentWS.leadingNode = node;\n      } else if (commentEnd === start) {\n        commentWS.trailingNode = node;\n      } else if (commentEnd < start) {\n        break;\n      }\n    }\n  }\n\n}\n\nconst lineBreak = /\\r\\n?|[\\n\\u2028\\u2029]/;\nconst lineBreakG = new RegExp(lineBreak.source, \"g\");\nfunction isNewLine(code) {\n  switch (code) {\n    case 10:\n    case 13:\n    case 8232:\n    case 8233:\n      return true;\n\n    default:\n      return false;\n  }\n}\nconst skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\nconst skipWhiteSpaceInLine = /(?:[^\\S\\n\\r\\u2028\\u2029]|\\/\\/.*|\\/\\*.*?\\*\\/)*/y;\nconst skipWhiteSpaceToLineBreak = new RegExp(\"(?=(\" + skipWhiteSpaceInLine.source + \"))\\\\1\" + /(?=[\\n\\r\\u2028\\u2029]|\\/\\*(?!.*?\\*\\/)|$)/.source, \"y\");\nfunction isWhitespace(code) {\n  switch (code) {\n    case 0x0009:\n    case 0x000b:\n    case 0x000c:\n    case 32:\n    case 160:\n    case 5760:\n    case 0x2000:\n    case 0x2001:\n    case 0x2002:\n    case 0x2003:\n    case 0x2004:\n    case 0x2005:\n    case 0x2006:\n    case 0x2007:\n    case 0x2008:\n    case 0x2009:\n    case 0x200a:\n    case 0x202f:\n    case 0x205f:\n    case 0x3000:\n    case 0xfeff:\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nclass State {\n  constructor() {\n    this.strict = void 0;\n    this.curLine = void 0;\n    this.lineStart = void 0;\n    this.startLoc = void 0;\n    this.endLoc = void 0;\n    this.errors = [];\n    this.potentialArrowAt = -1;\n    this.noArrowAt = [];\n    this.noArrowParamsConversionAt = [];\n    this.maybeInArrowParameters = false;\n    this.inType = false;\n    this.noAnonFunctionType = false;\n    this.hasFlowComment = false;\n    this.isAmbientContext = false;\n    this.inAbstractClass = false;\n    this.inDisallowConditionalTypesContext = false;\n    this.topicContext = {\n      maxNumOfResolvableTopics: 0,\n      maxTopicIndex: null\n    };\n    this.soloAwait = false;\n    this.inFSharpPipelineDirectBody = false;\n    this.labels = [];\n    this.decoratorStack = [[]];\n    this.comments = [];\n    this.commentStack = [];\n    this.pos = 0;\n    this.type = 135;\n    this.value = null;\n    this.start = 0;\n    this.end = 0;\n    this.lastTokEndLoc = null;\n    this.lastTokStartLoc = null;\n    this.lastTokStart = 0;\n    this.context = [types.brace];\n    this.canStartJSXElement = true;\n    this.containsEsc = false;\n    this.strictErrors = new Map();\n    this.tokensLength = 0;\n  }\n\n  init({\n    strictMode,\n    sourceType,\n    startLine,\n    startColumn\n  }) {\n    this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === \"module\";\n    this.curLine = startLine;\n    this.lineStart = -startColumn;\n    this.startLoc = this.endLoc = new Position(startLine, startColumn, 0);\n  }\n\n  curPosition() {\n    return new Position(this.curLine, this.pos - this.lineStart, this.pos);\n  }\n\n  clone(skipArrays) {\n    const state = new State();\n    const keys = Object.keys(this);\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      let val = this[key];\n\n      if (!skipArrays && Array.isArray(val)) {\n        val = val.slice();\n      }\n\n      state[key] = val;\n    }\n\n    return state;\n  }\n\n}\n\nconst _excluded = [\"at\"],\n      _excluded2 = [\"at\"];\n\nvar _isDigit = function isDigit(code) {\n  return code >= 48 && code <= 57;\n};\nconst VALID_REGEX_FLAGS = new Set([103, 109, 115, 105, 121, 117, 100, 118]);\nconst forbiddenNumericSeparatorSiblings = {\n  decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),\n  hex: new Set([46, 88, 95, 120])\n};\nconst isAllowedNumericSeparatorSibling = {\n  bin: ch => ch === 48 || ch === 49,\n  oct: ch => ch >= 48 && ch <= 55,\n  dec: ch => ch >= 48 && ch <= 57,\n  hex: ch => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102\n};\nclass Token {\n  constructor(state) {\n    this.type = state.type;\n    this.value = state.value;\n    this.start = state.start;\n    this.end = state.end;\n    this.loc = new SourceLocation(state.startLoc, state.endLoc);\n  }\n\n}\nclass Tokenizer extends CommentsParser {\n  constructor(options, input) {\n    super();\n    this.isLookahead = void 0;\n    this.tokens = [];\n    this.state = new State();\n    this.state.init(options);\n    this.input = input;\n    this.length = input.length;\n    this.isLookahead = false;\n  }\n\n  pushToken(token) {\n    this.tokens.length = this.state.tokensLength;\n    this.tokens.push(token);\n    ++this.state.tokensLength;\n  }\n\n  next() {\n    this.checkKeywordEscapes();\n\n    if (this.options.tokens) {\n      this.pushToken(new Token(this.state));\n    }\n\n    this.state.lastTokStart = this.state.start;\n    this.state.lastTokEndLoc = this.state.endLoc;\n    this.state.lastTokStartLoc = this.state.startLoc;\n    this.nextToken();\n  }\n\n  eat(type) {\n    if (this.match(type)) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  match(type) {\n    return this.state.type === type;\n  }\n\n  createLookaheadState(state) {\n    return {\n      pos: state.pos,\n      value: null,\n      type: state.type,\n      start: state.start,\n      end: state.end,\n      context: [this.curContext()],\n      inType: state.inType,\n      startLoc: state.startLoc,\n      lastTokEndLoc: state.lastTokEndLoc,\n      curLine: state.curLine,\n      lineStart: state.lineStart,\n      curPosition: state.curPosition\n    };\n  }\n\n  lookahead() {\n    const old = this.state;\n    this.state = this.createLookaheadState(old);\n    this.isLookahead = true;\n    this.nextToken();\n    this.isLookahead = false;\n    const curr = this.state;\n    this.state = old;\n    return curr;\n  }\n\n  nextTokenStart() {\n    return this.nextTokenStartSince(this.state.pos);\n  }\n\n  nextTokenStartSince(pos) {\n    skipWhiteSpace.lastIndex = pos;\n    return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;\n  }\n\n  lookaheadCharCode() {\n    return this.input.charCodeAt(this.nextTokenStart());\n  }\n\n  codePointAtPos(pos) {\n    let cp = this.input.charCodeAt(pos);\n\n    if ((cp & 0xfc00) === 0xd800 && ++pos < this.input.length) {\n      const trail = this.input.charCodeAt(pos);\n\n      if ((trail & 0xfc00) === 0xdc00) {\n        cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);\n      }\n    }\n\n    return cp;\n  }\n\n  setStrict(strict) {\n    this.state.strict = strict;\n\n    if (strict) {\n      this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, {\n        at\n      }));\n      this.state.strictErrors.clear();\n    }\n  }\n\n  curContext() {\n    return this.state.context[this.state.context.length - 1];\n  }\n\n  nextToken() {\n    this.skipSpace();\n    this.state.start = this.state.pos;\n    if (!this.isLookahead) this.state.startLoc = this.state.curPosition();\n\n    if (this.state.pos >= this.length) {\n      this.finishToken(135);\n      return;\n    }\n\n    this.getTokenFromCode(this.codePointAtPos(this.state.pos));\n  }\n\n  skipBlockComment() {\n    let startLoc;\n    if (!this.isLookahead) startLoc = this.state.curPosition();\n    const start = this.state.pos;\n    const end = this.input.indexOf(\"*/\", start + 2);\n\n    if (end === -1) {\n      throw this.raise(Errors.UnterminatedComment, {\n        at: this.state.curPosition()\n      });\n    }\n\n    this.state.pos = end + 2;\n    lineBreakG.lastIndex = start + 2;\n\n    while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {\n      ++this.state.curLine;\n      this.state.lineStart = lineBreakG.lastIndex;\n    }\n\n    if (this.isLookahead) return;\n    const comment = {\n      type: \"CommentBlock\",\n      value: this.input.slice(start + 2, end),\n      start,\n      end: end + 2,\n      loc: new SourceLocation(startLoc, this.state.curPosition())\n    };\n    if (this.options.tokens) this.pushToken(comment);\n    return comment;\n  }\n\n  skipLineComment(startSkip) {\n    const start = this.state.pos;\n    let startLoc;\n    if (!this.isLookahead) startLoc = this.state.curPosition();\n    let ch = this.input.charCodeAt(this.state.pos += startSkip);\n\n    if (this.state.pos < this.length) {\n      while (!isNewLine(ch) && ++this.state.pos < this.length) {\n        ch = this.input.charCodeAt(this.state.pos);\n      }\n    }\n\n    if (this.isLookahead) return;\n    const end = this.state.pos;\n    const value = this.input.slice(start + startSkip, end);\n    const comment = {\n      type: \"CommentLine\",\n      value,\n      start,\n      end,\n      loc: new SourceLocation(startLoc, this.state.curPosition())\n    };\n    if (this.options.tokens) this.pushToken(comment);\n    return comment;\n  }\n\n  skipSpace() {\n    const spaceStart = this.state.pos;\n    const comments = [];\n\n    loop: while (this.state.pos < this.length) {\n      const ch = this.input.charCodeAt(this.state.pos);\n\n      switch (ch) {\n        case 32:\n        case 160:\n        case 9:\n          ++this.state.pos;\n          break;\n\n        case 13:\n          if (this.input.charCodeAt(this.state.pos + 1) === 10) {\n            ++this.state.pos;\n          }\n\n        case 10:\n        case 8232:\n        case 8233:\n          ++this.state.pos;\n          ++this.state.curLine;\n          this.state.lineStart = this.state.pos;\n          break;\n\n        case 47:\n          switch (this.input.charCodeAt(this.state.pos + 1)) {\n            case 42:\n              {\n                const comment = this.skipBlockComment();\n\n                if (comment !== undefined) {\n                  this.addComment(comment);\n                  if (this.options.attachComment) comments.push(comment);\n                }\n\n                break;\n              }\n\n            case 47:\n              {\n                const comment = this.skipLineComment(2);\n\n                if (comment !== undefined) {\n                  this.addComment(comment);\n                  if (this.options.attachComment) comments.push(comment);\n                }\n\n                break;\n              }\n\n            default:\n              break loop;\n          }\n\n          break;\n\n        default:\n          if (isWhitespace(ch)) {\n            ++this.state.pos;\n          } else if (ch === 45 && !this.inModule) {\n            const pos = this.state.pos;\n\n            if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {\n              const comment = this.skipLineComment(3);\n\n              if (comment !== undefined) {\n                this.addComment(comment);\n                if (this.options.attachComment) comments.push(comment);\n              }\n            } else {\n              break loop;\n            }\n          } else if (ch === 60 && !this.inModule) {\n            const pos = this.state.pos;\n\n            if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {\n              const comment = this.skipLineComment(4);\n\n              if (comment !== undefined) {\n                this.addComment(comment);\n                if (this.options.attachComment) comments.push(comment);\n              }\n            } else {\n              break loop;\n            }\n          } else {\n            break loop;\n          }\n\n      }\n    }\n\n    if (comments.length > 0) {\n      const end = this.state.pos;\n      const CommentWhitespace = {\n        start: spaceStart,\n        end,\n        comments,\n        leadingNode: null,\n        trailingNode: null,\n        containingNode: null\n      };\n      this.state.commentStack.push(CommentWhitespace);\n    }\n  }\n\n  finishToken(type, val) {\n    this.state.end = this.state.pos;\n    this.state.endLoc = this.state.curPosition();\n    const prevType = this.state.type;\n    this.state.type = type;\n    this.state.value = val;\n\n    if (!this.isLookahead) {\n      this.updateContext(prevType);\n    }\n  }\n\n  replaceToken(type) {\n    this.state.type = type;\n    this.updateContext();\n  }\n\n  readToken_numberSign() {\n    if (this.state.pos === 0 && this.readToken_interpreter()) {\n      return;\n    }\n\n    const nextPos = this.state.pos + 1;\n    const next = this.codePointAtPos(nextPos);\n\n    if (next >= 48 && next <= 57) {\n      throw this.raise(Errors.UnexpectedDigitAfterHash, {\n        at: this.state.curPosition()\n      });\n    }\n\n    if (next === 123 || next === 91 && this.hasPlugin(\"recordAndTuple\")) {\n      this.expectPlugin(\"recordAndTuple\");\n\n      if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"hash\") {\n        throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, {\n          at: this.state.curPosition()\n        });\n      }\n\n      this.state.pos += 2;\n\n      if (next === 123) {\n        this.finishToken(7);\n      } else {\n        this.finishToken(1);\n      }\n    } else if (isIdentifierStart(next)) {\n      ++this.state.pos;\n      this.finishToken(134, this.readWord1(next));\n    } else if (next === 92) {\n      ++this.state.pos;\n      this.finishToken(134, this.readWord1());\n    } else {\n      this.finishOp(27, 1);\n    }\n  }\n\n  readToken_dot() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next >= 48 && next <= 57) {\n      this.readNumber(true);\n      return;\n    }\n\n    if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {\n      this.state.pos += 3;\n      this.finishToken(21);\n    } else {\n      ++this.state.pos;\n      this.finishToken(16);\n    }\n  }\n\n  readToken_slash() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61) {\n      this.finishOp(31, 2);\n    } else {\n      this.finishOp(56, 1);\n    }\n  }\n\n  readToken_interpreter() {\n    if (this.state.pos !== 0 || this.length < 2) return false;\n    let ch = this.input.charCodeAt(this.state.pos + 1);\n    if (ch !== 33) return false;\n    const start = this.state.pos;\n    this.state.pos += 1;\n\n    while (!isNewLine(ch) && ++this.state.pos < this.length) {\n      ch = this.input.charCodeAt(this.state.pos);\n    }\n\n    const value = this.input.slice(start + 2, this.state.pos);\n    this.finishToken(28, value);\n    return true;\n  }\n\n  readToken_mult_modulo(code) {\n    let type = code === 42 ? 55 : 54;\n    let width = 1;\n    let next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (code === 42 && next === 42) {\n      width++;\n      next = this.input.charCodeAt(this.state.pos + 2);\n      type = 57;\n    }\n\n    if (next === 61 && !this.state.inType) {\n      width++;\n      type = code === 37 ? 33 : 30;\n    }\n\n    this.finishOp(type, width);\n  }\n\n  readToken_pipe_amp(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      if (this.input.charCodeAt(this.state.pos + 2) === 61) {\n        this.finishOp(30, 3);\n      } else {\n        this.finishOp(code === 124 ? 41 : 42, 2);\n      }\n\n      return;\n    }\n\n    if (code === 124) {\n      if (next === 62) {\n        this.finishOp(39, 2);\n        return;\n      }\n\n      if (this.hasPlugin(\"recordAndTuple\") && next === 125) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, {\n            at: this.state.curPosition()\n          });\n        }\n\n        this.state.pos += 2;\n        this.finishToken(9);\n        return;\n      }\n\n      if (this.hasPlugin(\"recordAndTuple\") && next === 93) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, {\n            at: this.state.curPosition()\n          });\n        }\n\n        this.state.pos += 2;\n        this.finishToken(4);\n        return;\n      }\n    }\n\n    if (next === 61) {\n      this.finishOp(30, 2);\n      return;\n    }\n\n    this.finishOp(code === 124 ? 43 : 45, 1);\n  }\n\n  readToken_caret() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61 && !this.state.inType) {\n      this.finishOp(32, 2);\n    } else if (next === 94 && this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"hack\",\n      topicToken: \"^^\"\n    }])) {\n      this.finishOp(37, 2);\n      const lookaheadCh = this.input.codePointAt(this.state.pos);\n\n      if (lookaheadCh === 94) {\n        throw this.unexpected();\n      }\n    } else {\n      this.finishOp(44, 1);\n    }\n  }\n\n  readToken_atSign() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 64 && this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"hack\",\n      topicToken: \"@@\"\n    }])) {\n      this.finishOp(38, 2);\n    } else {\n      this.finishOp(26, 1);\n    }\n  }\n\n  readToken_plus_min(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      this.finishOp(34, 2);\n      return;\n    }\n\n    if (next === 61) {\n      this.finishOp(30, 2);\n    } else {\n      this.finishOp(53, 1);\n    }\n  }\n\n  readToken_lt() {\n    const {\n      pos\n    } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n\n    if (next === 60) {\n      if (this.input.charCodeAt(pos + 2) === 61) {\n        this.finishOp(30, 3);\n        return;\n      }\n\n      this.finishOp(51, 2);\n      return;\n    }\n\n    if (next === 61) {\n      this.finishOp(49, 2);\n      return;\n    }\n\n    this.finishOp(47, 1);\n  }\n\n  readToken_gt() {\n    const {\n      pos\n    } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n\n    if (next === 62) {\n      const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;\n\n      if (this.input.charCodeAt(pos + size) === 61) {\n        this.finishOp(30, size + 1);\n        return;\n      }\n\n      this.finishOp(52, size);\n      return;\n    }\n\n    if (next === 61) {\n      this.finishOp(49, 2);\n      return;\n    }\n\n    this.finishOp(48, 1);\n  }\n\n  readToken_eq_excl(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61) {\n      this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);\n      return;\n    }\n\n    if (code === 61 && next === 62) {\n      this.state.pos += 2;\n      this.finishToken(19);\n      return;\n    }\n\n    this.finishOp(code === 61 ? 29 : 35, 1);\n  }\n\n  readToken_question() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    const next2 = this.input.charCodeAt(this.state.pos + 2);\n\n    if (next === 63) {\n      if (next2 === 61) {\n        this.finishOp(30, 3);\n      } else {\n        this.finishOp(40, 2);\n      }\n    } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {\n      this.state.pos += 2;\n      this.finishToken(18);\n    } else {\n      ++this.state.pos;\n      this.finishToken(17);\n    }\n  }\n\n  getTokenFromCode(code) {\n    switch (code) {\n      case 46:\n        this.readToken_dot();\n        return;\n\n      case 40:\n        ++this.state.pos;\n        this.finishToken(10);\n        return;\n\n      case 41:\n        ++this.state.pos;\n        this.finishToken(11);\n        return;\n\n      case 59:\n        ++this.state.pos;\n        this.finishToken(13);\n        return;\n\n      case 44:\n        ++this.state.pos;\n        this.finishToken(12);\n        return;\n\n      case 91:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, {\n              at: this.state.curPosition()\n            });\n          }\n\n          this.state.pos += 2;\n          this.finishToken(2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(0);\n        }\n\n        return;\n\n      case 93:\n        ++this.state.pos;\n        this.finishToken(3);\n        return;\n\n      case 123:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, {\n              at: this.state.curPosition()\n            });\n          }\n\n          this.state.pos += 2;\n          this.finishToken(6);\n        } else {\n          ++this.state.pos;\n          this.finishToken(5);\n        }\n\n        return;\n\n      case 125:\n        ++this.state.pos;\n        this.finishToken(8);\n        return;\n\n      case 58:\n        if (this.hasPlugin(\"functionBind\") && this.input.charCodeAt(this.state.pos + 1) === 58) {\n          this.finishOp(15, 2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(14);\n        }\n\n        return;\n\n      case 63:\n        this.readToken_question();\n        return;\n\n      case 96:\n        this.readTemplateToken();\n        return;\n\n      case 48:\n        {\n          const next = this.input.charCodeAt(this.state.pos + 1);\n\n          if (next === 120 || next === 88) {\n            this.readRadixNumber(16);\n            return;\n          }\n\n          if (next === 111 || next === 79) {\n            this.readRadixNumber(8);\n            return;\n          }\n\n          if (next === 98 || next === 66) {\n            this.readRadixNumber(2);\n            return;\n          }\n        }\n\n      case 49:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n        this.readNumber(false);\n        return;\n\n      case 34:\n      case 39:\n        this.readString(code);\n        return;\n\n      case 47:\n        this.readToken_slash();\n        return;\n\n      case 37:\n      case 42:\n        this.readToken_mult_modulo(code);\n        return;\n\n      case 124:\n      case 38:\n        this.readToken_pipe_amp(code);\n        return;\n\n      case 94:\n        this.readToken_caret();\n        return;\n\n      case 43:\n      case 45:\n        this.readToken_plus_min(code);\n        return;\n\n      case 60:\n        this.readToken_lt();\n        return;\n\n      case 62:\n        this.readToken_gt();\n        return;\n\n      case 61:\n      case 33:\n        this.readToken_eq_excl(code);\n        return;\n\n      case 126:\n        this.finishOp(36, 1);\n        return;\n\n      case 64:\n        this.readToken_atSign();\n        return;\n\n      case 35:\n        this.readToken_numberSign();\n        return;\n\n      case 92:\n        this.readWord();\n        return;\n\n      default:\n        if (isIdentifierStart(code)) {\n          this.readWord(code);\n          return;\n        }\n\n    }\n\n    throw this.raise(Errors.InvalidOrUnexpectedToken, {\n      at: this.state.curPosition(),\n      unexpected: String.fromCodePoint(code)\n    });\n  }\n\n  finishOp(type, size) {\n    const str = this.input.slice(this.state.pos, this.state.pos + size);\n    this.state.pos += size;\n    this.finishToken(type, str);\n  }\n\n  readRegexp() {\n    const startLoc = this.state.startLoc;\n    const start = this.state.start + 1;\n    let escaped, inClass;\n    let {\n      pos\n    } = this.state;\n\n    for (;; ++pos) {\n      if (pos >= this.length) {\n        throw this.raise(Errors.UnterminatedRegExp, {\n          at: createPositionWithColumnOffset(startLoc, 1)\n        });\n      }\n\n      const ch = this.input.charCodeAt(pos);\n\n      if (isNewLine(ch)) {\n        throw this.raise(Errors.UnterminatedRegExp, {\n          at: createPositionWithColumnOffset(startLoc, 1)\n        });\n      }\n\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (ch === 91) {\n          inClass = true;\n        } else if (ch === 93 && inClass) {\n          inClass = false;\n        } else if (ch === 47 && !inClass) {\n          break;\n        }\n\n        escaped = ch === 92;\n      }\n    }\n\n    const content = this.input.slice(start, pos);\n    ++pos;\n    let mods = \"\";\n\n    const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);\n\n    while (pos < this.length) {\n      const cp = this.codePointAtPos(pos);\n      const char = String.fromCharCode(cp);\n\n      if (VALID_REGEX_FLAGS.has(cp)) {\n        if (cp === 118) {\n          this.expectPlugin(\"regexpUnicodeSets\", nextPos());\n\n          if (mods.includes(\"u\")) {\n            this.raise(Errors.IncompatibleRegExpUVFlags, {\n              at: nextPos()\n            });\n          }\n        } else if (cp === 117) {\n          if (mods.includes(\"v\")) {\n            this.raise(Errors.IncompatibleRegExpUVFlags, {\n              at: nextPos()\n            });\n          }\n        }\n\n        if (mods.includes(char)) {\n          this.raise(Errors.DuplicateRegExpFlags, {\n            at: nextPos()\n          });\n        }\n      } else if (isIdentifierChar(cp) || cp === 92) {\n        this.raise(Errors.MalformedRegExpFlags, {\n          at: nextPos()\n        });\n      } else {\n        break;\n      }\n\n      ++pos;\n      mods += char;\n    }\n\n    this.state.pos = pos;\n    this.finishToken(133, {\n      pattern: content,\n      flags: mods\n    });\n  }\n\n  readInt(radix, len, forceLen, allowNumSeparator = true) {\n    const start = this.state.pos;\n    const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;\n    const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;\n    let invalid = false;\n    let total = 0;\n\n    for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n      const code = this.input.charCodeAt(this.state.pos);\n      let val;\n\n      if (code === 95 && allowNumSeparator !== \"bail\") {\n        const prev = this.input.charCodeAt(this.state.pos - 1);\n        const next = this.input.charCodeAt(this.state.pos + 1);\n\n        if (!allowNumSeparator) {\n          this.raise(Errors.NumericSeparatorInEscapeSequence, {\n            at: this.state.curPosition()\n          });\n        } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {\n          this.raise(Errors.UnexpectedNumericSeparator, {\n            at: this.state.curPosition()\n          });\n        }\n\n        ++this.state.pos;\n        continue;\n      }\n\n      if (code >= 97) {\n        val = code - 97 + 10;\n      } else if (code >= 65) {\n        val = code - 65 + 10;\n      } else if (_isDigit(code)) {\n        val = code - 48;\n      } else {\n        val = Infinity;\n      }\n\n      if (val >= radix) {\n        if (this.options.errorRecovery && val <= 9) {\n          val = 0;\n          this.raise(Errors.InvalidDigit, {\n            at: this.state.curPosition(),\n            radix\n          });\n        } else if (forceLen) {\n          val = 0;\n          invalid = true;\n        } else {\n          break;\n        }\n      }\n\n      ++this.state.pos;\n      total = total * radix + val;\n    }\n\n    if (this.state.pos === start || len != null && this.state.pos - start !== len || invalid) {\n      return null;\n    }\n\n    return total;\n  }\n\n  readRadixNumber(radix) {\n    const startLoc = this.state.curPosition();\n    let isBigInt = false;\n    this.state.pos += 2;\n    const val = this.readInt(radix);\n\n    if (val == null) {\n      this.raise(Errors.InvalidDigit, {\n        at: createPositionWithColumnOffset(startLoc, 2),\n        radix\n      });\n    }\n\n    const next = this.input.charCodeAt(this.state.pos);\n\n    if (next === 110) {\n      ++this.state.pos;\n      isBigInt = true;\n    } else if (next === 109) {\n      throw this.raise(Errors.InvalidDecimal, {\n        at: startLoc\n      });\n    }\n\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(Errors.NumberIdentifier, {\n        at: this.state.curPosition()\n      });\n    }\n\n    if (isBigInt) {\n      const str = this.input.slice(startLoc.index, this.state.pos).replace(/[_n]/g, \"\");\n      this.finishToken(131, str);\n      return;\n    }\n\n    this.finishToken(130, val);\n  }\n\n  readNumber(startsWithDot) {\n    const start = this.state.pos;\n    const startLoc = this.state.curPosition();\n    let isFloat = false;\n    let isBigInt = false;\n    let isDecimal = false;\n    let hasExponent = false;\n    let isOctal = false;\n\n    if (!startsWithDot && this.readInt(10) === null) {\n      this.raise(Errors.InvalidNumber, {\n        at: this.state.curPosition()\n      });\n    }\n\n    const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n\n    if (hasLeadingZero) {\n      const integer = this.input.slice(start, this.state.pos);\n      this.recordStrictModeErrors(Errors.StrictOctalLiteral, {\n        at: startLoc\n      });\n\n      if (!this.state.strict) {\n        const underscorePos = integer.indexOf(\"_\");\n\n        if (underscorePos > 0) {\n          this.raise(Errors.ZeroDigitNumericSeparator, {\n            at: createPositionWithColumnOffset(startLoc, underscorePos)\n          });\n        }\n      }\n\n      isOctal = hasLeadingZero && !/[89]/.test(integer);\n    }\n\n    let next = this.input.charCodeAt(this.state.pos);\n\n    if (next === 46 && !isOctal) {\n      ++this.state.pos;\n      this.readInt(10);\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if ((next === 69 || next === 101) && !isOctal) {\n      next = this.input.charCodeAt(++this.state.pos);\n\n      if (next === 43 || next === 45) {\n        ++this.state.pos;\n      }\n\n      if (this.readInt(10) === null) {\n        this.raise(Errors.InvalidOrMissingExponent, {\n          at: startLoc\n        });\n      }\n\n      isFloat = true;\n      hasExponent = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if (next === 110) {\n      if (isFloat || hasLeadingZero) {\n        this.raise(Errors.InvalidBigIntLiteral, {\n          at: startLoc\n        });\n      }\n\n      ++this.state.pos;\n      isBigInt = true;\n    }\n\n    if (next === 109) {\n      this.expectPlugin(\"decimal\", this.state.curPosition());\n\n      if (hasExponent || hasLeadingZero) {\n        this.raise(Errors.InvalidDecimal, {\n          at: startLoc\n        });\n      }\n\n      ++this.state.pos;\n      isDecimal = true;\n    }\n\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(Errors.NumberIdentifier, {\n        at: this.state.curPosition()\n      });\n    }\n\n    const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, \"\");\n\n    if (isBigInt) {\n      this.finishToken(131, str);\n      return;\n    }\n\n    if (isDecimal) {\n      this.finishToken(132, str);\n      return;\n    }\n\n    const val = isOctal ? parseInt(str, 8) : parseFloat(str);\n    this.finishToken(130, val);\n  }\n\n  readCodePoint(throwOnInvalid) {\n    const ch = this.input.charCodeAt(this.state.pos);\n    let code;\n\n    if (ch === 123) {\n      ++this.state.pos;\n      code = this.readHexChar(this.input.indexOf(\"}\", this.state.pos) - this.state.pos, true, throwOnInvalid);\n      ++this.state.pos;\n\n      if (code !== null && code > 0x10ffff) {\n        if (throwOnInvalid) {\n          this.raise(Errors.InvalidCodePoint, {\n            at: this.state.curPosition()\n          });\n        } else {\n          return null;\n        }\n      }\n    } else {\n      code = this.readHexChar(4, false, throwOnInvalid);\n    }\n\n    return code;\n  }\n\n  readString(quote) {\n    let out = \"\",\n        chunkStart = ++this.state.pos;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(Errors.UnterminatedString, {\n          at: this.state.startLoc\n        });\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote) break;\n\n      if (ch === 92) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.readEscapedChar(false);\n        chunkStart = this.state.pos;\n      } else if (ch === 8232 || ch === 8233) {\n        ++this.state.pos;\n        ++this.state.curLine;\n        this.state.lineStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        throw this.raise(Errors.UnterminatedString, {\n          at: this.state.startLoc\n        });\n      } else {\n        ++this.state.pos;\n      }\n    }\n\n    out += this.input.slice(chunkStart, this.state.pos++);\n    this.finishToken(129, out);\n  }\n\n  readTemplateContinuation() {\n    if (!this.match(8)) {\n      this.unexpected(null, 8);\n    }\n\n    this.state.pos--;\n    this.readTemplateToken();\n  }\n\n  readTemplateToken() {\n    let out = \"\",\n        chunkStart = this.state.pos,\n        containsInvalid = false;\n    ++this.state.pos;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(Errors.UnterminatedTemplate, {\n          at: createPositionWithColumnOffset(this.state.startLoc, 1)\n        });\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n\n      if (ch === 96) {\n        ++this.state.pos;\n        out += this.input.slice(chunkStart, this.state.pos);\n        this.finishToken(24, containsInvalid ? null : out);\n        return;\n      }\n\n      if (ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {\n        this.state.pos += 2;\n        out += this.input.slice(chunkStart, this.state.pos);\n        this.finishToken(25, containsInvalid ? null : out);\n        return;\n      }\n\n      if (ch === 92) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        const escaped = this.readEscapedChar(true);\n\n        if (escaped === null) {\n          containsInvalid = true;\n        } else {\n          out += escaped;\n        }\n\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        ++this.state.pos;\n\n        switch (ch) {\n          case 13:\n            if (this.input.charCodeAt(this.state.pos) === 10) {\n              ++this.state.pos;\n            }\n\n          case 10:\n            out += \"\\n\";\n            break;\n\n          default:\n            out += String.fromCharCode(ch);\n            break;\n        }\n\n        ++this.state.curLine;\n        this.state.lineStart = this.state.pos;\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n  }\n\n  recordStrictModeErrors(toParseError, {\n    at\n  }) {\n    const index = at.index;\n\n    if (this.state.strict && !this.state.strictErrors.has(index)) {\n      this.raise(toParseError, {\n        at\n      });\n    } else {\n      this.state.strictErrors.set(index, [toParseError, at]);\n    }\n  }\n\n  readEscapedChar(inTemplate) {\n    const throwOnInvalid = !inTemplate;\n    const ch = this.input.charCodeAt(++this.state.pos);\n    ++this.state.pos;\n\n    switch (ch) {\n      case 110:\n        return \"\\n\";\n\n      case 114:\n        return \"\\r\";\n\n      case 120:\n        {\n          const code = this.readHexChar(2, false, throwOnInvalid);\n          return code === null ? null : String.fromCharCode(code);\n        }\n\n      case 117:\n        {\n          const code = this.readCodePoint(throwOnInvalid);\n          return code === null ? null : String.fromCodePoint(code);\n        }\n\n      case 116:\n        return \"\\t\";\n\n      case 98:\n        return \"\\b\";\n\n      case 118:\n        return \"\\u000b\";\n\n      case 102:\n        return \"\\f\";\n\n      case 13:\n        if (this.input.charCodeAt(this.state.pos) === 10) {\n          ++this.state.pos;\n        }\n\n      case 10:\n        this.state.lineStart = this.state.pos;\n        ++this.state.curLine;\n\n      case 8232:\n      case 8233:\n        return \"\";\n\n      case 56:\n      case 57:\n        if (inTemplate) {\n          return null;\n        } else {\n          this.recordStrictModeErrors(Errors.StrictNumericEscape, {\n            at: createPositionWithColumnOffset(this.state.curPosition(), -1)\n          });\n        }\n\n      default:\n        if (ch >= 48 && ch <= 55) {\n          const codePos = createPositionWithColumnOffset(this.state.curPosition(), -1);\n          const match = this.input.slice(this.state.pos - 1, this.state.pos + 2).match(/^[0-7]+/);\n          let octalStr = match[0];\n          let octal = parseInt(octalStr, 8);\n\n          if (octal > 255) {\n            octalStr = octalStr.slice(0, -1);\n            octal = parseInt(octalStr, 8);\n          }\n\n          this.state.pos += octalStr.length - 1;\n          const next = this.input.charCodeAt(this.state.pos);\n\n          if (octalStr !== \"0\" || next === 56 || next === 57) {\n            if (inTemplate) {\n              return null;\n            } else {\n              this.recordStrictModeErrors(Errors.StrictNumericEscape, {\n                at: codePos\n              });\n            }\n          }\n\n          return String.fromCharCode(octal);\n        }\n\n        return String.fromCharCode(ch);\n    }\n  }\n\n  readHexChar(len, forceLen, throwOnInvalid) {\n    const codeLoc = this.state.curPosition();\n    const n = this.readInt(16, len, forceLen, false);\n\n    if (n === null) {\n      if (throwOnInvalid) {\n        this.raise(Errors.InvalidEscapeSequence, {\n          at: codeLoc\n        });\n      } else {\n        this.state.pos = codeLoc.index - 1;\n      }\n    }\n\n    return n;\n  }\n\n  readWord1(firstCode) {\n    this.state.containsEsc = false;\n    let word = \"\";\n    const start = this.state.pos;\n    let chunkStart = this.state.pos;\n\n    if (firstCode !== undefined) {\n      this.state.pos += firstCode <= 0xffff ? 1 : 2;\n    }\n\n    while (this.state.pos < this.length) {\n      const ch = this.codePointAtPos(this.state.pos);\n\n      if (isIdentifierChar(ch)) {\n        this.state.pos += ch <= 0xffff ? 1 : 2;\n      } else if (ch === 92) {\n        this.state.containsEsc = true;\n        word += this.input.slice(chunkStart, this.state.pos);\n        const escStart = this.state.curPosition();\n        const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;\n\n        if (this.input.charCodeAt(++this.state.pos) !== 117) {\n          this.raise(Errors.MissingUnicodeEscape, {\n            at: this.state.curPosition()\n          });\n          chunkStart = this.state.pos - 1;\n          continue;\n        }\n\n        ++this.state.pos;\n        const esc = this.readCodePoint(true);\n\n        if (esc !== null) {\n          if (!identifierCheck(esc)) {\n            this.raise(Errors.EscapedCharNotAnIdentifier, {\n              at: escStart\n            });\n          }\n\n          word += String.fromCodePoint(esc);\n        }\n\n        chunkStart = this.state.pos;\n      } else {\n        break;\n      }\n    }\n\n    return word + this.input.slice(chunkStart, this.state.pos);\n  }\n\n  readWord(firstCode) {\n    const word = this.readWord1(firstCode);\n    const type = keywords$1.get(word);\n\n    if (type !== undefined) {\n      this.finishToken(type, tokenLabelName(type));\n    } else {\n      this.finishToken(128, word);\n    }\n  }\n\n  checkKeywordEscapes() {\n    const {\n      type\n    } = this.state;\n\n    if (tokenIsKeyword(type) && this.state.containsEsc) {\n      this.raise(Errors.InvalidEscapedReservedWord, {\n        at: this.state.startLoc,\n        reservedWord: tokenLabelName(type)\n      });\n    }\n  }\n\n  raise(toParseError, raiseProperties) {\n    const {\n      at\n    } = raiseProperties,\n          details = _objectWithoutPropertiesLoose(raiseProperties, _excluded);\n\n    const loc = at instanceof Position ? at : at.loc.start;\n    const error = toParseError({\n      loc,\n      details\n    });\n    if (!this.options.errorRecovery) throw error;\n    if (!this.isLookahead) this.state.errors.push(error);\n    return error;\n  }\n\n  raiseOverwrite(toParseError, raiseProperties) {\n    const {\n      at\n    } = raiseProperties,\n          details = _objectWithoutPropertiesLoose(raiseProperties, _excluded2);\n\n    const loc = at instanceof Position ? at : at.loc.start;\n    const pos = loc.index;\n    const errors = this.state.errors;\n\n    for (let i = errors.length - 1; i >= 0; i--) {\n      const error = errors[i];\n\n      if (error.loc.index === pos) {\n        return errors[i] = toParseError({\n          loc,\n          details\n        });\n      }\n\n      if (error.loc.index < pos) break;\n    }\n\n    return this.raise(toParseError, raiseProperties);\n  }\n\n  updateContext(prevType) {}\n\n  unexpected(loc, type) {\n    throw this.raise(Errors.UnexpectedToken, {\n      expected: type ? tokenLabelName(type) : null,\n      at: loc != null ? loc : this.state.startLoc\n    });\n  }\n\n  expectPlugin(pluginName, loc) {\n    if (this.hasPlugin(pluginName)) {\n      return true;\n    }\n\n    throw this.raise(Errors.MissingPlugin, {\n      at: loc != null ? loc : this.state.startLoc,\n      missingPlugin: [pluginName]\n    });\n  }\n\n  expectOnePlugin(pluginNames) {\n    if (!pluginNames.some(name => this.hasPlugin(name))) {\n      throw this.raise(Errors.MissingOneOfPlugins, {\n        at: this.state.startLoc,\n        missingPlugin: pluginNames\n      });\n    }\n  }\n\n}\n\nclass Scope {\n  constructor(flags) {\n    this.var = new Set();\n    this.lexical = new Set();\n    this.functions = new Set();\n    this.flags = flags;\n  }\n\n}\nclass ScopeHandler {\n  constructor(parser, inModule) {\n    this.parser = void 0;\n    this.scopeStack = [];\n    this.inModule = void 0;\n    this.undefinedExports = new Map();\n    this.parser = parser;\n    this.inModule = inModule;\n  }\n\n  get inFunction() {\n    return (this.currentVarScopeFlags() & SCOPE_FUNCTION) > 0;\n  }\n\n  get allowSuper() {\n    return (this.currentThisScopeFlags() & SCOPE_SUPER) > 0;\n  }\n\n  get allowDirectSuper() {\n    return (this.currentThisScopeFlags() & SCOPE_DIRECT_SUPER) > 0;\n  }\n\n  get inClass() {\n    return (this.currentThisScopeFlags() & SCOPE_CLASS) > 0;\n  }\n\n  get inClassAndNotInNonArrowFunction() {\n    const flags = this.currentThisScopeFlags();\n    return (flags & SCOPE_CLASS) > 0 && (flags & SCOPE_FUNCTION) === 0;\n  }\n\n  get inStaticBlock() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n\n      if (flags & SCOPE_STATIC_BLOCK) {\n        return true;\n      }\n\n      if (flags & (SCOPE_VAR | SCOPE_CLASS)) {\n        return false;\n      }\n    }\n  }\n\n  get inNonArrowFunction() {\n    return (this.currentThisScopeFlags() & SCOPE_FUNCTION) > 0;\n  }\n\n  get treatFunctionsAsVar() {\n    return this.treatFunctionsAsVarInScope(this.currentScope());\n  }\n\n  createScope(flags) {\n    return new Scope(flags);\n  }\n\n  enter(flags) {\n    this.scopeStack.push(this.createScope(flags));\n  }\n\n  exit() {\n    this.scopeStack.pop();\n  }\n\n  treatFunctionsAsVarInScope(scope) {\n    return !!(scope.flags & (SCOPE_FUNCTION | SCOPE_STATIC_BLOCK) || !this.parser.inModule && scope.flags & SCOPE_PROGRAM);\n  }\n\n  declareName(name, bindingType, loc) {\n    let scope = this.currentScope();\n\n    if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {\n      this.checkRedeclarationInScope(scope, name, bindingType, loc);\n\n      if (bindingType & BIND_SCOPE_FUNCTION) {\n        scope.functions.add(name);\n      } else {\n        scope.lexical.add(name);\n      }\n\n      if (bindingType & BIND_SCOPE_LEXICAL) {\n        this.maybeExportDefined(scope, name);\n      }\n    } else if (bindingType & BIND_SCOPE_VAR) {\n      for (let i = this.scopeStack.length - 1; i >= 0; --i) {\n        scope = this.scopeStack[i];\n        this.checkRedeclarationInScope(scope, name, bindingType, loc);\n        scope.var.add(name);\n        this.maybeExportDefined(scope, name);\n        if (scope.flags & SCOPE_VAR) break;\n      }\n    }\n\n    if (this.parser.inModule && scope.flags & SCOPE_PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n\n  maybeExportDefined(scope, name) {\n    if (this.parser.inModule && scope.flags & SCOPE_PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n\n  checkRedeclarationInScope(scope, name, bindingType, loc) {\n    if (this.isRedeclaredInScope(scope, name, bindingType)) {\n      this.parser.raise(Errors.VarRedeclaration, {\n        at: loc,\n        identifierName: name\n      });\n    }\n  }\n\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (!(bindingType & BIND_KIND_VALUE)) return false;\n\n    if (bindingType & BIND_SCOPE_LEXICAL) {\n      return scope.lexical.has(name) || scope.functions.has(name) || scope.var.has(name);\n    }\n\n    if (bindingType & BIND_SCOPE_FUNCTION) {\n      return scope.lexical.has(name) || !this.treatFunctionsAsVarInScope(scope) && scope.var.has(name);\n    }\n\n    return scope.lexical.has(name) && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical.values().next().value === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.has(name);\n  }\n\n  checkLocalExport(id) {\n    const {\n      name\n    } = id;\n    const topLevelScope = this.scopeStack[0];\n\n    if (!topLevelScope.lexical.has(name) && !topLevelScope.var.has(name) && !topLevelScope.functions.has(name)) {\n      this.undefinedExports.set(name, id.loc.start);\n    }\n  }\n\n  currentScope() {\n    return this.scopeStack[this.scopeStack.length - 1];\n  }\n\n  currentVarScopeFlags() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n\n      if (flags & SCOPE_VAR) {\n        return flags;\n      }\n    }\n  }\n\n  currentThisScopeFlags() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n\n      if (flags & (SCOPE_VAR | SCOPE_CLASS) && !(flags & SCOPE_ARROW)) {\n        return flags;\n      }\n    }\n  }\n\n}\n\nclass FlowScope extends Scope {\n  constructor(...args) {\n    super(...args);\n    this.declareFunctions = new Set();\n  }\n\n}\n\nclass FlowScopeHandler extends ScopeHandler {\n  createScope(flags) {\n    return new FlowScope(flags);\n  }\n\n  declareName(name, bindingType, loc) {\n    const scope = this.currentScope();\n\n    if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {\n      this.checkRedeclarationInScope(scope, name, bindingType, loc);\n      this.maybeExportDefined(scope, name);\n      scope.declareFunctions.add(name);\n      return;\n    }\n\n    super.declareName(...arguments);\n  }\n\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (super.isRedeclaredInScope(...arguments)) return true;\n\n    if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {\n      return !scope.declareFunctions.has(name) && (scope.lexical.has(name) || scope.functions.has(name));\n    }\n\n    return false;\n  }\n\n  checkLocalExport(id) {\n    if (!this.scopeStack[0].declareFunctions.has(id.name)) {\n      super.checkLocalExport(id);\n    }\n  }\n\n}\n\nclass ClassScope {\n  constructor() {\n    this.privateNames = new Set();\n    this.loneAccessors = new Map();\n    this.undefinedPrivateNames = new Map();\n  }\n\n}\nclass ClassScopeHandler {\n  constructor(parser) {\n    this.parser = void 0;\n    this.stack = [];\n    this.undefinedPrivateNames = new Map();\n    this.parser = parser;\n  }\n\n  current() {\n    return this.stack[this.stack.length - 1];\n  }\n\n  enter() {\n    this.stack.push(new ClassScope());\n  }\n\n  exit() {\n    const oldClassScope = this.stack.pop();\n    const current = this.current();\n\n    for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {\n      if (current) {\n        if (!current.undefinedPrivateNames.has(name)) {\n          current.undefinedPrivateNames.set(name, loc);\n        }\n      } else {\n        this.parser.raise(Errors.InvalidPrivateFieldResolution, {\n          at: loc,\n          identifierName: name\n        });\n      }\n    }\n  }\n\n  declarePrivateName(name, elementType, loc) {\n    const {\n      privateNames,\n      loneAccessors,\n      undefinedPrivateNames\n    } = this.current();\n    let redefined = privateNames.has(name);\n\n    if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {\n      const accessor = redefined && loneAccessors.get(name);\n\n      if (accessor) {\n        const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;\n        const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;\n        const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;\n        const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;\n        redefined = oldKind === newKind || oldStatic !== newStatic;\n        if (!redefined) loneAccessors.delete(name);\n      } else if (!redefined) {\n        loneAccessors.set(name, elementType);\n      }\n    }\n\n    if (redefined) {\n      this.parser.raise(Errors.PrivateNameRedeclaration, {\n        at: loc,\n        identifierName: name\n      });\n    }\n\n    privateNames.add(name);\n    undefinedPrivateNames.delete(name);\n  }\n\n  usePrivateName(name, loc) {\n    let classScope;\n\n    for (classScope of this.stack) {\n      if (classScope.privateNames.has(name)) return;\n    }\n\n    if (classScope) {\n      classScope.undefinedPrivateNames.set(name, loc);\n    } else {\n      this.parser.raise(Errors.InvalidPrivateFieldResolution, {\n        at: loc,\n        identifierName: name\n      });\n    }\n  }\n\n}\n\nconst kExpression = 0,\n      kMaybeArrowParameterDeclaration = 1,\n      kMaybeAsyncArrowParameterDeclaration = 2,\n      kParameterDeclaration = 3;\n\nclass ExpressionScope {\n  constructor(type = kExpression) {\n    this.type = void 0;\n    this.type = type;\n  }\n\n  canBeArrowParameterDeclaration() {\n    return this.type === kMaybeAsyncArrowParameterDeclaration || this.type === kMaybeArrowParameterDeclaration;\n  }\n\n  isCertainlyParameterDeclaration() {\n    return this.type === kParameterDeclaration;\n  }\n\n}\n\nclass ArrowHeadParsingScope extends ExpressionScope {\n  constructor(type) {\n    super(type);\n    this.declarationErrors = new Map();\n  }\n\n  recordDeclarationError(ParsingErrorClass, {\n    at\n  }) {\n    const index = at.index;\n    this.declarationErrors.set(index, [ParsingErrorClass, at]);\n  }\n\n  clearDeclarationError(index) {\n    this.declarationErrors.delete(index);\n  }\n\n  iterateErrors(iterator) {\n    this.declarationErrors.forEach(iterator);\n  }\n\n}\n\nclass ExpressionScopeHandler {\n  constructor(parser) {\n    this.parser = void 0;\n    this.stack = [new ExpressionScope()];\n    this.parser = parser;\n  }\n\n  enter(scope) {\n    this.stack.push(scope);\n  }\n\n  exit() {\n    this.stack.pop();\n  }\n\n  recordParameterInitializerError(toParseError, {\n    at: node\n  }) {\n    const origin = {\n      at: node.loc.start\n    };\n    const {\n      stack\n    } = this;\n    let i = stack.length - 1;\n    let scope = stack[i];\n\n    while (!scope.isCertainlyParameterDeclaration()) {\n      if (scope.canBeArrowParameterDeclaration()) {\n        scope.recordDeclarationError(toParseError, origin);\n      } else {\n        return;\n      }\n\n      scope = stack[--i];\n    }\n\n    this.parser.raise(toParseError, origin);\n  }\n\n  recordArrowParemeterBindingError(error, {\n    at: node\n  }) {\n    const {\n      stack\n    } = this;\n    const scope = stack[stack.length - 1];\n    const origin = {\n      at: node.loc.start\n    };\n\n    if (scope.isCertainlyParameterDeclaration()) {\n      this.parser.raise(error, origin);\n    } else if (scope.canBeArrowParameterDeclaration()) {\n      scope.recordDeclarationError(error, origin);\n    } else {\n      return;\n    }\n  }\n\n  recordAsyncArrowParametersError({\n    at\n  }) {\n    const {\n      stack\n    } = this;\n    let i = stack.length - 1;\n    let scope = stack[i];\n\n    while (scope.canBeArrowParameterDeclaration()) {\n      if (scope.type === kMaybeAsyncArrowParameterDeclaration) {\n        scope.recordDeclarationError(Errors.AwaitBindingIdentifier, {\n          at\n        });\n      }\n\n      scope = stack[--i];\n    }\n  }\n\n  validateAsPattern() {\n    const {\n      stack\n    } = this;\n    const currentScope = stack[stack.length - 1];\n    if (!currentScope.canBeArrowParameterDeclaration()) return;\n    currentScope.iterateErrors(([toParseError, loc]) => {\n      this.parser.raise(toParseError, {\n        at: loc\n      });\n      let i = stack.length - 2;\n      let scope = stack[i];\n\n      while (scope.canBeArrowParameterDeclaration()) {\n        scope.clearDeclarationError(loc.index);\n        scope = stack[--i];\n      }\n    });\n  }\n\n}\nfunction newParameterDeclarationScope() {\n  return new ExpressionScope(kParameterDeclaration);\n}\nfunction newArrowHeadScope() {\n  return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);\n}\nfunction newAsyncArrowScope() {\n  return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);\n}\nfunction newExpressionScope() {\n  return new ExpressionScope();\n}\n\nconst PARAM = 0b0000,\n      PARAM_YIELD = 0b0001,\n      PARAM_AWAIT = 0b0010,\n      PARAM_RETURN = 0b0100,\n      PARAM_IN = 0b1000;\nclass ProductionParameterHandler {\n  constructor() {\n    this.stacks = [];\n  }\n\n  enter(flags) {\n    this.stacks.push(flags);\n  }\n\n  exit() {\n    this.stacks.pop();\n  }\n\n  currentFlags() {\n    return this.stacks[this.stacks.length - 1];\n  }\n\n  get hasAwait() {\n    return (this.currentFlags() & PARAM_AWAIT) > 0;\n  }\n\n  get hasYield() {\n    return (this.currentFlags() & PARAM_YIELD) > 0;\n  }\n\n  get hasReturn() {\n    return (this.currentFlags() & PARAM_RETURN) > 0;\n  }\n\n  get hasIn() {\n    return (this.currentFlags() & PARAM_IN) > 0;\n  }\n\n}\nfunction functionFlags(isAsync, isGenerator) {\n  return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);\n}\n\nclass UtilParser extends Tokenizer {\n  addExtra(node, key, value, enumerable = true) {\n    if (!node) return;\n    const extra = node.extra = node.extra || {};\n\n    if (enumerable) {\n      extra[key] = value;\n    } else {\n      Object.defineProperty(extra, key, {\n        enumerable,\n        value\n      });\n    }\n  }\n\n  isContextual(token) {\n    return this.state.type === token && !this.state.containsEsc;\n  }\n\n  isUnparsedContextual(nameStart, name) {\n    const nameEnd = nameStart + name.length;\n\n    if (this.input.slice(nameStart, nameEnd) === name) {\n      const nextCh = this.input.charCodeAt(nameEnd);\n      return !(isIdentifierChar(nextCh) || (nextCh & 0xfc00) === 0xd800);\n    }\n\n    return false;\n  }\n\n  isLookaheadContextual(name) {\n    const next = this.nextTokenStart();\n    return this.isUnparsedContextual(next, name);\n  }\n\n  eatContextual(token) {\n    if (this.isContextual(token)) {\n      this.next();\n      return true;\n    }\n\n    return false;\n  }\n\n  expectContextual(token, toParseError) {\n    if (!this.eatContextual(token)) {\n      if (toParseError != null) {\n        throw this.raise(toParseError, {\n          at: this.state.startLoc\n        });\n      }\n\n      throw this.unexpected(null, token);\n    }\n  }\n\n  canInsertSemicolon() {\n    return this.match(135) || this.match(8) || this.hasPrecedingLineBreak();\n  }\n\n  hasPrecedingLineBreak() {\n    return lineBreak.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));\n  }\n\n  hasFollowingLineBreak() {\n    skipWhiteSpaceToLineBreak.lastIndex = this.state.end;\n    return skipWhiteSpaceToLineBreak.test(this.input);\n  }\n\n  isLineTerminator() {\n    return this.eat(13) || this.canInsertSemicolon();\n  }\n\n  semicolon(allowAsi = true) {\n    if (allowAsi ? this.isLineTerminator() : this.eat(13)) return;\n    this.raise(Errors.MissingSemicolon, {\n      at: this.state.lastTokEndLoc\n    });\n  }\n\n  expect(type, loc) {\n    this.eat(type) || this.unexpected(loc, type);\n  }\n\n  tryParse(fn, oldState = this.state.clone()) {\n    const abortSignal = {\n      node: null\n    };\n\n    try {\n      const node = fn((node = null) => {\n        abortSignal.node = node;\n        throw abortSignal;\n      });\n\n      if (this.state.errors.length > oldState.errors.length) {\n        const failState = this.state;\n        this.state = oldState;\n        this.state.tokensLength = failState.tokensLength;\n        return {\n          node,\n          error: failState.errors[oldState.errors.length],\n          thrown: false,\n          aborted: false,\n          failState\n        };\n      }\n\n      return {\n        node,\n        error: null,\n        thrown: false,\n        aborted: false,\n        failState: null\n      };\n    } catch (error) {\n      const failState = this.state;\n      this.state = oldState;\n\n      if (error instanceof SyntaxError) {\n        return {\n          node: null,\n          error,\n          thrown: true,\n          aborted: false,\n          failState\n        };\n      }\n\n      if (error === abortSignal) {\n        return {\n          node: abortSignal.node,\n          error: null,\n          thrown: false,\n          aborted: true,\n          failState\n        };\n      }\n\n      throw error;\n    }\n  }\n\n  checkExpressionErrors(refExpressionErrors, andThrow) {\n    if (!refExpressionErrors) return false;\n    const {\n      shorthandAssignLoc,\n      doubleProtoLoc,\n      privateKeyLoc,\n      optionalParametersLoc\n    } = refExpressionErrors;\n    const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;\n\n    if (!andThrow) {\n      return hasErrors;\n    }\n\n    if (shorthandAssignLoc != null) {\n      this.raise(Errors.InvalidCoverInitializedName, {\n        at: shorthandAssignLoc\n      });\n    }\n\n    if (doubleProtoLoc != null) {\n      this.raise(Errors.DuplicateProto, {\n        at: doubleProtoLoc\n      });\n    }\n\n    if (privateKeyLoc != null) {\n      this.raise(Errors.UnexpectedPrivateField, {\n        at: privateKeyLoc\n      });\n    }\n\n    if (optionalParametersLoc != null) {\n      this.unexpected(optionalParametersLoc);\n    }\n  }\n\n  isLiteralPropertyName() {\n    return tokenIsLiteralPropertyName(this.state.type);\n  }\n\n  isPrivateName(node) {\n    return node.type === \"PrivateName\";\n  }\n\n  getPrivateNameSV(node) {\n    return node.id.name;\n  }\n\n  hasPropertyAsPrivateName(node) {\n    return (node.type === \"MemberExpression\" || node.type === \"OptionalMemberExpression\") && this.isPrivateName(node.property);\n  }\n\n  isOptionalChain(node) {\n    return node.type === \"OptionalMemberExpression\" || node.type === \"OptionalCallExpression\";\n  }\n\n  isObjectProperty(node) {\n    return node.type === \"ObjectProperty\";\n  }\n\n  isObjectMethod(node) {\n    return node.type === \"ObjectMethod\";\n  }\n\n  initializeScopes(inModule = this.options.sourceType === \"module\") {\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    const oldExportedIdentifiers = this.exportedIdentifiers;\n    this.exportedIdentifiers = new Set();\n    const oldInModule = this.inModule;\n    this.inModule = inModule;\n    const oldScope = this.scope;\n    const ScopeHandler = this.getScopeHandler();\n    this.scope = new ScopeHandler(this, inModule);\n    const oldProdParam = this.prodParam;\n    this.prodParam = new ProductionParameterHandler();\n    const oldClassScope = this.classScope;\n    this.classScope = new ClassScopeHandler(this);\n    const oldExpressionScope = this.expressionScope;\n    this.expressionScope = new ExpressionScopeHandler(this);\n    return () => {\n      this.state.labels = oldLabels;\n      this.exportedIdentifiers = oldExportedIdentifiers;\n      this.inModule = oldInModule;\n      this.scope = oldScope;\n      this.prodParam = oldProdParam;\n      this.classScope = oldClassScope;\n      this.expressionScope = oldExpressionScope;\n    };\n  }\n\n  enterInitialScopes() {\n    let paramFlags = PARAM;\n\n    if (this.inModule) {\n      paramFlags |= PARAM_AWAIT;\n    }\n\n    this.scope.enter(SCOPE_PROGRAM);\n    this.prodParam.enter(paramFlags);\n  }\n\n  checkDestructuringPrivate(refExpressionErrors) {\n    const {\n      privateKeyLoc\n    } = refExpressionErrors;\n\n    if (privateKeyLoc !== null) {\n      this.expectPlugin(\"destructuringPrivate\", privateKeyLoc);\n    }\n  }\n\n}\nclass ExpressionErrors {\n  constructor() {\n    this.shorthandAssignLoc = null;\n    this.doubleProtoLoc = null;\n    this.privateKeyLoc = null;\n    this.optionalParametersLoc = null;\n  }\n\n}\n\nclass Node {\n  constructor(parser, pos, loc) {\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    this.loc = new SourceLocation(loc);\n    if (parser != null && parser.options.ranges) this.range = [pos, 0];\n    if (parser != null && parser.filename) this.loc.filename = parser.filename;\n  }\n\n}\n\nconst NodePrototype = Node.prototype;\n{\n  NodePrototype.__clone = function () {\n    const newNode = new Node();\n    const keys = Object.keys(this);\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n\n      if (key !== \"leadingComments\" && key !== \"trailingComments\" && key !== \"innerComments\") {\n        newNode[key] = this[key];\n      }\n    }\n\n    return newNode;\n  };\n}\n\nfunction clonePlaceholder(node) {\n  return cloneIdentifier(node);\n}\n\nfunction cloneIdentifier(node) {\n  const {\n    type,\n    start,\n    end,\n    loc,\n    range,\n    extra,\n    name\n  } = node;\n  const cloned = Object.create(NodePrototype);\n  cloned.type = type;\n  cloned.start = start;\n  cloned.end = end;\n  cloned.loc = loc;\n  cloned.range = range;\n  cloned.extra = extra;\n  cloned.name = name;\n\n  if (type === \"Placeholder\") {\n    cloned.expectedNode = node.expectedNode;\n  }\n\n  return cloned;\n}\nfunction cloneStringLiteral(node) {\n  const {\n    type,\n    start,\n    end,\n    loc,\n    range,\n    extra\n  } = node;\n\n  if (type === \"Placeholder\") {\n    return clonePlaceholder(node);\n  }\n\n  const cloned = Object.create(NodePrototype);\n  cloned.type = type;\n  cloned.start = start;\n  cloned.end = end;\n  cloned.loc = loc;\n  cloned.range = range;\n\n  if (node.raw !== undefined) {\n    cloned.raw = node.raw;\n  } else {\n    cloned.extra = extra;\n  }\n\n  cloned.value = node.value;\n  return cloned;\n}\nclass NodeUtils extends UtilParser {\n  startNode() {\n    return new Node(this, this.state.start, this.state.startLoc);\n  }\n\n  startNodeAt(pos, loc) {\n    return new Node(this, pos, loc);\n  }\n\n  startNodeAtNode(type) {\n    return this.startNodeAt(type.start, type.loc.start);\n  }\n\n  finishNode(node, type) {\n    return this.finishNodeAt(node, type, this.state.lastTokEndLoc);\n  }\n\n  finishNodeAt(node, type, endLoc) {\n\n    node.type = type;\n    node.end = endLoc.index;\n    node.loc.end = endLoc;\n    if (this.options.ranges) node.range[1] = endLoc.index;\n    if (this.options.attachComment) this.processComment(node);\n    return node;\n  }\n\n  resetStartLocation(node, start, startLoc) {\n    node.start = start;\n    node.loc.start = startLoc;\n    if (this.options.ranges) node.range[0] = start;\n  }\n\n  resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {\n    node.end = endLoc.index;\n    node.loc.end = endLoc;\n    if (this.options.ranges) node.range[1] = endLoc.index;\n  }\n\n  resetStartLocationFromNode(node, locationNode) {\n    this.resetStartLocation(node, locationNode.start, locationNode.loc.start);\n  }\n\n}\n\nconst reservedTypes = new Set([\"_\", \"any\", \"bool\", \"boolean\", \"empty\", \"extends\", \"false\", \"interface\", \"mixed\", \"null\", \"number\", \"static\", \"string\", \"true\", \"typeof\", \"void\"]);\nconst FlowErrors = ParseErrorEnum`flow`(_ => ({\n  AmbiguousConditionalArrow: _(\"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\"),\n  AmbiguousDeclareModuleKind: _(\"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.\"),\n  AssignReservedType: _(({\n    reservedType\n  }) => `Cannot overwrite reserved type ${reservedType}.`),\n  DeclareClassElement: _(\"The `declare` modifier can only appear on class fields.\"),\n  DeclareClassFieldInitializer: _(\"Initializers are not allowed in fields with the `declare` modifier.\"),\n  DuplicateDeclareModuleExports: _(\"Duplicate `declare module.exports` statement.\"),\n  EnumBooleanMemberNotInitialized: _(({\n    memberName,\n    enumName\n  }) => `Boolean enum members need to be initialized. Use either \\`${memberName} = true,\\` or \\`${memberName} = false,\\` in enum \\`${enumName}\\`.`),\n  EnumDuplicateMemberName: _(({\n    memberName,\n    enumName\n  }) => `Enum member names need to be unique, but the name \\`${memberName}\\` has already been used before in enum \\`${enumName}\\`.`),\n  EnumInconsistentMemberValues: _(({\n    enumName\n  }) => `Enum \\`${enumName}\\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`),\n  EnumInvalidExplicitType: _(({\n    invalidEnumType,\n    enumName\n  }) => `Enum type \\`${invalidEnumType}\\` is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`),\n  EnumInvalidExplicitTypeUnknownSupplied: _(({\n    enumName\n  }) => `Supplied enum type is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`),\n  EnumInvalidMemberInitializerPrimaryType: _(({\n    enumName,\n    memberName,\n    explicitType\n  }) => `Enum \\`${enumName}\\` has type \\`${explicitType}\\`, so the initializer of \\`${memberName}\\` needs to be a ${explicitType} literal.`),\n  EnumInvalidMemberInitializerSymbolType: _(({\n    enumName,\n    memberName\n  }) => `Symbol enum members cannot be initialized. Use \\`${memberName},\\` in enum \\`${enumName}\\`.`),\n  EnumInvalidMemberInitializerUnknownType: _(({\n    enumName,\n    memberName\n  }) => `The enum member initializer for \\`${memberName}\\` needs to be a literal (either a boolean, number, or string) in enum \\`${enumName}\\`.`),\n  EnumInvalidMemberName: _(({\n    enumName,\n    memberName,\n    suggestion\n  }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \\`${memberName}\\`, consider using \\`${suggestion}\\`, in enum \\`${enumName}\\`.`),\n  EnumNumberMemberNotInitialized: _(({\n    enumName,\n    memberName\n  }) => `Number enum members need to be initialized, e.g. \\`${memberName} = 1\\` in enum \\`${enumName}\\`.`),\n  EnumStringMemberInconsistentlyInitailized: _(({\n    enumName\n  }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \\`${enumName}\\`.`),\n  GetterMayNotHaveThisParam: _(\"A getter cannot have a `this` parameter.\"),\n  ImportTypeShorthandOnlyInPureImport: _(\"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.\"),\n  InexactInsideExact: _(\"Explicit inexact syntax cannot appear inside an explicit exact object type.\"),\n  InexactInsideNonObject: _(\"Explicit inexact syntax cannot appear in class or interface definitions.\"),\n  InexactVariance: _(\"Explicit inexact syntax cannot have variance.\"),\n  InvalidNonTypeImportInDeclareModule: _(\"Imports within a `declare module` body must always be `import type` or `import typeof`.\"),\n  MissingTypeParamDefault: _(\"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.\"),\n  NestedDeclareModule: _(\"`declare module` cannot be used inside another `declare module`.\"),\n  NestedFlowComment: _(\"Cannot have a flow comment inside another flow comment.\"),\n  PatternIsOptional: _(\"A binding pattern parameter cannot be optional in an implementation signature.\", {\n    reasonCode: \"OptionalBindingPattern\"\n  }),\n  SetterMayNotHaveThisParam: _(\"A setter cannot have a `this` parameter.\"),\n  SpreadVariance: _(\"Spread properties cannot have variance.\"),\n  ThisParamAnnotationRequired: _(\"A type annotation is required for the `this` parameter.\"),\n  ThisParamBannedInConstructor: _(\"Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.\"),\n  ThisParamMayNotBeOptional: _(\"The `this` parameter cannot be optional.\"),\n  ThisParamMustBeFirst: _(\"The `this` parameter must be the first function parameter.\"),\n  ThisParamNoDefault: _(\"The `this` parameter may not have a default value.\"),\n  TypeBeforeInitializer: _(\"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\"),\n  TypeCastInPattern: _(\"The type cast expression is expected to be wrapped with parenthesis.\"),\n  UnexpectedExplicitInexactInObject: _(\"Explicit inexact syntax must appear at the end of an inexact object.\"),\n  UnexpectedReservedType: _(({\n    reservedType\n  }) => `Unexpected reserved type ${reservedType}.`),\n  UnexpectedReservedUnderscore: _(\"`_` is only allowed as a type argument to call or new.\"),\n  UnexpectedSpaceBetweenModuloChecks: _(\"Spaces between `%` and `checks` are not allowed here.\"),\n  UnexpectedSpreadType: _(\"Spread operator cannot appear in class or interface definitions.\"),\n  UnexpectedSubtractionOperand: _('Unexpected token, expected \"number\" or \"bigint\".'),\n  UnexpectedTokenAfterTypeParameter: _(\"Expected an arrow function after this type parameter declaration.\"),\n  UnexpectedTypeParameterBeforeAsyncArrowFunction: _(\"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.\"),\n  UnsupportedDeclareExportKind: _(({\n    unsupportedExportKind,\n    suggestion\n  }) => `\\`declare export ${unsupportedExportKind}\\` is not supported. Use \\`${suggestion}\\` instead.`),\n  UnsupportedStatementInDeclareModule: _(\"Only declares and type imports are allowed inside declare module.\"),\n  UnterminatedFlowComment: _(\"Unterminated flow-comment.\")\n}));\n\nfunction isEsModuleType(bodyElement) {\n  return bodyElement.type === \"DeclareExportAllDeclaration\" || bodyElement.type === \"DeclareExportDeclaration\" && (!bodyElement.declaration || bodyElement.declaration.type !== \"TypeAlias\" && bodyElement.declaration.type !== \"InterfaceDeclaration\");\n}\n\nfunction hasTypeImportKind(node) {\n  return node.importKind === \"type\" || node.importKind === \"typeof\";\n}\n\nfunction isMaybeDefaultImport(type) {\n  return tokenIsKeywordOrIdentifier(type) && type !== 97;\n}\n\nconst exportSuggestions = {\n  const: \"declare export var\",\n  let: \"declare export var\",\n  type: \"export type\",\n  interface: \"export interface\"\n};\n\nfunction partition(list, test) {\n  const list1 = [];\n  const list2 = [];\n\n  for (let i = 0; i < list.length; i++) {\n    (test(list[i], i, list) ? list1 : list2).push(list[i]);\n  }\n\n  return [list1, list2];\n}\n\nconst FLOW_PRAGMA_REGEX = /\\*?\\s*@((?:no)?flow)\\b/;\nvar flow = (superClass => class extends superClass {\n  constructor(...args) {\n    super(...args);\n    this.flowPragma = undefined;\n  }\n\n  getScopeHandler() {\n    return FlowScopeHandler;\n  }\n\n  shouldParseTypes() {\n    return this.getPluginOption(\"flow\", \"all\") || this.flowPragma === \"flow\";\n  }\n\n  shouldParseEnums() {\n    return !!this.getPluginOption(\"flow\", \"enums\");\n  }\n\n  finishToken(type, val) {\n    if (type !== 129 && type !== 13 && type !== 28) {\n      if (this.flowPragma === undefined) {\n        this.flowPragma = null;\n      }\n    }\n\n    return super.finishToken(type, val);\n  }\n\n  addComment(comment) {\n    if (this.flowPragma === undefined) {\n      const matches = FLOW_PRAGMA_REGEX.exec(comment.value);\n\n      if (!matches) ; else if (matches[1] === \"flow\") {\n        this.flowPragma = \"flow\";\n      } else if (matches[1] === \"noflow\") {\n        this.flowPragma = \"noflow\";\n      } else {\n        throw new Error(\"Unexpected flow pragma\");\n      }\n    }\n\n    return super.addComment(comment);\n  }\n\n  flowParseTypeInitialiser(tok) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    this.expect(tok || 14);\n    const type = this.flowParseType();\n    this.state.inType = oldInType;\n    return type;\n  }\n\n  flowParsePredicate() {\n    const node = this.startNode();\n    const moduloLoc = this.state.startLoc;\n    this.next();\n    this.expectContextual(107);\n\n    if (this.state.lastTokStart > moduloLoc.index + 1) {\n      this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, {\n        at: moduloLoc\n      });\n    }\n\n    if (this.eat(10)) {\n      node.value = this.parseExpression();\n      this.expect(11);\n      return this.finishNode(node, \"DeclaredPredicate\");\n    } else {\n      return this.finishNode(node, \"InferredPredicate\");\n    }\n  }\n\n  flowParseTypeAndPredicateInitialiser() {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    this.expect(14);\n    let type = null;\n    let predicate = null;\n\n    if (this.match(54)) {\n      this.state.inType = oldInType;\n      predicate = this.flowParsePredicate();\n    } else {\n      type = this.flowParseType();\n      this.state.inType = oldInType;\n\n      if (this.match(54)) {\n        predicate = this.flowParsePredicate();\n      }\n    }\n\n    return [type, predicate];\n  }\n\n  flowParseDeclareClass(node) {\n    this.next();\n    this.flowParseInterfaceish(node, true);\n    return this.finishNode(node, \"DeclareClass\");\n  }\n\n  flowParseDeclareFunction(node) {\n    this.next();\n    const id = node.id = this.parseIdentifier();\n    const typeNode = this.startNode();\n    const typeContainer = this.startNode();\n\n    if (this.match(47)) {\n      typeNode.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      typeNode.typeParameters = null;\n    }\n\n    this.expect(10);\n    const tmp = this.flowParseFunctionTypeParams();\n    typeNode.params = tmp.params;\n    typeNode.rest = tmp.rest;\n    typeNode.this = tmp._this;\n    this.expect(11);\n    [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n    typeContainer.typeAnnotation = this.finishNode(typeNode, \"FunctionTypeAnnotation\");\n    id.typeAnnotation = this.finishNode(typeContainer, \"TypeAnnotation\");\n    this.resetEndLocation(id);\n    this.semicolon();\n    this.scope.declareName(node.id.name, BIND_FLOW_DECLARE_FN, node.id.loc.start);\n    return this.finishNode(node, \"DeclareFunction\");\n  }\n\n  flowParseDeclare(node, insideModule) {\n    if (this.match(80)) {\n      return this.flowParseDeclareClass(node);\n    } else if (this.match(68)) {\n      return this.flowParseDeclareFunction(node);\n    } else if (this.match(74)) {\n      return this.flowParseDeclareVariable(node);\n    } else if (this.eatContextual(123)) {\n      if (this.match(16)) {\n        return this.flowParseDeclareModuleExports(node);\n      } else {\n        if (insideModule) {\n          this.raise(FlowErrors.NestedDeclareModule, {\n            at: this.state.lastTokStartLoc\n          });\n        }\n\n        return this.flowParseDeclareModule(node);\n      }\n    } else if (this.isContextual(126)) {\n      return this.flowParseDeclareTypeAlias(node);\n    } else if (this.isContextual(127)) {\n      return this.flowParseDeclareOpaqueType(node);\n    } else if (this.isContextual(125)) {\n      return this.flowParseDeclareInterface(node);\n    } else if (this.match(82)) {\n      return this.flowParseDeclareExportDeclaration(node, insideModule);\n    } else {\n      throw this.unexpected();\n    }\n  }\n\n  flowParseDeclareVariable(node) {\n    this.next();\n    node.id = this.flowParseTypeAnnotatableIdentifier(true);\n    this.scope.declareName(node.id.name, BIND_VAR, node.id.loc.start);\n    this.semicolon();\n    return this.finishNode(node, \"DeclareVariable\");\n  }\n\n  flowParseDeclareModule(node) {\n    this.scope.enter(SCOPE_OTHER);\n\n    if (this.match(129)) {\n      node.id = this.parseExprAtom();\n    } else {\n      node.id = this.parseIdentifier();\n    }\n\n    const bodyNode = node.body = this.startNode();\n    const body = bodyNode.body = [];\n    this.expect(5);\n\n    while (!this.match(8)) {\n      let bodyNode = this.startNode();\n\n      if (this.match(83)) {\n        this.next();\n\n        if (!this.isContextual(126) && !this.match(87)) {\n          this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, {\n            at: this.state.lastTokStartLoc\n          });\n        }\n\n        this.parseImport(bodyNode);\n      } else {\n        this.expectContextual(121, FlowErrors.UnsupportedStatementInDeclareModule);\n        bodyNode = this.flowParseDeclare(bodyNode, true);\n      }\n\n      body.push(bodyNode);\n    }\n\n    this.scope.exit();\n    this.expect(8);\n    this.finishNode(bodyNode, \"BlockStatement\");\n    let kind = null;\n    let hasModuleExport = false;\n    body.forEach(bodyElement => {\n      if (isEsModuleType(bodyElement)) {\n        if (kind === \"CommonJS\") {\n          this.raise(FlowErrors.AmbiguousDeclareModuleKind, {\n            at: bodyElement\n          });\n        }\n\n        kind = \"ES\";\n      } else if (bodyElement.type === \"DeclareModuleExports\") {\n        if (hasModuleExport) {\n          this.raise(FlowErrors.DuplicateDeclareModuleExports, {\n            at: bodyElement\n          });\n        }\n\n        if (kind === \"ES\") {\n          this.raise(FlowErrors.AmbiguousDeclareModuleKind, {\n            at: bodyElement\n          });\n        }\n\n        kind = \"CommonJS\";\n        hasModuleExport = true;\n      }\n    });\n    node.kind = kind || \"CommonJS\";\n    return this.finishNode(node, \"DeclareModule\");\n  }\n\n  flowParseDeclareExportDeclaration(node, insideModule) {\n    this.expect(82);\n\n    if (this.eat(65)) {\n      if (this.match(68) || this.match(80)) {\n        node.declaration = this.flowParseDeclare(this.startNode());\n      } else {\n        node.declaration = this.flowParseType();\n        this.semicolon();\n      }\n\n      node.default = true;\n      return this.finishNode(node, \"DeclareExportDeclaration\");\n    } else {\n      if (this.match(75) || this.isLet() || (this.isContextual(126) || this.isContextual(125)) && !insideModule) {\n        const label = this.state.value;\n        throw this.raise(FlowErrors.UnsupportedDeclareExportKind, {\n          at: this.state.startLoc,\n          unsupportedExportKind: label,\n          suggestion: exportSuggestions[label]\n        });\n      }\n\n      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(127)) {\n        node.declaration = this.flowParseDeclare(this.startNode());\n        node.default = false;\n        return this.finishNode(node, \"DeclareExportDeclaration\");\n      } else if (this.match(55) || this.match(5) || this.isContextual(125) || this.isContextual(126) || this.isContextual(127)) {\n        node = this.parseExport(node);\n\n        if (node.type === \"ExportNamedDeclaration\") {\n          node.type = \"ExportDeclaration\";\n          node.default = false;\n          delete node.exportKind;\n        }\n\n        node.type = \"Declare\" + node.type;\n        return node;\n      }\n    }\n\n    throw this.unexpected();\n  }\n\n  flowParseDeclareModuleExports(node) {\n    this.next();\n    this.expectContextual(108);\n    node.typeAnnotation = this.flowParseTypeAnnotation();\n    this.semicolon();\n    return this.finishNode(node, \"DeclareModuleExports\");\n  }\n\n  flowParseDeclareTypeAlias(node) {\n    this.next();\n    this.flowParseTypeAlias(node);\n    node.type = \"DeclareTypeAlias\";\n    return node;\n  }\n\n  flowParseDeclareOpaqueType(node) {\n    this.next();\n    this.flowParseOpaqueType(node, true);\n    node.type = \"DeclareOpaqueType\";\n    return node;\n  }\n\n  flowParseDeclareInterface(node) {\n    this.next();\n    this.flowParseInterfaceish(node);\n    return this.finishNode(node, \"DeclareInterface\");\n  }\n\n  flowParseInterfaceish(node, isClass = false) {\n    node.id = this.flowParseRestrictedIdentifier(!isClass, true);\n    this.scope.declareName(node.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node.id.loc.start);\n\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n\n    node.extends = [];\n    node.implements = [];\n    node.mixins = [];\n\n    if (this.eat(81)) {\n      do {\n        node.extends.push(this.flowParseInterfaceExtends());\n      } while (!isClass && this.eat(12));\n    }\n\n    if (this.isContextual(114)) {\n      this.next();\n\n      do {\n        node.mixins.push(this.flowParseInterfaceExtends());\n      } while (this.eat(12));\n    }\n\n    if (this.isContextual(110)) {\n      this.next();\n\n      do {\n        node.implements.push(this.flowParseInterfaceExtends());\n      } while (this.eat(12));\n    }\n\n    node.body = this.flowParseObjectType({\n      allowStatic: isClass,\n      allowExact: false,\n      allowSpread: false,\n      allowProto: isClass,\n      allowInexact: false\n    });\n  }\n\n  flowParseInterfaceExtends() {\n    const node = this.startNode();\n    node.id = this.flowParseQualifiedTypeIdentifier();\n\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\n    } else {\n      node.typeParameters = null;\n    }\n\n    return this.finishNode(node, \"InterfaceExtends\");\n  }\n\n  flowParseInterface(node) {\n    this.flowParseInterfaceish(node);\n    return this.finishNode(node, \"InterfaceDeclaration\");\n  }\n\n  checkNotUnderscore(word) {\n    if (word === \"_\") {\n      this.raise(FlowErrors.UnexpectedReservedUnderscore, {\n        at: this.state.startLoc\n      });\n    }\n  }\n\n  checkReservedType(word, startLoc, declaration) {\n    if (!reservedTypes.has(word)) return;\n    this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, {\n      at: startLoc,\n      reservedType: word\n    });\n  }\n\n  flowParseRestrictedIdentifier(liberal, declaration) {\n    this.checkReservedType(this.state.value, this.state.startLoc, declaration);\n    return this.parseIdentifier(liberal);\n  }\n\n  flowParseTypeAlias(node) {\n    node.id = this.flowParseRestrictedIdentifier(false, true);\n    this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.loc.start);\n\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n\n    node.right = this.flowParseTypeInitialiser(29);\n    this.semicolon();\n    return this.finishNode(node, \"TypeAlias\");\n  }\n\n  flowParseOpaqueType(node, declare) {\n    this.expectContextual(126);\n    node.id = this.flowParseRestrictedIdentifier(true, true);\n    this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.loc.start);\n\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n\n    node.supertype = null;\n\n    if (this.match(14)) {\n      node.supertype = this.flowParseTypeInitialiser(14);\n    }\n\n    node.impltype = null;\n\n    if (!declare) {\n      node.impltype = this.flowParseTypeInitialiser(29);\n    }\n\n    this.semicolon();\n    return this.finishNode(node, \"OpaqueType\");\n  }\n\n  flowParseTypeParameter(requireDefault = false) {\n    const nodeStartLoc = this.state.startLoc;\n    const node = this.startNode();\n    const variance = this.flowParseVariance();\n    const ident = this.flowParseTypeAnnotatableIdentifier();\n    node.name = ident.name;\n    node.variance = variance;\n    node.bound = ident.typeAnnotation;\n\n    if (this.match(29)) {\n      this.eat(29);\n      node.default = this.flowParseType();\n    } else {\n      if (requireDefault) {\n        this.raise(FlowErrors.MissingTypeParamDefault, {\n          at: nodeStartLoc\n        });\n      }\n    }\n\n    return this.finishNode(node, \"TypeParameter\");\n  }\n\n  flowParseTypeParameterDeclaration() {\n    const oldInType = this.state.inType;\n    const node = this.startNode();\n    node.params = [];\n    this.state.inType = true;\n\n    if (this.match(47) || this.match(138)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n\n    let defaultRequired = false;\n\n    do {\n      const typeParameter = this.flowParseTypeParameter(defaultRequired);\n      node.params.push(typeParameter);\n\n      if (typeParameter.default) {\n        defaultRequired = true;\n      }\n\n      if (!this.match(48)) {\n        this.expect(12);\n      }\n    } while (!this.match(48));\n\n    this.expect(48);\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterDeclaration\");\n  }\n\n  flowParseTypeParameterInstantiation() {\n    const node = this.startNode();\n    const oldInType = this.state.inType;\n    node.params = [];\n    this.state.inType = true;\n    this.expect(47);\n    const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n    this.state.noAnonFunctionType = false;\n\n    while (!this.match(48)) {\n      node.params.push(this.flowParseType());\n\n      if (!this.match(48)) {\n        this.expect(12);\n      }\n    }\n\n    this.state.noAnonFunctionType = oldNoAnonFunctionType;\n    this.expect(48);\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterInstantiation\");\n  }\n\n  flowParseTypeParameterInstantiationCallOrNew() {\n    const node = this.startNode();\n    const oldInType = this.state.inType;\n    node.params = [];\n    this.state.inType = true;\n    this.expect(47);\n\n    while (!this.match(48)) {\n      node.params.push(this.flowParseTypeOrImplicitInstantiation());\n\n      if (!this.match(48)) {\n        this.expect(12);\n      }\n    }\n\n    this.expect(48);\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterInstantiation\");\n  }\n\n  flowParseInterfaceType() {\n    const node = this.startNode();\n    this.expectContextual(125);\n    node.extends = [];\n\n    if (this.eat(81)) {\n      do {\n        node.extends.push(this.flowParseInterfaceExtends());\n      } while (this.eat(12));\n    }\n\n    node.body = this.flowParseObjectType({\n      allowStatic: false,\n      allowExact: false,\n      allowSpread: false,\n      allowProto: false,\n      allowInexact: false\n    });\n    return this.finishNode(node, \"InterfaceTypeAnnotation\");\n  }\n\n  flowParseObjectPropertyKey() {\n    return this.match(130) || this.match(129) ? this.parseExprAtom() : this.parseIdentifier(true);\n  }\n\n  flowParseObjectTypeIndexer(node, isStatic, variance) {\n    node.static = isStatic;\n\n    if (this.lookahead().type === 14) {\n      node.id = this.flowParseObjectPropertyKey();\n      node.key = this.flowParseTypeInitialiser();\n    } else {\n      node.id = null;\n      node.key = this.flowParseType();\n    }\n\n    this.expect(3);\n    node.value = this.flowParseTypeInitialiser();\n    node.variance = variance;\n    return this.finishNode(node, \"ObjectTypeIndexer\");\n  }\n\n  flowParseObjectTypeInternalSlot(node, isStatic) {\n    node.static = isStatic;\n    node.id = this.flowParseObjectPropertyKey();\n    this.expect(3);\n    this.expect(3);\n\n    if (this.match(47) || this.match(10)) {\n      node.method = true;\n      node.optional = false;\n      node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));\n    } else {\n      node.method = false;\n\n      if (this.eat(17)) {\n        node.optional = true;\n      }\n\n      node.value = this.flowParseTypeInitialiser();\n    }\n\n    return this.finishNode(node, \"ObjectTypeInternalSlot\");\n  }\n\n  flowParseObjectTypeMethodish(node) {\n    node.params = [];\n    node.rest = null;\n    node.typeParameters = null;\n    node.this = null;\n\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n\n    this.expect(10);\n\n    if (this.match(78)) {\n      node.this = this.flowParseFunctionTypeParam(true);\n      node.this.name = null;\n\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n\n    while (!this.match(11) && !this.match(21)) {\n      node.params.push(this.flowParseFunctionTypeParam(false));\n\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n\n    if (this.eat(21)) {\n      node.rest = this.flowParseFunctionTypeParam(false);\n    }\n\n    this.expect(11);\n    node.returnType = this.flowParseTypeInitialiser();\n    return this.finishNode(node, \"FunctionTypeAnnotation\");\n  }\n\n  flowParseObjectTypeCallProperty(node, isStatic) {\n    const valueNode = this.startNode();\n    node.static = isStatic;\n    node.value = this.flowParseObjectTypeMethodish(valueNode);\n    return this.finishNode(node, \"ObjectTypeCallProperty\");\n  }\n\n  flowParseObjectType({\n    allowStatic,\n    allowExact,\n    allowSpread,\n    allowProto,\n    allowInexact\n  }) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    const nodeStart = this.startNode();\n    nodeStart.callProperties = [];\n    nodeStart.properties = [];\n    nodeStart.indexers = [];\n    nodeStart.internalSlots = [];\n    let endDelim;\n    let exact;\n    let inexact = false;\n\n    if (allowExact && this.match(6)) {\n      this.expect(6);\n      endDelim = 9;\n      exact = true;\n    } else {\n      this.expect(5);\n      endDelim = 8;\n      exact = false;\n    }\n\n    nodeStart.exact = exact;\n\n    while (!this.match(endDelim)) {\n      let isStatic = false;\n      let protoStartLoc = null;\n      let inexactStartLoc = null;\n      const node = this.startNode();\n\n      if (allowProto && this.isContextual(115)) {\n        const lookahead = this.lookahead();\n\n        if (lookahead.type !== 14 && lookahead.type !== 17) {\n          this.next();\n          protoStartLoc = this.state.startLoc;\n          allowStatic = false;\n        }\n      }\n\n      if (allowStatic && this.isContextual(104)) {\n        const lookahead = this.lookahead();\n\n        if (lookahead.type !== 14 && lookahead.type !== 17) {\n          this.next();\n          isStatic = true;\n        }\n      }\n\n      const variance = this.flowParseVariance();\n\n      if (this.eat(0)) {\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n\n        if (this.eat(0)) {\n          if (variance) {\n            this.unexpected(variance.loc.start);\n          }\n\n          nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));\n        } else {\n          nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));\n        }\n      } else if (this.match(10) || this.match(47)) {\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n\n        if (variance) {\n          this.unexpected(variance.loc.start);\n        }\n\n        nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));\n      } else {\n        let kind = \"init\";\n\n        if (this.isContextual(98) || this.isContextual(103)) {\n          const lookahead = this.lookahead();\n\n          if (tokenIsLiteralPropertyName(lookahead.type)) {\n            kind = this.state.value;\n            this.next();\n          }\n        }\n\n        const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);\n\n        if (propOrInexact === null) {\n          inexact = true;\n          inexactStartLoc = this.state.lastTokStartLoc;\n        } else {\n          nodeStart.properties.push(propOrInexact);\n        }\n      }\n\n      this.flowObjectTypeSemicolon();\n\n      if (inexactStartLoc && !this.match(8) && !this.match(9)) {\n        this.raise(FlowErrors.UnexpectedExplicitInexactInObject, {\n          at: inexactStartLoc\n        });\n      }\n    }\n\n    this.expect(endDelim);\n\n    if (allowSpread) {\n      nodeStart.inexact = inexact;\n    }\n\n    const out = this.finishNode(nodeStart, \"ObjectTypeAnnotation\");\n    this.state.inType = oldInType;\n    return out;\n  }\n\n  flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {\n    if (this.eat(21)) {\n      const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);\n\n      if (isInexactToken) {\n        if (!allowSpread) {\n          this.raise(FlowErrors.InexactInsideNonObject, {\n            at: this.state.lastTokStartLoc\n          });\n        } else if (!allowInexact) {\n          this.raise(FlowErrors.InexactInsideExact, {\n            at: this.state.lastTokStartLoc\n          });\n        }\n\n        if (variance) {\n          this.raise(FlowErrors.InexactVariance, {\n            at: variance\n          });\n        }\n\n        return null;\n      }\n\n      if (!allowSpread) {\n        this.raise(FlowErrors.UnexpectedSpreadType, {\n          at: this.state.lastTokStartLoc\n        });\n      }\n\n      if (protoStartLoc != null) {\n        this.unexpected(protoStartLoc);\n      }\n\n      if (variance) {\n        this.raise(FlowErrors.SpreadVariance, {\n          at: variance\n        });\n      }\n\n      node.argument = this.flowParseType();\n      return this.finishNode(node, \"ObjectTypeSpreadProperty\");\n    } else {\n      node.key = this.flowParseObjectPropertyKey();\n      node.static = isStatic;\n      node.proto = protoStartLoc != null;\n      node.kind = kind;\n      let optional = false;\n\n      if (this.match(47) || this.match(10)) {\n        node.method = true;\n\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n\n        if (variance) {\n          this.unexpected(variance.loc.start);\n        }\n\n        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));\n\n        if (kind === \"get\" || kind === \"set\") {\n          this.flowCheckGetterSetterParams(node);\n        }\n\n        if (!allowSpread && node.key.name === \"constructor\" && node.value.this) {\n          this.raise(FlowErrors.ThisParamBannedInConstructor, {\n            at: node.value.this\n          });\n        }\n      } else {\n        if (kind !== \"init\") this.unexpected();\n        node.method = false;\n\n        if (this.eat(17)) {\n          optional = true;\n        }\n\n        node.value = this.flowParseTypeInitialiser();\n        node.variance = variance;\n      }\n\n      node.optional = optional;\n      return this.finishNode(node, \"ObjectTypeProperty\");\n    }\n  }\n\n  flowCheckGetterSetterParams(property) {\n    const paramCount = property.kind === \"get\" ? 0 : 1;\n    const length = property.value.params.length + (property.value.rest ? 1 : 0);\n\n    if (property.value.this) {\n      this.raise(property.kind === \"get\" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, {\n        at: property.value.this\n      });\n    }\n\n    if (length !== paramCount) {\n      this.raise(property.kind === \"get\" ? Errors.BadGetterArity : Errors.BadSetterArity, {\n        at: property\n      });\n    }\n\n    if (property.kind === \"set\" && property.value.rest) {\n      this.raise(Errors.BadSetterRestParameter, {\n        at: property\n      });\n    }\n  }\n\n  flowObjectTypeSemicolon() {\n    if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {\n      this.unexpected();\n    }\n  }\n\n  flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {\n    startPos = startPos || this.state.start;\n    startLoc = startLoc || this.state.startLoc;\n    let node = id || this.flowParseRestrictedIdentifier(true);\n\n    while (this.eat(16)) {\n      const node2 = this.startNodeAt(startPos, startLoc);\n      node2.qualification = node;\n      node2.id = this.flowParseRestrictedIdentifier(true);\n      node = this.finishNode(node2, \"QualifiedTypeIdentifier\");\n    }\n\n    return node;\n  }\n\n  flowParseGenericType(startPos, startLoc, id) {\n    const node = this.startNodeAt(startPos, startLoc);\n    node.typeParameters = null;\n    node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);\n\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\n    }\n\n    return this.finishNode(node, \"GenericTypeAnnotation\");\n  }\n\n  flowParseTypeofType() {\n    const node = this.startNode();\n    this.expect(87);\n    node.argument = this.flowParsePrimaryType();\n    return this.finishNode(node, \"TypeofTypeAnnotation\");\n  }\n\n  flowParseTupleType() {\n    const node = this.startNode();\n    node.types = [];\n    this.expect(0);\n\n    while (this.state.pos < this.length && !this.match(3)) {\n      node.types.push(this.flowParseType());\n      if (this.match(3)) break;\n      this.expect(12);\n    }\n\n    this.expect(3);\n    return this.finishNode(node, \"TupleTypeAnnotation\");\n  }\n\n  flowParseFunctionTypeParam(first) {\n    let name = null;\n    let optional = false;\n    let typeAnnotation = null;\n    const node = this.startNode();\n    const lh = this.lookahead();\n    const isThis = this.state.type === 78;\n\n    if (lh.type === 14 || lh.type === 17) {\n      if (isThis && !first) {\n        this.raise(FlowErrors.ThisParamMustBeFirst, {\n          at: node\n        });\n      }\n\n      name = this.parseIdentifier(isThis);\n\n      if (this.eat(17)) {\n        optional = true;\n\n        if (isThis) {\n          this.raise(FlowErrors.ThisParamMayNotBeOptional, {\n            at: node\n          });\n        }\n      }\n\n      typeAnnotation = this.flowParseTypeInitialiser();\n    } else {\n      typeAnnotation = this.flowParseType();\n    }\n\n    node.name = name;\n    node.optional = optional;\n    node.typeAnnotation = typeAnnotation;\n    return this.finishNode(node, \"FunctionTypeParam\");\n  }\n\n  reinterpretTypeAsFunctionTypeParam(type) {\n    const node = this.startNodeAt(type.start, type.loc.start);\n    node.name = null;\n    node.optional = false;\n    node.typeAnnotation = type;\n    return this.finishNode(node, \"FunctionTypeParam\");\n  }\n\n  flowParseFunctionTypeParams(params = []) {\n    let rest = null;\n    let _this = null;\n\n    if (this.match(78)) {\n      _this = this.flowParseFunctionTypeParam(true);\n      _this.name = null;\n\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n\n    while (!this.match(11) && !this.match(21)) {\n      params.push(this.flowParseFunctionTypeParam(false));\n\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n\n    if (this.eat(21)) {\n      rest = this.flowParseFunctionTypeParam(false);\n    }\n\n    return {\n      params,\n      rest,\n      _this\n    };\n  }\n\n  flowIdentToTypeAnnotation(startPos, startLoc, node, id) {\n    switch (id.name) {\n      case \"any\":\n        return this.finishNode(node, \"AnyTypeAnnotation\");\n\n      case \"bool\":\n      case \"boolean\":\n        return this.finishNode(node, \"BooleanTypeAnnotation\");\n\n      case \"mixed\":\n        return this.finishNode(node, \"MixedTypeAnnotation\");\n\n      case \"empty\":\n        return this.finishNode(node, \"EmptyTypeAnnotation\");\n\n      case \"number\":\n        return this.finishNode(node, \"NumberTypeAnnotation\");\n\n      case \"string\":\n        return this.finishNode(node, \"StringTypeAnnotation\");\n\n      case \"symbol\":\n        return this.finishNode(node, \"SymbolTypeAnnotation\");\n\n      default:\n        this.checkNotUnderscore(id.name);\n        return this.flowParseGenericType(startPos, startLoc, id);\n    }\n  }\n\n  flowParsePrimaryType() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const node = this.startNode();\n    let tmp;\n    let type;\n    let isGroupedType = false;\n    const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n\n    switch (this.state.type) {\n      case 5:\n        return this.flowParseObjectType({\n          allowStatic: false,\n          allowExact: false,\n          allowSpread: true,\n          allowProto: false,\n          allowInexact: true\n        });\n\n      case 6:\n        return this.flowParseObjectType({\n          allowStatic: false,\n          allowExact: true,\n          allowSpread: true,\n          allowProto: false,\n          allowInexact: false\n        });\n\n      case 0:\n        this.state.noAnonFunctionType = false;\n        type = this.flowParseTupleType();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        return type;\n\n      case 47:\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n        this.expect(10);\n        tmp = this.flowParseFunctionTypeParams();\n        node.params = tmp.params;\n        node.rest = tmp.rest;\n        node.this = tmp._this;\n        this.expect(11);\n        this.expect(19);\n        node.returnType = this.flowParseType();\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\n\n      case 10:\n        this.next();\n\n        if (!this.match(11) && !this.match(21)) {\n          if (tokenIsIdentifier(this.state.type) || this.match(78)) {\n            const token = this.lookahead().type;\n            isGroupedType = token !== 17 && token !== 14;\n          } else {\n            isGroupedType = true;\n          }\n        }\n\n        if (isGroupedType) {\n          this.state.noAnonFunctionType = false;\n          type = this.flowParseType();\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n\n          if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {\n            this.expect(11);\n            return type;\n          } else {\n            this.eat(12);\n          }\n        }\n\n        if (type) {\n          tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);\n        } else {\n          tmp = this.flowParseFunctionTypeParams();\n        }\n\n        node.params = tmp.params;\n        node.rest = tmp.rest;\n        node.this = tmp._this;\n        this.expect(11);\n        this.expect(19);\n        node.returnType = this.flowParseType();\n        node.typeParameters = null;\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\n\n      case 129:\n        return this.parseLiteral(this.state.value, \"StringLiteralTypeAnnotation\");\n\n      case 85:\n      case 86:\n        node.value = this.match(85);\n        this.next();\n        return this.finishNode(node, \"BooleanLiteralTypeAnnotation\");\n\n      case 53:\n        if (this.state.value === \"-\") {\n          this.next();\n\n          if (this.match(130)) {\n            return this.parseLiteralAtNode(-this.state.value, \"NumberLiteralTypeAnnotation\", node);\n          }\n\n          if (this.match(131)) {\n            return this.parseLiteralAtNode(-this.state.value, \"BigIntLiteralTypeAnnotation\", node);\n          }\n\n          throw this.raise(FlowErrors.UnexpectedSubtractionOperand, {\n            at: this.state.startLoc\n          });\n        }\n\n        throw this.unexpected();\n\n      case 130:\n        return this.parseLiteral(this.state.value, \"NumberLiteralTypeAnnotation\");\n\n      case 131:\n        return this.parseLiteral(this.state.value, \"BigIntLiteralTypeAnnotation\");\n\n      case 88:\n        this.next();\n        return this.finishNode(node, \"VoidTypeAnnotation\");\n\n      case 84:\n        this.next();\n        return this.finishNode(node, \"NullLiteralTypeAnnotation\");\n\n      case 78:\n        this.next();\n        return this.finishNode(node, \"ThisTypeAnnotation\");\n\n      case 55:\n        this.next();\n        return this.finishNode(node, \"ExistsTypeAnnotation\");\n\n      case 87:\n        return this.flowParseTypeofType();\n\n      default:\n        if (tokenIsKeyword(this.state.type)) {\n          const label = tokenLabelName(this.state.type);\n          this.next();\n          return super.createIdentifier(node, label);\n        } else if (tokenIsIdentifier(this.state.type)) {\n          if (this.isContextual(125)) {\n            return this.flowParseInterfaceType();\n          }\n\n          return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());\n        }\n\n    }\n\n    throw this.unexpected();\n  }\n\n  flowParsePostfixType() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let type = this.flowParsePrimaryType();\n    let seenOptionalIndexedAccess = false;\n\n    while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startPos, startLoc);\n      const optional = this.eat(18);\n      seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;\n      this.expect(0);\n\n      if (!optional && this.match(3)) {\n        node.elementType = type;\n        this.next();\n        type = this.finishNode(node, \"ArrayTypeAnnotation\");\n      } else {\n        node.objectType = type;\n        node.indexType = this.flowParseType();\n        this.expect(3);\n\n        if (seenOptionalIndexedAccess) {\n          node.optional = optional;\n          type = this.finishNode(node, \"OptionalIndexedAccessType\");\n        } else {\n          type = this.finishNode(node, \"IndexedAccessType\");\n        }\n      }\n    }\n\n    return type;\n  }\n\n  flowParsePrefixType() {\n    const node = this.startNode();\n\n    if (this.eat(17)) {\n      node.typeAnnotation = this.flowParsePrefixType();\n      return this.finishNode(node, \"NullableTypeAnnotation\");\n    } else {\n      return this.flowParsePostfixType();\n    }\n  }\n\n  flowParseAnonFunctionWithoutParens() {\n    const param = this.flowParsePrefixType();\n\n    if (!this.state.noAnonFunctionType && this.eat(19)) {\n      const node = this.startNodeAt(param.start, param.loc.start);\n      node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];\n      node.rest = null;\n      node.this = null;\n      node.returnType = this.flowParseType();\n      node.typeParameters = null;\n      return this.finishNode(node, \"FunctionTypeAnnotation\");\n    }\n\n    return param;\n  }\n\n  flowParseIntersectionType() {\n    const node = this.startNode();\n    this.eat(45);\n    const type = this.flowParseAnonFunctionWithoutParens();\n    node.types = [type];\n\n    while (this.eat(45)) {\n      node.types.push(this.flowParseAnonFunctionWithoutParens());\n    }\n\n    return node.types.length === 1 ? type : this.finishNode(node, \"IntersectionTypeAnnotation\");\n  }\n\n  flowParseUnionType() {\n    const node = this.startNode();\n    this.eat(43);\n    const type = this.flowParseIntersectionType();\n    node.types = [type];\n\n    while (this.eat(43)) {\n      node.types.push(this.flowParseIntersectionType());\n    }\n\n    return node.types.length === 1 ? type : this.finishNode(node, \"UnionTypeAnnotation\");\n  }\n\n  flowParseType() {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    const type = this.flowParseUnionType();\n    this.state.inType = oldInType;\n    return type;\n  }\n\n  flowParseTypeOrImplicitInstantiation() {\n    if (this.state.type === 128 && this.state.value === \"_\") {\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      const node = this.parseIdentifier();\n      return this.flowParseGenericType(startPos, startLoc, node);\n    } else {\n      return this.flowParseType();\n    }\n  }\n\n  flowParseTypeAnnotation() {\n    const node = this.startNode();\n    node.typeAnnotation = this.flowParseTypeInitialiser();\n    return this.finishNode(node, \"TypeAnnotation\");\n  }\n\n  flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {\n    const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();\n\n    if (this.match(14)) {\n      ident.typeAnnotation = this.flowParseTypeAnnotation();\n      this.resetEndLocation(ident);\n    }\n\n    return ident;\n  }\n\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n\n  flowParseVariance() {\n    let variance = null;\n\n    if (this.match(53)) {\n      variance = this.startNode();\n\n      if (this.state.value === \"+\") {\n        variance.kind = \"plus\";\n      } else {\n        variance.kind = \"minus\";\n      }\n\n      this.next();\n      this.finishNode(variance, \"Variance\");\n    }\n\n    return variance;\n  }\n\n  parseFunctionBody(node, allowExpressionBody, isMethod = false) {\n    if (allowExpressionBody) {\n      return this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));\n    }\n\n    return super.parseFunctionBody(node, false, isMethod);\n  }\n\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(14)) {\n      const typeNode = this.startNode();\n      [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n      node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, \"TypeAnnotation\") : null;\n    }\n\n    super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n\n  parseStatement(context, topLevel) {\n    if (this.state.strict && this.isContextual(125)) {\n      const lookahead = this.lookahead();\n\n      if (tokenIsKeywordOrIdentifier(lookahead.type)) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseInterface(node);\n      }\n    } else if (this.shouldParseEnums() && this.isContextual(122)) {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(node);\n    }\n\n    const stmt = super.parseStatement(context, topLevel);\n\n    if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {\n      this.flowPragma = null;\n    }\n\n    return stmt;\n  }\n\n  parseExpressionStatement(node, expr) {\n    if (expr.type === \"Identifier\") {\n      if (expr.name === \"declare\") {\n        if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {\n          return this.flowParseDeclare(node);\n        }\n      } else if (tokenIsIdentifier(this.state.type)) {\n        if (expr.name === \"interface\") {\n          return this.flowParseInterface(node);\n        } else if (expr.name === \"type\") {\n          return this.flowParseTypeAlias(node);\n        } else if (expr.name === \"opaque\") {\n          return this.flowParseOpaqueType(node, false);\n        }\n      }\n    }\n\n    return super.parseExpressionStatement(node, expr);\n  }\n\n  shouldParseExportDeclaration() {\n    const {\n      type\n    } = this.state;\n\n    if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 122) {\n      return !this.state.containsEsc;\n    }\n\n    return super.shouldParseExportDeclaration();\n  }\n\n  isExportDefaultSpecifier() {\n    const {\n      type\n    } = this.state;\n\n    if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 122) {\n      return this.state.containsEsc;\n    }\n\n    return super.isExportDefaultSpecifier();\n  }\n\n  parseExportDefaultExpression() {\n    if (this.shouldParseEnums() && this.isContextual(122)) {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(node);\n    }\n\n    return super.parseExportDefaultExpression();\n  }\n\n  parseConditional(expr, startPos, startLoc, refExpressionErrors) {\n    if (!this.match(17)) return expr;\n\n    if (this.state.maybeInArrowParameters) {\n      const nextCh = this.lookaheadCharCode();\n\n      if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {\n        this.setOptionalParametersError(refExpressionErrors);\n        return expr;\n      }\n    }\n\n    this.expect(17);\n    const state = this.state.clone();\n    const originalNoArrowAt = this.state.noArrowAt;\n    const node = this.startNodeAt(startPos, startLoc);\n    let {\n      consequent,\n      failed\n    } = this.tryParseConditionalConsequent();\n    let [valid, invalid] = this.getArrowLikeExpressions(consequent);\n\n    if (failed || invalid.length > 0) {\n      const noArrowAt = [...originalNoArrowAt];\n\n      if (invalid.length > 0) {\n        this.state = state;\n        this.state.noArrowAt = noArrowAt;\n\n        for (let i = 0; i < invalid.length; i++) {\n          noArrowAt.push(invalid[i].start);\n        }\n\n        ({\n          consequent,\n          failed\n        } = this.tryParseConditionalConsequent());\n        [valid, invalid] = this.getArrowLikeExpressions(consequent);\n      }\n\n      if (failed && valid.length > 1) {\n        this.raise(FlowErrors.AmbiguousConditionalArrow, {\n          at: state.startLoc\n        });\n      }\n\n      if (failed && valid.length === 1) {\n        this.state = state;\n        noArrowAt.push(valid[0].start);\n        this.state.noArrowAt = noArrowAt;\n        ({\n          consequent,\n          failed\n        } = this.tryParseConditionalConsequent());\n      }\n    }\n\n    this.getArrowLikeExpressions(consequent, true);\n    this.state.noArrowAt = originalNoArrowAt;\n    this.expect(14);\n    node.test = expr;\n    node.consequent = consequent;\n    node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(undefined, undefined));\n    return this.finishNode(node, \"ConditionalExpression\");\n  }\n\n  tryParseConditionalConsequent() {\n    this.state.noArrowParamsConversionAt.push(this.state.start);\n    const consequent = this.parseMaybeAssignAllowIn();\n    const failed = !this.match(14);\n    this.state.noArrowParamsConversionAt.pop();\n    return {\n      consequent,\n      failed\n    };\n  }\n\n  getArrowLikeExpressions(node, disallowInvalid) {\n    const stack = [node];\n    const arrows = [];\n\n    while (stack.length !== 0) {\n      const node = stack.pop();\n\n      if (node.type === \"ArrowFunctionExpression\") {\n        if (node.typeParameters || !node.returnType) {\n          this.finishArrowValidation(node);\n        } else {\n          arrows.push(node);\n        }\n\n        stack.push(node.body);\n      } else if (node.type === \"ConditionalExpression\") {\n        stack.push(node.consequent);\n        stack.push(node.alternate);\n      }\n    }\n\n    if (disallowInvalid) {\n      arrows.forEach(node => this.finishArrowValidation(node));\n      return [arrows, []];\n    }\n\n    return partition(arrows, node => node.params.every(param => this.isAssignable(param, true)));\n  }\n\n  finishArrowValidation(node) {\n    var _node$extra;\n\n    this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);\n    this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);\n    super.checkParams(node, false, true);\n    this.scope.exit();\n  }\n\n  forwardNoArrowParamsConversionAt(node, parse) {\n    let result;\n\n    if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      this.state.noArrowParamsConversionAt.push(this.state.start);\n      result = parse();\n      this.state.noArrowParamsConversionAt.pop();\n    } else {\n      result = parse();\n    }\n\n    return result;\n  }\n\n  parseParenItem(node, startPos, startLoc) {\n    node = super.parseParenItem(node, startPos, startLoc);\n\n    if (this.eat(17)) {\n      node.optional = true;\n      this.resetEndLocation(node);\n    }\n\n    if (this.match(14)) {\n      const typeCastNode = this.startNodeAt(startPos, startLoc);\n      typeCastNode.expression = node;\n      typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TypeCastExpression\");\n    }\n\n    return node;\n  }\n\n  assertModuleNodeAllowed(node) {\n    if (node.type === \"ImportDeclaration\" && (node.importKind === \"type\" || node.importKind === \"typeof\") || node.type === \"ExportNamedDeclaration\" && node.exportKind === \"type\" || node.type === \"ExportAllDeclaration\" && node.exportKind === \"type\") {\n      return;\n    }\n\n    super.assertModuleNodeAllowed(node);\n  }\n\n  parseExport(node) {\n    const decl = super.parseExport(node);\n\n    if (decl.type === \"ExportNamedDeclaration\" || decl.type === \"ExportAllDeclaration\") {\n      decl.exportKind = decl.exportKind || \"value\";\n    }\n\n    return decl;\n  }\n\n  parseExportDeclaration(node) {\n    if (this.isContextual(126)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n\n      if (this.match(5)) {\n        node.specifiers = this.parseExportSpecifiers(true);\n        this.parseExportFrom(node);\n        return null;\n      } else {\n        return this.flowParseTypeAlias(declarationNode);\n      }\n    } else if (this.isContextual(127)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseOpaqueType(declarationNode, false);\n    } else if (this.isContextual(125)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseInterface(declarationNode);\n    } else if (this.shouldParseEnums() && this.isContextual(122)) {\n      node.exportKind = \"value\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(declarationNode);\n    } else {\n      return super.parseExportDeclaration(node);\n    }\n  }\n\n  eatExportStar(node) {\n    if (super.eatExportStar(...arguments)) return true;\n\n    if (this.isContextual(126) && this.lookahead().type === 55) {\n      node.exportKind = \"type\";\n      this.next();\n      this.next();\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportNamespaceSpecifier(node) {\n    const {\n      startLoc\n    } = this.state;\n    const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);\n\n    if (hasNamespace && node.exportKind === \"type\") {\n      this.unexpected(startLoc);\n    }\n\n    return hasNamespace;\n  }\n\n  parseClassId(node, isStatement, optionalId) {\n    super.parseClassId(node, isStatement, optionalId);\n\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n  }\n\n  parseClassMember(classBody, member, state) {\n    const {\n      startLoc\n    } = this.state;\n\n    if (this.isContextual(121)) {\n      if (this.parseClassMemberFromModifier(classBody, member)) {\n        return;\n      }\n\n      member.declare = true;\n    }\n\n    super.parseClassMember(classBody, member, state);\n\n    if (member.declare) {\n      if (member.type !== \"ClassProperty\" && member.type !== \"ClassPrivateProperty\" && member.type !== \"PropertyDefinition\") {\n        this.raise(FlowErrors.DeclareClassElement, {\n          at: startLoc\n        });\n      } else if (member.value) {\n        this.raise(FlowErrors.DeclareClassFieldInitializer, {\n          at: member.value\n        });\n      }\n    }\n  }\n\n  isIterator(word) {\n    return word === \"iterator\" || word === \"asyncIterator\";\n  }\n\n  readIterator() {\n    const word = super.readWord1();\n    const fullWord = \"@@\" + word;\n\n    if (!this.isIterator(word) || !this.state.inType) {\n      this.raise(Errors.InvalidIdentifier, {\n        at: this.state.curPosition(),\n        identifierName: fullWord\n      });\n    }\n\n    this.finishToken(128, fullWord);\n  }\n\n  getTokenFromCode(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (code === 123 && next === 124) {\n      return this.finishOp(6, 2);\n    } else if (this.state.inType && (code === 62 || code === 60)) {\n      return this.finishOp(code === 62 ? 48 : 47, 1);\n    } else if (this.state.inType && code === 63) {\n      if (next === 46) {\n        return this.finishOp(18, 2);\n      }\n\n      return this.finishOp(17, 1);\n    } else if (isIteratorStart(code, next, this.input.charCodeAt(this.state.pos + 2))) {\n      this.state.pos += 2;\n      return this.readIterator();\n    } else {\n      return super.getTokenFromCode(code);\n    }\n  }\n\n  isAssignable(node, isBinding) {\n    if (node.type === \"TypeCastExpression\") {\n      return this.isAssignable(node.expression, isBinding);\n    } else {\n      return super.isAssignable(node, isBinding);\n    }\n  }\n\n  toAssignable(node, isLHS = false) {\n    if (!isLHS && node.type === \"AssignmentExpression\" && node.left.type === \"TypeCastExpression\") {\n      node.left = this.typeCastToParameter(node.left);\n    }\n\n    super.toAssignable(...arguments);\n  }\n\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n\n      if ((expr == null ? void 0 : expr.type) === \"TypeCastExpression\") {\n        exprList[i] = this.typeCastToParameter(expr);\n      }\n    }\n\n    super.toAssignableList(exprList, trailingCommaLoc, isLHS);\n  }\n\n  toReferencedList(exprList, isParenthesizedExpr) {\n    for (let i = 0; i < exprList.length; i++) {\n      var _expr$extra;\n\n      const expr = exprList[i];\n\n      if (expr && expr.type === \"TypeCastExpression\" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {\n        this.raise(FlowErrors.TypeCastInPattern, {\n          at: expr.typeAnnotation\n        });\n      }\n    }\n\n    return exprList;\n  }\n\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);\n\n    if (canBePattern && !this.state.maybeInArrowParameters) {\n      this.toReferencedList(node.elements);\n    }\n\n    return node;\n  }\n\n  isValidLVal(type, ...rest) {\n    return type === \"TypeCastExpression\" || super.isValidLVal(type, ...rest);\n  }\n\n  parseClassProperty(node) {\n    if (this.match(14)) {\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n\n    return super.parseClassProperty(node);\n  }\n\n  parseClassPrivateProperty(node) {\n    if (this.match(14)) {\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n\n    return super.parseClassPrivateProperty(node);\n  }\n\n  isClassMethod() {\n    return this.match(47) || super.isClassMethod();\n  }\n\n  isClassProperty() {\n    return this.match(14) || super.isClassProperty();\n  }\n\n  isNonstaticConstructor(method) {\n    return !this.match(14) && super.isNonstaticConstructor(method);\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    if (method.variance) {\n      this.unexpected(method.variance.loc.start);\n    }\n\n    delete method.variance;\n\n    if (this.match(47)) {\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n\n    if (method.params && isConstructor) {\n      const params = method.params;\n\n      if (params.length > 0 && this.isThisParam(params[0])) {\n        this.raise(FlowErrors.ThisParamBannedInConstructor, {\n          at: method\n        });\n      }\n    } else if (method.type === \"MethodDefinition\" && isConstructor && method.value.params) {\n      const params = method.value.params;\n\n      if (params.length > 0 && this.isThisParam(params[0])) {\n        this.raise(FlowErrors.ThisParamBannedInConstructor, {\n          at: method\n        });\n      }\n    }\n  }\n\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    if (method.variance) {\n      this.unexpected(method.variance.loc.start);\n    }\n\n    delete method.variance;\n\n    if (this.match(47)) {\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n\n    if (node.superClass && this.match(47)) {\n      node.superTypeParameters = this.flowParseTypeParameterInstantiation();\n    }\n\n    if (this.isContextual(110)) {\n      this.next();\n      const implemented = node.implements = [];\n\n      do {\n        const node = this.startNode();\n        node.id = this.flowParseRestrictedIdentifier(true);\n\n        if (this.match(47)) {\n          node.typeParameters = this.flowParseTypeParameterInstantiation();\n        } else {\n          node.typeParameters = null;\n        }\n\n        implemented.push(this.finishNode(node, \"ClassImplements\"));\n      } while (this.eat(12));\n    }\n  }\n\n  checkGetterSetterParams(method) {\n    super.checkGetterSetterParams(method);\n    const params = this.getObjectOrClassMethodParams(method);\n\n    if (params.length > 0) {\n      const param = params[0];\n\n      if (this.isThisParam(param) && method.kind === \"get\") {\n        this.raise(FlowErrors.GetterMayNotHaveThisParam, {\n          at: param\n        });\n      } else if (this.isThisParam(param)) {\n        this.raise(FlowErrors.SetterMayNotHaveThisParam, {\n          at: param\n        });\n      }\n    }\n  }\n\n  parsePropertyNamePrefixOperator(node) {\n    node.variance = this.flowParseVariance();\n  }\n\n  parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    if (prop.variance) {\n      this.unexpected(prop.variance.loc.start);\n    }\n\n    delete prop.variance;\n    let typeParameters;\n\n    if (this.match(47) && !isAccessor) {\n      typeParameters = this.flowParseTypeParameterDeclaration();\n      if (!this.match(10)) this.unexpected();\n    }\n\n    super.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\n\n    if (typeParameters) {\n      (prop.value || prop).typeParameters = typeParameters;\n    }\n  }\n\n  parseAssignableListItemTypes(param) {\n    if (this.eat(17)) {\n      if (param.type !== \"Identifier\") {\n        this.raise(FlowErrors.PatternIsOptional, {\n          at: param\n        });\n      }\n\n      if (this.isThisParam(param)) {\n        this.raise(FlowErrors.ThisParamMayNotBeOptional, {\n          at: param\n        });\n      }\n\n      param.optional = true;\n    }\n\n    if (this.match(14)) {\n      param.typeAnnotation = this.flowParseTypeAnnotation();\n    } else if (this.isThisParam(param)) {\n      this.raise(FlowErrors.ThisParamAnnotationRequired, {\n        at: param\n      });\n    }\n\n    if (this.match(29) && this.isThisParam(param)) {\n      this.raise(FlowErrors.ThisParamNoDefault, {\n        at: param\n      });\n    }\n\n    this.resetEndLocation(param);\n    return param;\n  }\n\n  parseMaybeDefault(startPos, startLoc, left) {\n    const node = super.parseMaybeDefault(startPos, startLoc, left);\n\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(FlowErrors.TypeBeforeInitializer, {\n        at: node.typeAnnotation\n      });\n    }\n\n    return node;\n  }\n\n  shouldParseDefaultImport(node) {\n    if (!hasTypeImportKind(node)) {\n      return super.shouldParseDefaultImport(node);\n    }\n\n    return isMaybeDefaultImport(this.state.type);\n  }\n\n  parseImportSpecifierLocal(node, specifier, type) {\n    specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();\n    node.specifiers.push(this.finishImportSpecifier(specifier, type));\n  }\n\n  maybeParseDefaultImportSpecifier(node) {\n    node.importKind = \"value\";\n    let kind = null;\n\n    if (this.match(87)) {\n      kind = \"typeof\";\n    } else if (this.isContextual(126)) {\n      kind = \"type\";\n    }\n\n    if (kind) {\n      const lh = this.lookahead();\n      const {\n        type\n      } = lh;\n\n      if (kind === \"type\" && type === 55) {\n        this.unexpected(null, lh.type);\n      }\n\n      if (isMaybeDefaultImport(type) || type === 5 || type === 55) {\n        this.next();\n        node.importKind = kind;\n      }\n    }\n\n    return super.maybeParseDefaultImportSpecifier(node);\n  }\n\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {\n    const firstIdent = specifier.imported;\n    let specifierTypeKind = null;\n\n    if (firstIdent.type === \"Identifier\") {\n      if (firstIdent.name === \"type\") {\n        specifierTypeKind = \"type\";\n      } else if (firstIdent.name === \"typeof\") {\n        specifierTypeKind = \"typeof\";\n      }\n    }\n\n    let isBinding = false;\n\n    if (this.isContextual(93) && !this.isLookaheadContextual(\"as\")) {\n      const as_ident = this.parseIdentifier(true);\n\n      if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {\n        specifier.imported = as_ident;\n        specifier.importKind = specifierTypeKind;\n        specifier.local = cloneIdentifier(as_ident);\n      } else {\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n        specifier.local = this.parseIdentifier();\n      }\n    } else {\n      if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {\n        specifier.imported = this.parseIdentifier(true);\n        specifier.importKind = specifierTypeKind;\n      } else {\n        if (importedIsString) {\n          throw this.raise(Errors.ImportBindingIsString, {\n            at: specifier,\n            importName: firstIdent.value\n          });\n        }\n\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n      }\n\n      if (this.eatContextual(93)) {\n        specifier.local = this.parseIdentifier();\n      } else {\n        isBinding = true;\n        specifier.local = cloneIdentifier(specifier.imported);\n      }\n    }\n\n    const specifierIsTypeImport = hasTypeImportKind(specifier);\n\n    if (isInTypeOnlyImport && specifierIsTypeImport) {\n      this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, {\n        at: specifier\n      });\n    }\n\n    if (isInTypeOnlyImport || specifierIsTypeImport) {\n      this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);\n    }\n\n    if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {\n      this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);\n    }\n\n    return this.finishImportSpecifier(specifier, \"ImportSpecifier\");\n  }\n\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case 78:\n        return this.parseIdentifier(true);\n\n      default:\n        return super.parseBindingAtom();\n    }\n  }\n\n  parseFunctionParams(node, allowModifiers) {\n    const kind = node.kind;\n\n    if (kind !== \"get\" && kind !== \"set\" && this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n\n    super.parseFunctionParams(node, allowModifiers);\n  }\n\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n\n    if (this.match(14)) {\n      decl.id.typeAnnotation = this.flowParseTypeAnnotation();\n      this.resetEndLocation(decl.id);\n    }\n  }\n\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(14)) {\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n      this.state.noAnonFunctionType = true;\n      node.returnType = this.flowParseTypeAnnotation();\n      this.state.noAnonFunctionType = oldNoAnonFunctionType;\n    }\n\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n\n  shouldParseAsyncArrow() {\n    return this.match(14) || super.shouldParseAsyncArrow();\n  }\n\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    var _jsx;\n\n    let state = null;\n    let jsx;\n\n    if (this.hasPlugin(\"jsx\") && (this.match(138) || this.match(47))) {\n      state = this.state.clone();\n      jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!jsx.error) return jsx.node;\n      const {\n        context\n      } = this.state;\n      const currentContext = context[context.length - 1];\n\n      if (currentContext === types.j_oTag || currentContext === types.j_expr) {\n        context.pop();\n      }\n    }\n\n    if ((_jsx = jsx) != null && _jsx.error || this.match(47)) {\n      var _jsx2, _jsx3;\n\n      state = state || this.state.clone();\n      let typeParameters;\n      const arrow = this.tryParse(abort => {\n        var _arrowExpression$extr;\n\n        typeParameters = this.flowParseTypeParameterDeclaration();\n        const arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, () => {\n          const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n          this.resetStartLocationFromNode(result, typeParameters);\n          return result;\n        });\n        if ((_arrowExpression$extr = arrowExpression.extra) != null && _arrowExpression$extr.parenthesized) abort();\n        const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);\n        if (expr.type !== \"ArrowFunctionExpression\") abort();\n        expr.typeParameters = typeParameters;\n        this.resetStartLocationFromNode(expr, typeParameters);\n        return arrowExpression;\n      }, state);\n      let arrowExpression = null;\n\n      if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === \"ArrowFunctionExpression\") {\n        if (!arrow.error && !arrow.aborted) {\n          if (arrow.node.async) {\n            this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, {\n              at: typeParameters\n            });\n          }\n\n          return arrow.node;\n        }\n\n        arrowExpression = arrow.node;\n      }\n\n      if ((_jsx2 = jsx) != null && _jsx2.node) {\n        this.state = jsx.failState;\n        return jsx.node;\n      }\n\n      if (arrowExpression) {\n        this.state = arrow.failState;\n        return arrowExpression;\n      }\n\n      if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;\n      if (arrow.thrown) throw arrow.error;\n      throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, {\n        at: typeParameters\n      });\n    }\n\n    return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n  }\n\n  parseArrow(node) {\n    if (this.match(14)) {\n      const result = this.tryParse(() => {\n        const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n        this.state.noAnonFunctionType = true;\n        const typeNode = this.startNode();\n        [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        if (this.canInsertSemicolon()) this.unexpected();\n        if (!this.match(19)) this.unexpected();\n        return typeNode;\n      });\n      if (result.thrown) return null;\n      if (result.error) this.state = result.failState;\n      node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, \"TypeAnnotation\") : null;\n    }\n\n    return super.parseArrow(node);\n  }\n\n  shouldParseArrow(params) {\n    return this.match(14) || super.shouldParseArrow(params);\n  }\n\n  setArrowFunctionParameters(node, params) {\n    if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      node.params = params;\n    } else {\n      super.setArrowFunctionParameters(node, params);\n    }\n  }\n\n  checkParams(node, allowDuplicates, isArrowFunction) {\n    if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      return;\n    }\n\n    for (let i = 0; i < node.params.length; i++) {\n      if (this.isThisParam(node.params[i]) && i > 0) {\n        this.raise(FlowErrors.ThisParamMustBeFirst, {\n          at: node.params[i]\n        });\n      }\n    }\n\n    return super.checkParams(...arguments);\n  }\n\n  parseParenAndDistinguishExpression(canBeArrow) {\n    return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);\n  }\n\n  parseSubscripts(base, startPos, startLoc, noCalls) {\n    if (base.type === \"Identifier\" && base.name === \"async\" && this.state.noArrowAt.indexOf(startPos) !== -1) {\n      this.next();\n      const node = this.startNodeAt(startPos, startLoc);\n      node.callee = base;\n      node.arguments = this.parseCallExpressionArguments(11, false);\n      base = this.finishNode(node, \"CallExpression\");\n    } else if (base.type === \"Identifier\" && base.name === \"async\" && this.match(47)) {\n      const state = this.state.clone();\n      const arrow = this.tryParse(abort => this.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort(), state);\n      if (!arrow.error && !arrow.aborted) return arrow.node;\n      const result = this.tryParse(() => super.parseSubscripts(base, startPos, startLoc, noCalls), state);\n      if (result.node && !result.error) return result.node;\n\n      if (arrow.node) {\n        this.state = arrow.failState;\n        return arrow.node;\n      }\n\n      if (result.node) {\n        this.state = result.failState;\n        return result.node;\n      }\n\n      throw arrow.error || result.error;\n    }\n\n    return super.parseSubscripts(base, startPos, startLoc, noCalls);\n  }\n\n  parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {\n    if (this.match(18) && this.isLookaheadToken_lt()) {\n      subscriptState.optionalChainMember = true;\n\n      if (noCalls) {\n        subscriptState.stop = true;\n        return base;\n      }\n\n      this.next();\n      const node = this.startNodeAt(startPos, startLoc);\n      node.callee = base;\n      node.typeArguments = this.flowParseTypeParameterInstantiation();\n      this.expect(10);\n      node.arguments = this.parseCallExpressionArguments(11, false);\n      node.optional = true;\n      return this.finishCallExpression(node, true);\n    } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.callee = base;\n      const result = this.tryParse(() => {\n        node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();\n        this.expect(10);\n        node.arguments = this.parseCallExpressionArguments(11, false);\n        if (subscriptState.optionalChainMember) node.optional = false;\n        return this.finishCallExpression(node, subscriptState.optionalChainMember);\n      });\n\n      if (result.node) {\n        if (result.error) this.state = result.failState;\n        return result.node;\n      }\n    }\n\n    return super.parseSubscript(base, startPos, startLoc, noCalls, subscriptState);\n  }\n\n  parseNewCallee(node) {\n    super.parseNewCallee(node);\n    let targs = null;\n\n    if (this.shouldParseTypes() && this.match(47)) {\n      targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;\n    }\n\n    node.typeArguments = targs;\n  }\n\n  parseAsyncArrowWithTypeParameters(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n    this.parseFunctionParams(node);\n    if (!this.parseArrow(node)) return;\n    return this.parseArrowExpression(node, undefined, true);\n  }\n\n  readToken_mult_modulo(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (code === 42 && next === 47 && this.state.hasFlowComment) {\n      this.state.hasFlowComment = false;\n      this.state.pos += 2;\n      this.nextToken();\n      return;\n    }\n\n    super.readToken_mult_modulo(code);\n  }\n\n  readToken_pipe_amp(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (code === 124 && next === 125) {\n      this.finishOp(9, 2);\n      return;\n    }\n\n    super.readToken_pipe_amp(code);\n  }\n\n  parseTopLevel(file, program) {\n    const fileNode = super.parseTopLevel(file, program);\n\n    if (this.state.hasFlowComment) {\n      this.raise(FlowErrors.UnterminatedFlowComment, {\n        at: this.state.curPosition()\n      });\n    }\n\n    return fileNode;\n  }\n\n  skipBlockComment() {\n    if (this.hasPlugin(\"flowComments\") && this.skipFlowComment()) {\n      if (this.state.hasFlowComment) {\n        throw this.raise(FlowErrors.NestedFlowComment, {\n          at: this.state.startLoc\n        });\n      }\n\n      this.hasFlowCommentCompletion();\n      this.state.pos += this.skipFlowComment();\n      this.state.hasFlowComment = true;\n      return;\n    }\n\n    if (this.state.hasFlowComment) {\n      const end = this.input.indexOf(\"*-/\", this.state.pos + 2);\n\n      if (end === -1) {\n        throw this.raise(Errors.UnterminatedComment, {\n          at: this.state.curPosition()\n        });\n      }\n\n      this.state.pos = end + 2 + 3;\n      return;\n    }\n\n    return super.skipBlockComment();\n  }\n\n  skipFlowComment() {\n    const {\n      pos\n    } = this.state;\n    let shiftToFirstNonWhiteSpace = 2;\n\n    while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {\n      shiftToFirstNonWhiteSpace++;\n    }\n\n    const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);\n    const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);\n\n    if (ch2 === 58 && ch3 === 58) {\n      return shiftToFirstNonWhiteSpace + 2;\n    }\n\n    if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === \"flow-include\") {\n      return shiftToFirstNonWhiteSpace + 12;\n    }\n\n    if (ch2 === 58 && ch3 !== 58) {\n      return shiftToFirstNonWhiteSpace;\n    }\n\n    return false;\n  }\n\n  hasFlowCommentCompletion() {\n    const end = this.input.indexOf(\"*/\", this.state.pos);\n\n    if (end === -1) {\n      throw this.raise(Errors.UnterminatedComment, {\n        at: this.state.curPosition()\n      });\n    }\n  }\n\n  flowEnumErrorBooleanMemberNotInitialized(loc, {\n    enumName,\n    memberName\n  }) {\n    this.raise(FlowErrors.EnumBooleanMemberNotInitialized, {\n      at: loc,\n      memberName,\n      enumName\n    });\n  }\n\n  flowEnumErrorInvalidMemberInitializer(loc, enumContext) {\n    return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === \"symbol\" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, Object.assign({\n      at: loc\n    }, enumContext));\n  }\n\n  flowEnumErrorNumberMemberNotInitialized(loc, {\n    enumName,\n    memberName\n  }) {\n    this.raise(FlowErrors.EnumNumberMemberNotInitialized, {\n      at: loc,\n      enumName,\n      memberName\n    });\n  }\n\n  flowEnumErrorStringMemberInconsistentlyInitailized(node, {\n    enumName\n  }) {\n    this.raise(FlowErrors.EnumStringMemberInconsistentlyInitailized, {\n      at: node,\n      enumName\n    });\n  }\n\n  flowEnumMemberInit() {\n    const startLoc = this.state.startLoc;\n\n    const endOfInit = () => this.match(12) || this.match(8);\n\n    switch (this.state.type) {\n      case 130:\n        {\n          const literal = this.parseNumericLiteral(this.state.value);\n\n          if (endOfInit()) {\n            return {\n              type: \"number\",\n              loc: literal.loc.start,\n              value: literal\n            };\n          }\n\n          return {\n            type: \"invalid\",\n            loc: startLoc\n          };\n        }\n\n      case 129:\n        {\n          const literal = this.parseStringLiteral(this.state.value);\n\n          if (endOfInit()) {\n            return {\n              type: \"string\",\n              loc: literal.loc.start,\n              value: literal\n            };\n          }\n\n          return {\n            type: \"invalid\",\n            loc: startLoc\n          };\n        }\n\n      case 85:\n      case 86:\n        {\n          const literal = this.parseBooleanLiteral(this.match(85));\n\n          if (endOfInit()) {\n            return {\n              type: \"boolean\",\n              loc: literal.loc.start,\n              value: literal\n            };\n          }\n\n          return {\n            type: \"invalid\",\n            loc: startLoc\n          };\n        }\n\n      default:\n        return {\n          type: \"invalid\",\n          loc: startLoc\n        };\n    }\n  }\n\n  flowEnumMemberRaw() {\n    const loc = this.state.startLoc;\n    const id = this.parseIdentifier(true);\n    const init = this.eat(29) ? this.flowEnumMemberInit() : {\n      type: \"none\",\n      loc\n    };\n    return {\n      id,\n      init\n    };\n  }\n\n  flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {\n    const {\n      explicitType\n    } = context;\n\n    if (explicitType === null) {\n      return;\n    }\n\n    if (explicitType !== expectedType) {\n      this.flowEnumErrorInvalidMemberInitializer(loc, context);\n    }\n  }\n\n  flowEnumMembers({\n    enumName,\n    explicitType\n  }) {\n    const seenNames = new Set();\n    const members = {\n      booleanMembers: [],\n      numberMembers: [],\n      stringMembers: [],\n      defaultedMembers: []\n    };\n    let hasUnknownMembers = false;\n\n    while (!this.match(8)) {\n      if (this.eat(21)) {\n        hasUnknownMembers = true;\n        break;\n      }\n\n      const memberNode = this.startNode();\n      const {\n        id,\n        init\n      } = this.flowEnumMemberRaw();\n      const memberName = id.name;\n\n      if (memberName === \"\") {\n        continue;\n      }\n\n      if (/^[a-z]/.test(memberName)) {\n        this.raise(FlowErrors.EnumInvalidMemberName, {\n          at: id,\n          memberName,\n          suggestion: memberName[0].toUpperCase() + memberName.slice(1),\n          enumName\n        });\n      }\n\n      if (seenNames.has(memberName)) {\n        this.raise(FlowErrors.EnumDuplicateMemberName, {\n          at: id,\n          memberName,\n          enumName\n        });\n      }\n\n      seenNames.add(memberName);\n      const context = {\n        enumName,\n        explicitType,\n        memberName\n      };\n      memberNode.id = id;\n\n      switch (init.type) {\n        case \"boolean\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"boolean\");\n            memberNode.init = init.value;\n            members.booleanMembers.push(this.finishNode(memberNode, \"EnumBooleanMember\"));\n            break;\n          }\n\n        case \"number\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"number\");\n            memberNode.init = init.value;\n            members.numberMembers.push(this.finishNode(memberNode, \"EnumNumberMember\"));\n            break;\n          }\n\n        case \"string\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"string\");\n            memberNode.init = init.value;\n            members.stringMembers.push(this.finishNode(memberNode, \"EnumStringMember\"));\n            break;\n          }\n\n        case \"invalid\":\n          {\n            throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);\n          }\n\n        case \"none\":\n          {\n            switch (explicitType) {\n              case \"boolean\":\n                this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);\n                break;\n\n              case \"number\":\n                this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);\n                break;\n\n              default:\n                members.defaultedMembers.push(this.finishNode(memberNode, \"EnumDefaultedMember\"));\n            }\n          }\n      }\n\n      if (!this.match(8)) {\n        this.expect(12);\n      }\n    }\n\n    return {\n      members,\n      hasUnknownMembers\n    };\n  }\n\n  flowEnumStringMembers(initializedMembers, defaultedMembers, {\n    enumName\n  }) {\n    if (initializedMembers.length === 0) {\n      return defaultedMembers;\n    } else if (defaultedMembers.length === 0) {\n      return initializedMembers;\n    } else if (defaultedMembers.length > initializedMembers.length) {\n      for (const member of initializedMembers) {\n        this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {\n          enumName\n        });\n      }\n\n      return defaultedMembers;\n    } else {\n      for (const member of defaultedMembers) {\n        this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {\n          enumName\n        });\n      }\n\n      return initializedMembers;\n    }\n  }\n\n  flowEnumParseExplicitType({\n    enumName\n  }) {\n    if (!this.eatContextual(101)) return null;\n\n    if (!tokenIsIdentifier(this.state.type)) {\n      throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, {\n        at: this.state.startLoc,\n        enumName\n      });\n    }\n\n    const {\n      value\n    } = this.state;\n    this.next();\n\n    if (value !== \"boolean\" && value !== \"number\" && value !== \"string\" && value !== \"symbol\") {\n      this.raise(FlowErrors.EnumInvalidExplicitType, {\n        at: this.state.startLoc,\n        enumName,\n        invalidEnumType: value\n      });\n    }\n\n    return value;\n  }\n\n  flowEnumBody(node, id) {\n    const enumName = id.name;\n    const nameLoc = id.loc.start;\n    const explicitType = this.flowEnumParseExplicitType({\n      enumName\n    });\n    this.expect(5);\n    const {\n      members,\n      hasUnknownMembers\n    } = this.flowEnumMembers({\n      enumName,\n      explicitType\n    });\n    node.hasUnknownMembers = hasUnknownMembers;\n\n    switch (explicitType) {\n      case \"boolean\":\n        node.explicitType = true;\n        node.members = members.booleanMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumBooleanBody\");\n\n      case \"number\":\n        node.explicitType = true;\n        node.members = members.numberMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumNumberBody\");\n\n      case \"string\":\n        node.explicitType = true;\n        node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n          enumName\n        });\n        this.expect(8);\n        return this.finishNode(node, \"EnumStringBody\");\n\n      case \"symbol\":\n        node.members = members.defaultedMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumSymbolBody\");\n\n      default:\n        {\n          const empty = () => {\n            node.members = [];\n            this.expect(8);\n            return this.finishNode(node, \"EnumStringBody\");\n          };\n\n          node.explicitType = false;\n          const boolsLen = members.booleanMembers.length;\n          const numsLen = members.numberMembers.length;\n          const strsLen = members.stringMembers.length;\n          const defaultedLen = members.defaultedMembers.length;\n\n          if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {\n            return empty();\n          } else if (!boolsLen && !numsLen) {\n            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n              enumName\n            });\n            this.expect(8);\n            return this.finishNode(node, \"EnumStringBody\");\n          } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {\n                enumName,\n                memberName: member.id.name\n              });\n            }\n\n            node.members = members.booleanMembers;\n            this.expect(8);\n            return this.finishNode(node, \"EnumBooleanBody\");\n          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {\n                enumName,\n                memberName: member.id.name\n              });\n            }\n\n            node.members = members.numberMembers;\n            this.expect(8);\n            return this.finishNode(node, \"EnumNumberBody\");\n          } else {\n            this.raise(FlowErrors.EnumInconsistentMemberValues, {\n              at: nameLoc,\n              enumName\n            });\n            return empty();\n          }\n        }\n    }\n  }\n\n  flowParseEnumDeclaration(node) {\n    const id = this.parseIdentifier();\n    node.id = id;\n    node.body = this.flowEnumBody(this.startNode(), id);\n    return this.finishNode(node, \"EnumDeclaration\");\n  }\n\n  isLookaheadToken_lt() {\n    const next = this.nextTokenStart();\n\n    if (this.input.charCodeAt(next) === 60) {\n      const afterNext = this.input.charCodeAt(next + 1);\n      return afterNext !== 60 && afterNext !== 61;\n    }\n\n    return false;\n  }\n\n  maybeUnwrapTypeCastExpression(node) {\n    return node.type === \"TypeCastExpression\" ? node.expression : node;\n  }\n\n});\n\nconst entities = {\n  __proto__: null,\n  quot: \"\\u0022\",\n  amp: \"&\",\n  apos: \"\\u0027\",\n  lt: \"<\",\n  gt: \">\",\n  nbsp: \"\\u00A0\",\n  iexcl: \"\\u00A1\",\n  cent: \"\\u00A2\",\n  pound: \"\\u00A3\",\n  curren: \"\\u00A4\",\n  yen: \"\\u00A5\",\n  brvbar: \"\\u00A6\",\n  sect: \"\\u00A7\",\n  uml: \"\\u00A8\",\n  copy: \"\\u00A9\",\n  ordf: \"\\u00AA\",\n  laquo: \"\\u00AB\",\n  not: \"\\u00AC\",\n  shy: \"\\u00AD\",\n  reg: \"\\u00AE\",\n  macr: \"\\u00AF\",\n  deg: \"\\u00B0\",\n  plusmn: \"\\u00B1\",\n  sup2: \"\\u00B2\",\n  sup3: \"\\u00B3\",\n  acute: \"\\u00B4\",\n  micro: \"\\u00B5\",\n  para: \"\\u00B6\",\n  middot: \"\\u00B7\",\n  cedil: \"\\u00B8\",\n  sup1: \"\\u00B9\",\n  ordm: \"\\u00BA\",\n  raquo: \"\\u00BB\",\n  frac14: \"\\u00BC\",\n  frac12: \"\\u00BD\",\n  frac34: \"\\u00BE\",\n  iquest: \"\\u00BF\",\n  Agrave: \"\\u00C0\",\n  Aacute: \"\\u00C1\",\n  Acirc: \"\\u00C2\",\n  Atilde: \"\\u00C3\",\n  Auml: \"\\u00C4\",\n  Aring: \"\\u00C5\",\n  AElig: \"\\u00C6\",\n  Ccedil: \"\\u00C7\",\n  Egrave: \"\\u00C8\",\n  Eacute: \"\\u00C9\",\n  Ecirc: \"\\u00CA\",\n  Euml: \"\\u00CB\",\n  Igrave: \"\\u00CC\",\n  Iacute: \"\\u00CD\",\n  Icirc: \"\\u00CE\",\n  Iuml: \"\\u00CF\",\n  ETH: \"\\u00D0\",\n  Ntilde: \"\\u00D1\",\n  Ograve: \"\\u00D2\",\n  Oacute: \"\\u00D3\",\n  Ocirc: \"\\u00D4\",\n  Otilde: \"\\u00D5\",\n  Ouml: \"\\u00D6\",\n  times: \"\\u00D7\",\n  Oslash: \"\\u00D8\",\n  Ugrave: \"\\u00D9\",\n  Uacute: \"\\u00DA\",\n  Ucirc: \"\\u00DB\",\n  Uuml: \"\\u00DC\",\n  Yacute: \"\\u00DD\",\n  THORN: \"\\u00DE\",\n  szlig: \"\\u00DF\",\n  agrave: \"\\u00E0\",\n  aacute: \"\\u00E1\",\n  acirc: \"\\u00E2\",\n  atilde: \"\\u00E3\",\n  auml: \"\\u00E4\",\n  aring: \"\\u00E5\",\n  aelig: \"\\u00E6\",\n  ccedil: \"\\u00E7\",\n  egrave: \"\\u00E8\",\n  eacute: \"\\u00E9\",\n  ecirc: \"\\u00EA\",\n  euml: \"\\u00EB\",\n  igrave: \"\\u00EC\",\n  iacute: \"\\u00ED\",\n  icirc: \"\\u00EE\",\n  iuml: \"\\u00EF\",\n  eth: \"\\u00F0\",\n  ntilde: \"\\u00F1\",\n  ograve: \"\\u00F2\",\n  oacute: \"\\u00F3\",\n  ocirc: \"\\u00F4\",\n  otilde: \"\\u00F5\",\n  ouml: \"\\u00F6\",\n  divide: \"\\u00F7\",\n  oslash: \"\\u00F8\",\n  ugrave: \"\\u00F9\",\n  uacute: \"\\u00FA\",\n  ucirc: \"\\u00FB\",\n  uuml: \"\\u00FC\",\n  yacute: \"\\u00FD\",\n  thorn: \"\\u00FE\",\n  yuml: \"\\u00FF\",\n  OElig: \"\\u0152\",\n  oelig: \"\\u0153\",\n  Scaron: \"\\u0160\",\n  scaron: \"\\u0161\",\n  Yuml: \"\\u0178\",\n  fnof: \"\\u0192\",\n  circ: \"\\u02C6\",\n  tilde: \"\\u02DC\",\n  Alpha: \"\\u0391\",\n  Beta: \"\\u0392\",\n  Gamma: \"\\u0393\",\n  Delta: \"\\u0394\",\n  Epsilon: \"\\u0395\",\n  Zeta: \"\\u0396\",\n  Eta: \"\\u0397\",\n  Theta: \"\\u0398\",\n  Iota: \"\\u0399\",\n  Kappa: \"\\u039A\",\n  Lambda: \"\\u039B\",\n  Mu: \"\\u039C\",\n  Nu: \"\\u039D\",\n  Xi: \"\\u039E\",\n  Omicron: \"\\u039F\",\n  Pi: \"\\u03A0\",\n  Rho: \"\\u03A1\",\n  Sigma: \"\\u03A3\",\n  Tau: \"\\u03A4\",\n  Upsilon: \"\\u03A5\",\n  Phi: \"\\u03A6\",\n  Chi: \"\\u03A7\",\n  Psi: \"\\u03A8\",\n  Omega: \"\\u03A9\",\n  alpha: \"\\u03B1\",\n  beta: \"\\u03B2\",\n  gamma: \"\\u03B3\",\n  delta: \"\\u03B4\",\n  epsilon: \"\\u03B5\",\n  zeta: \"\\u03B6\",\n  eta: \"\\u03B7\",\n  theta: \"\\u03B8\",\n  iota: \"\\u03B9\",\n  kappa: \"\\u03BA\",\n  lambda: \"\\u03BB\",\n  mu: \"\\u03BC\",\n  nu: \"\\u03BD\",\n  xi: \"\\u03BE\",\n  omicron: \"\\u03BF\",\n  pi: \"\\u03C0\",\n  rho: \"\\u03C1\",\n  sigmaf: \"\\u03C2\",\n  sigma: \"\\u03C3\",\n  tau: \"\\u03C4\",\n  upsilon: \"\\u03C5\",\n  phi: \"\\u03C6\",\n  chi: \"\\u03C7\",\n  psi: \"\\u03C8\",\n  omega: \"\\u03C9\",\n  thetasym: \"\\u03D1\",\n  upsih: \"\\u03D2\",\n  piv: \"\\u03D6\",\n  ensp: \"\\u2002\",\n  emsp: \"\\u2003\",\n  thinsp: \"\\u2009\",\n  zwnj: \"\\u200C\",\n  zwj: \"\\u200D\",\n  lrm: \"\\u200E\",\n  rlm: \"\\u200F\",\n  ndash: \"\\u2013\",\n  mdash: \"\\u2014\",\n  lsquo: \"\\u2018\",\n  rsquo: \"\\u2019\",\n  sbquo: \"\\u201A\",\n  ldquo: \"\\u201C\",\n  rdquo: \"\\u201D\",\n  bdquo: \"\\u201E\",\n  dagger: \"\\u2020\",\n  Dagger: \"\\u2021\",\n  bull: \"\\u2022\",\n  hellip: \"\\u2026\",\n  permil: \"\\u2030\",\n  prime: \"\\u2032\",\n  Prime: \"\\u2033\",\n  lsaquo: \"\\u2039\",\n  rsaquo: \"\\u203A\",\n  oline: \"\\u203E\",\n  frasl: \"\\u2044\",\n  euro: \"\\u20AC\",\n  image: \"\\u2111\",\n  weierp: \"\\u2118\",\n  real: \"\\u211C\",\n  trade: \"\\u2122\",\n  alefsym: \"\\u2135\",\n  larr: \"\\u2190\",\n  uarr: \"\\u2191\",\n  rarr: \"\\u2192\",\n  darr: \"\\u2193\",\n  harr: \"\\u2194\",\n  crarr: \"\\u21B5\",\n  lArr: \"\\u21D0\",\n  uArr: \"\\u21D1\",\n  rArr: \"\\u21D2\",\n  dArr: \"\\u21D3\",\n  hArr: \"\\u21D4\",\n  forall: \"\\u2200\",\n  part: \"\\u2202\",\n  exist: \"\\u2203\",\n  empty: \"\\u2205\",\n  nabla: \"\\u2207\",\n  isin: \"\\u2208\",\n  notin: \"\\u2209\",\n  ni: \"\\u220B\",\n  prod: \"\\u220F\",\n  sum: \"\\u2211\",\n  minus: \"\\u2212\",\n  lowast: \"\\u2217\",\n  radic: \"\\u221A\",\n  prop: \"\\u221D\",\n  infin: \"\\u221E\",\n  ang: \"\\u2220\",\n  and: \"\\u2227\",\n  or: \"\\u2228\",\n  cap: \"\\u2229\",\n  cup: \"\\u222A\",\n  int: \"\\u222B\",\n  there4: \"\\u2234\",\n  sim: \"\\u223C\",\n  cong: \"\\u2245\",\n  asymp: \"\\u2248\",\n  ne: \"\\u2260\",\n  equiv: \"\\u2261\",\n  le: \"\\u2264\",\n  ge: \"\\u2265\",\n  sub: \"\\u2282\",\n  sup: \"\\u2283\",\n  nsub: \"\\u2284\",\n  sube: \"\\u2286\",\n  supe: \"\\u2287\",\n  oplus: \"\\u2295\",\n  otimes: \"\\u2297\",\n  perp: \"\\u22A5\",\n  sdot: \"\\u22C5\",\n  lceil: \"\\u2308\",\n  rceil: \"\\u2309\",\n  lfloor: \"\\u230A\",\n  rfloor: \"\\u230B\",\n  lang: \"\\u2329\",\n  rang: \"\\u232A\",\n  loz: \"\\u25CA\",\n  spades: \"\\u2660\",\n  clubs: \"\\u2663\",\n  hearts: \"\\u2665\",\n  diams: \"\\u2666\"\n};\n\nconst JsxErrors = ParseErrorEnum`jsx`(_ => ({\n  AttributeIsEmpty: _(\"JSX attributes must only be assigned a non-empty expression.\"),\n  MissingClosingTagElement: _(({\n    openingTagName\n  }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`),\n  MissingClosingTagFragment: _(\"Expected corresponding JSX closing tag for <>.\"),\n  UnexpectedSequenceExpression: _(\"Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?\"),\n  UnexpectedToken: _(({\n    unexpected,\n    HTMLEntity\n  }) => `Unexpected token \\`${unexpected}\\`. Did you mean \\`${HTMLEntity}\\` or \\`{'${unexpected}'}\\`?`),\n  UnsupportedJsxValue: _(\"JSX value should be either an expression or a quoted JSX text.\"),\n  UnterminatedJsxContent: _(\"Unterminated JSX contents.\"),\n  UnwrappedAdjacentJSXElements: _(\"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?\")\n}));\n\nfunction isFragment(object) {\n  return object ? object.type === \"JSXOpeningFragment\" || object.type === \"JSXClosingFragment\" : false;\n}\n\nfunction getQualifiedJSXName(object) {\n  if (object.type === \"JSXIdentifier\") {\n    return object.name;\n  }\n\n  if (object.type === \"JSXNamespacedName\") {\n    return object.namespace.name + \":\" + object.name.name;\n  }\n\n  if (object.type === \"JSXMemberExpression\") {\n    return getQualifiedJSXName(object.object) + \".\" + getQualifiedJSXName(object.property);\n  }\n\n  throw new Error(\"Node had unexpected type: \" + object.type);\n}\n\nvar jsx = (superClass => class extends superClass {\n  jsxReadToken() {\n    let out = \"\";\n    let chunkStart = this.state.pos;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(JsxErrors.UnterminatedJsxContent, {\n          at: this.state.startLoc\n        });\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n\n      switch (ch) {\n        case 60:\n        case 123:\n          if (this.state.pos === this.state.start) {\n            if (ch === 60 && this.state.canStartJSXElement) {\n              ++this.state.pos;\n              return this.finishToken(138);\n            }\n\n            return super.getTokenFromCode(ch);\n          }\n\n          out += this.input.slice(chunkStart, this.state.pos);\n          return this.finishToken(137, out);\n\n        case 38:\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadEntity();\n          chunkStart = this.state.pos;\n          break;\n\n        case 62:\n        case 125:\n\n        default:\n          if (isNewLine(ch)) {\n            out += this.input.slice(chunkStart, this.state.pos);\n            out += this.jsxReadNewLine(true);\n            chunkStart = this.state.pos;\n          } else {\n            ++this.state.pos;\n          }\n\n      }\n    }\n  }\n\n  jsxReadNewLine(normalizeCRLF) {\n    const ch = this.input.charCodeAt(this.state.pos);\n    let out;\n    ++this.state.pos;\n\n    if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {\n      ++this.state.pos;\n      out = normalizeCRLF ? \"\\n\" : \"\\r\\n\";\n    } else {\n      out = String.fromCharCode(ch);\n    }\n\n    ++this.state.curLine;\n    this.state.lineStart = this.state.pos;\n    return out;\n  }\n\n  jsxReadString(quote) {\n    let out = \"\";\n    let chunkStart = ++this.state.pos;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(Errors.UnterminatedString, {\n          at: this.state.startLoc\n        });\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote) break;\n\n      if (ch === 38) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadEntity();\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadNewLine(false);\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n\n    out += this.input.slice(chunkStart, this.state.pos++);\n    return this.finishToken(129, out);\n  }\n\n  jsxReadEntity() {\n    const startPos = ++this.state.pos;\n\n    if (this.codePointAtPos(this.state.pos) === 35) {\n      ++this.state.pos;\n      let radix = 10;\n\n      if (this.codePointAtPos(this.state.pos) === 120) {\n        radix = 16;\n        ++this.state.pos;\n      }\n\n      const codePoint = this.readInt(radix, undefined, false, \"bail\");\n\n      if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {\n        ++this.state.pos;\n        return String.fromCodePoint(codePoint);\n      }\n    } else {\n      let count = 0;\n      let semi = false;\n\n      while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) == 59)) {\n        ++this.state.pos;\n      }\n\n      if (semi) {\n        const desc = this.input.slice(startPos, this.state.pos);\n        const entity = entities[desc];\n        ++this.state.pos;\n\n        if (entity) {\n          return entity;\n        }\n      }\n    }\n\n    this.state.pos = startPos;\n    return \"&\";\n  }\n\n  jsxReadWord() {\n    let ch;\n    const start = this.state.pos;\n\n    do {\n      ch = this.input.charCodeAt(++this.state.pos);\n    } while (isIdentifierChar(ch) || ch === 45);\n\n    return this.finishToken(136, this.input.slice(start, this.state.pos));\n  }\n\n  jsxParseIdentifier() {\n    const node = this.startNode();\n\n    if (this.match(136)) {\n      node.name = this.state.value;\n    } else if (tokenIsKeyword(this.state.type)) {\n      node.name = tokenLabelName(this.state.type);\n    } else {\n      this.unexpected();\n    }\n\n    this.next();\n    return this.finishNode(node, \"JSXIdentifier\");\n  }\n\n  jsxParseNamespacedName() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const name = this.jsxParseIdentifier();\n    if (!this.eat(14)) return name;\n    const node = this.startNodeAt(startPos, startLoc);\n    node.namespace = name;\n    node.name = this.jsxParseIdentifier();\n    return this.finishNode(node, \"JSXNamespacedName\");\n  }\n\n  jsxParseElementName() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let node = this.jsxParseNamespacedName();\n\n    if (node.type === \"JSXNamespacedName\") {\n      return node;\n    }\n\n    while (this.eat(16)) {\n      const newNode = this.startNodeAt(startPos, startLoc);\n      newNode.object = node;\n      newNode.property = this.jsxParseIdentifier();\n      node = this.finishNode(newNode, \"JSXMemberExpression\");\n    }\n\n    return node;\n  }\n\n  jsxParseAttributeValue() {\n    let node;\n\n    switch (this.state.type) {\n      case 5:\n        node = this.startNode();\n        this.setContext(types.brace);\n        this.next();\n        node = this.jsxParseExpressionContainer(node, types.j_oTag);\n\n        if (node.expression.type === \"JSXEmptyExpression\") {\n          this.raise(JsxErrors.AttributeIsEmpty, {\n            at: node\n          });\n        }\n\n        return node;\n\n      case 138:\n      case 129:\n        return this.parseExprAtom();\n\n      default:\n        throw this.raise(JsxErrors.UnsupportedJsxValue, {\n          at: this.state.startLoc\n        });\n    }\n  }\n\n  jsxParseEmptyExpression() {\n    const node = this.startNodeAt(this.state.lastTokEndLoc.index, this.state.lastTokEndLoc);\n    return this.finishNodeAt(node, \"JSXEmptyExpression\", this.state.startLoc);\n  }\n\n  jsxParseSpreadChild(node) {\n    this.next();\n    node.expression = this.parseExpression();\n    this.setContext(types.j_oTag);\n    this.state.canStartJSXElement = true;\n    this.expect(8);\n    return this.finishNode(node, \"JSXSpreadChild\");\n  }\n\n  jsxParseExpressionContainer(node, previousContext) {\n    if (this.match(8)) {\n      node.expression = this.jsxParseEmptyExpression();\n    } else {\n      const expression = this.parseExpression();\n      node.expression = expression;\n    }\n\n    this.setContext(previousContext);\n    this.state.canStartJSXElement = true;\n    this.expect(8);\n    return this.finishNode(node, \"JSXExpressionContainer\");\n  }\n\n  jsxParseAttribute() {\n    const node = this.startNode();\n\n    if (this.match(5)) {\n      this.setContext(types.brace);\n      this.next();\n      this.expect(21);\n      node.argument = this.parseMaybeAssignAllowIn();\n      this.setContext(types.j_oTag);\n      this.state.canStartJSXElement = true;\n      this.expect(8);\n      return this.finishNode(node, \"JSXSpreadAttribute\");\n    }\n\n    node.name = this.jsxParseNamespacedName();\n    node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;\n    return this.finishNode(node, \"JSXAttribute\");\n  }\n\n  jsxParseOpeningElementAt(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n\n    if (this.eat(139)) {\n      return this.finishNode(node, \"JSXOpeningFragment\");\n    }\n\n    node.name = this.jsxParseElementName();\n    return this.jsxParseOpeningElementAfterName(node);\n  }\n\n  jsxParseOpeningElementAfterName(node) {\n    const attributes = [];\n\n    while (!this.match(56) && !this.match(139)) {\n      attributes.push(this.jsxParseAttribute());\n    }\n\n    node.attributes = attributes;\n    node.selfClosing = this.eat(56);\n    this.expect(139);\n    return this.finishNode(node, \"JSXOpeningElement\");\n  }\n\n  jsxParseClosingElementAt(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n\n    if (this.eat(139)) {\n      return this.finishNode(node, \"JSXClosingFragment\");\n    }\n\n    node.name = this.jsxParseElementName();\n    this.expect(139);\n    return this.finishNode(node, \"JSXClosingElement\");\n  }\n\n  jsxParseElementAt(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n    const children = [];\n    const openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);\n    let closingElement = null;\n\n    if (!openingElement.selfClosing) {\n      contents: for (;;) {\n        switch (this.state.type) {\n          case 138:\n            startPos = this.state.start;\n            startLoc = this.state.startLoc;\n            this.next();\n\n            if (this.eat(56)) {\n              closingElement = this.jsxParseClosingElementAt(startPos, startLoc);\n              break contents;\n            }\n\n            children.push(this.jsxParseElementAt(startPos, startLoc));\n            break;\n\n          case 137:\n            children.push(this.parseExprAtom());\n            break;\n\n          case 5:\n            {\n              const node = this.startNode();\n              this.setContext(types.brace);\n              this.next();\n\n              if (this.match(21)) {\n                children.push(this.jsxParseSpreadChild(node));\n              } else {\n                children.push(this.jsxParseExpressionContainer(node, types.j_expr));\n              }\n\n              break;\n            }\n\n          default:\n            throw this.unexpected();\n        }\n      }\n\n      if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {\n        this.raise(JsxErrors.MissingClosingTagFragment, {\n          at: closingElement\n        });\n      } else if (!isFragment(openingElement) && isFragment(closingElement)) {\n        this.raise(JsxErrors.MissingClosingTagElement, {\n          at: closingElement,\n          openingTagName: getQualifiedJSXName(openingElement.name)\n        });\n      } else if (!isFragment(openingElement) && !isFragment(closingElement)) {\n        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n          this.raise(JsxErrors.MissingClosingTagElement, {\n            at: closingElement,\n            openingTagName: getQualifiedJSXName(openingElement.name)\n          });\n        }\n      }\n    }\n\n    if (isFragment(openingElement)) {\n      node.openingFragment = openingElement;\n      node.closingFragment = closingElement;\n    } else {\n      node.openingElement = openingElement;\n      node.closingElement = closingElement;\n    }\n\n    node.children = children;\n\n    if (this.match(47)) {\n      throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, {\n        at: this.state.startLoc\n      });\n    }\n\n    return isFragment(openingElement) ? this.finishNode(node, \"JSXFragment\") : this.finishNode(node, \"JSXElement\");\n  }\n\n  jsxParseElement() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    this.next();\n    return this.jsxParseElementAt(startPos, startLoc);\n  }\n\n  setContext(newContext) {\n    const {\n      context\n    } = this.state;\n    context[context.length - 1] = newContext;\n  }\n\n  parseExprAtom(refExpressionErrors) {\n    if (this.match(137)) {\n      return this.parseLiteral(this.state.value, \"JSXText\");\n    } else if (this.match(138)) {\n      return this.jsxParseElement();\n    } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {\n      this.replaceToken(138);\n      return this.jsxParseElement();\n    } else {\n      return super.parseExprAtom(refExpressionErrors);\n    }\n  }\n\n  skipSpace() {\n    const curContext = this.curContext();\n    if (!curContext.preserveSpace) super.skipSpace();\n  }\n\n  getTokenFromCode(code) {\n    const context = this.curContext();\n\n    if (context === types.j_expr) {\n      return this.jsxReadToken();\n    }\n\n    if (context === types.j_oTag || context === types.j_cTag) {\n      if (isIdentifierStart(code)) {\n        return this.jsxReadWord();\n      }\n\n      if (code === 62) {\n        ++this.state.pos;\n        return this.finishToken(139);\n      }\n\n      if ((code === 34 || code === 39) && context === types.j_oTag) {\n        return this.jsxReadString(code);\n      }\n    }\n\n    if (code === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {\n      ++this.state.pos;\n      return this.finishToken(138);\n    }\n\n    return super.getTokenFromCode(code);\n  }\n\n  updateContext(prevType) {\n    const {\n      context,\n      type\n    } = this.state;\n\n    if (type === 56 && prevType === 138) {\n      context.splice(-2, 2, types.j_cTag);\n      this.state.canStartJSXElement = false;\n    } else if (type === 138) {\n      context.push(types.j_oTag);\n    } else if (type === 139) {\n      const out = context[context.length - 1];\n\n      if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {\n        context.pop();\n        this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;\n      } else {\n        this.setContext(types.j_expr);\n        this.state.canStartJSXElement = true;\n      }\n    } else {\n      this.state.canStartJSXElement = tokenComesBeforeExpression(type);\n    }\n  }\n\n});\n\nclass TypeScriptScope extends Scope {\n  constructor(...args) {\n    super(...args);\n    this.types = new Set();\n    this.enums = new Set();\n    this.constEnums = new Set();\n    this.classes = new Set();\n    this.exportOnlyBindings = new Set();\n  }\n\n}\n\nclass TypeScriptScopeHandler extends ScopeHandler {\n  createScope(flags) {\n    return new TypeScriptScope(flags);\n  }\n\n  declareName(name, bindingType, loc) {\n    const scope = this.currentScope();\n\n    if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {\n      this.maybeExportDefined(scope, name);\n      scope.exportOnlyBindings.add(name);\n      return;\n    }\n\n    super.declareName(...arguments);\n\n    if (bindingType & BIND_KIND_TYPE) {\n      if (!(bindingType & BIND_KIND_VALUE)) {\n        this.checkRedeclarationInScope(scope, name, bindingType, loc);\n        this.maybeExportDefined(scope, name);\n      }\n\n      scope.types.add(name);\n    }\n\n    if (bindingType & BIND_FLAGS_TS_ENUM) scope.enums.add(name);\n    if (bindingType & BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.add(name);\n    if (bindingType & BIND_FLAGS_CLASS) scope.classes.add(name);\n  }\n\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (scope.enums.has(name)) {\n      if (bindingType & BIND_FLAGS_TS_ENUM) {\n        const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);\n        const wasConst = scope.constEnums.has(name);\n        return isConst !== wasConst;\n      }\n\n      return true;\n    }\n\n    if (bindingType & BIND_FLAGS_CLASS && scope.classes.has(name)) {\n      if (scope.lexical.has(name)) {\n        return !!(bindingType & BIND_KIND_VALUE);\n      } else {\n        return false;\n      }\n    }\n\n    if (bindingType & BIND_KIND_TYPE && scope.types.has(name)) {\n      return true;\n    }\n\n    return super.isRedeclaredInScope(...arguments);\n  }\n\n  checkLocalExport(id) {\n    const topLevelScope = this.scopeStack[0];\n    const {\n      name\n    } = id;\n\n    if (!topLevelScope.types.has(name) && !topLevelScope.exportOnlyBindings.has(name)) {\n      super.checkLocalExport(id);\n    }\n  }\n\n}\n\nconst getOwn$1 = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];\n\nfunction nonNull(x) {\n  if (x == null) {\n    throw new Error(`Unexpected ${x} value.`);\n  }\n\n  return x;\n}\n\nfunction assert(x) {\n  if (!x) {\n    throw new Error(\"Assert fail\");\n  }\n}\n\nfunction tsTokenCanStartExpression(token) {\n  return tokenCanStartExpression(token) || tokenIsBinaryOperator(token);\n}\n\nconst TSErrors = ParseErrorEnum`typescript`(_ => ({\n  AbstractMethodHasImplementation: _(({\n    methodName\n  }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`),\n  AbstractPropertyHasInitializer: _(({\n    propertyName\n  }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`),\n  AccesorCannotDeclareThisParameter: _(\"'get' and 'set' accessors cannot declare 'this' parameters.\"),\n  AccesorCannotHaveTypeParameters: _(\"An accessor cannot have type parameters.\"),\n  CannotFindName: _(({\n    name\n  }) => `Cannot find name '${name}'.`),\n  ClassMethodHasDeclare: _(\"Class methods cannot have the 'declare' modifier.\"),\n  ClassMethodHasReadonly: _(\"Class methods cannot have the 'readonly' modifier.\"),\n  ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: _(\"A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.\"),\n  ConstructorHasTypeParameters: _(\"Type parameters cannot appear on a constructor declaration.\"),\n  DeclareAccessor: _(({\n    kind\n  }) => `'declare' is not allowed in ${kind}ters.`),\n  DeclareClassFieldHasInitializer: _(\"Initializers are not allowed in ambient contexts.\"),\n  DeclareFunctionHasImplementation: _(\"An implementation cannot be declared in ambient contexts.\"),\n  DuplicateAccessibilityModifier: _(({\n    modifier\n  }) => `Accessibility modifier already seen.`),\n  DuplicateModifier: _(({\n    modifier\n  }) => `Duplicate modifier: '${modifier}'.`),\n  EmptyHeritageClauseType: _(({\n    token\n  }) => `'${token}' list cannot be empty.`),\n  EmptyTypeArguments: _(\"Type argument list cannot be empty.\"),\n  EmptyTypeParameters: _(\"Type parameter list cannot be empty.\"),\n  ExpectedAmbientAfterExportDeclare: _(\"'export declare' must be followed by an ambient declaration.\"),\n  ImportAliasHasImportType: _(\"An import alias can not use 'import type'.\"),\n  IncompatibleModifiers: _(({\n    modifiers\n  }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`),\n  IndexSignatureHasAbstract: _(\"Index signatures cannot have the 'abstract' modifier.\"),\n  IndexSignatureHasAccessibility: _(({\n    modifier\n  }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`),\n  IndexSignatureHasDeclare: _(\"Index signatures cannot have the 'declare' modifier.\"),\n  IndexSignatureHasOverride: _(\"'override' modifier cannot appear on an index signature.\"),\n  IndexSignatureHasStatic: _(\"Index signatures cannot have the 'static' modifier.\"),\n  InitializerNotAllowedInAmbientContext: _(\"Initializers are not allowed in ambient contexts.\"),\n  InvalidModifierOnTypeMember: _(({\n    modifier\n  }) => `'${modifier}' modifier cannot appear on a type member.`),\n  InvalidModifierOnTypeParameter: _(({\n    modifier\n  }) => `'${modifier}' modifier cannot appear on a type parameter.`),\n  InvalidModifierOnTypeParameterPositions: _(({\n    modifier\n  }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`),\n  InvalidModifiersOrder: _(({\n    orderedModifiers\n  }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`),\n  InvalidTupleMemberLabel: _(\"Tuple members must be labeled with a simple identifier.\"),\n  MissingInterfaceName: _(\"'interface' declarations must be followed by an identifier.\"),\n  MixedLabeledAndUnlabeledElements: _(\"Tuple members must all have names or all not have names.\"),\n  NonAbstractClassHasAbstractMethod: _(\"Abstract methods can only appear within an abstract class.\"),\n  NonClassMethodPropertyHasAbstractModifer: _(\"'abstract' modifier can only appear on a class, method, or property declaration.\"),\n  OptionalTypeBeforeRequired: _(\"A required element cannot follow an optional element.\"),\n  OverrideNotInSubClass: _(\"This member cannot have an 'override' modifier because its containing class does not extend another class.\"),\n  PatternIsOptional: _(\"A binding pattern parameter cannot be optional in an implementation signature.\"),\n  PrivateElementHasAbstract: _(\"Private elements cannot have the 'abstract' modifier.\"),\n  PrivateElementHasAccessibility: _(({\n    modifier\n  }) => `Private elements cannot have an accessibility modifier ('${modifier}').`),\n  ReadonlyForMethodSignature: _(\"'readonly' modifier can only appear on a property declaration or index signature.\"),\n  ReservedArrowTypeParam: _(\"This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.\"),\n  ReservedTypeAssertion: _(\"This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.\"),\n  SetAccesorCannotHaveOptionalParameter: _(\"A 'set' accessor cannot have an optional parameter.\"),\n  SetAccesorCannotHaveRestParameter: _(\"A 'set' accessor cannot have rest parameter.\"),\n  SetAccesorCannotHaveReturnType: _(\"A 'set' accessor cannot have a return type annotation.\"),\n  SingleTypeParameterWithoutTrailingComma: _(({\n    typeParameterName\n  }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`),\n  StaticBlockCannotHaveModifier: _(\"Static class blocks cannot have any modifier.\"),\n  TypeAnnotationAfterAssign: _(\"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\"),\n  TypeImportCannotSpecifyDefaultAndNamed: _(\"A type-only import can specify a default import or named bindings, but not both.\"),\n  TypeModifierIsUsedInTypeExports: _(\"The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.\"),\n  TypeModifierIsUsedInTypeImports: _(\"The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.\"),\n  UnexpectedParameterModifier: _(\"A parameter property is only allowed in a constructor implementation.\"),\n  UnexpectedReadonly: _(\"'readonly' type modifier is only permitted on array and tuple literal types.\"),\n  UnexpectedTypeAnnotation: _(\"Did not expect a type annotation here.\"),\n  UnexpectedTypeCastInParameter: _(\"Unexpected type cast in parameter position.\"),\n  UnsupportedImportTypeArgument: _(\"Argument in a type import must be a string literal.\"),\n  UnsupportedParameterPropertyKind: _(\"A parameter property may not be declared using a binding pattern.\"),\n  UnsupportedSignatureParameterKind: _(({\n    type\n  }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`)\n}));\n\nfunction keywordTypeFromName(value) {\n  switch (value) {\n    case \"any\":\n      return \"TSAnyKeyword\";\n\n    case \"boolean\":\n      return \"TSBooleanKeyword\";\n\n    case \"bigint\":\n      return \"TSBigIntKeyword\";\n\n    case \"never\":\n      return \"TSNeverKeyword\";\n\n    case \"number\":\n      return \"TSNumberKeyword\";\n\n    case \"object\":\n      return \"TSObjectKeyword\";\n\n    case \"string\":\n      return \"TSStringKeyword\";\n\n    case \"symbol\":\n      return \"TSSymbolKeyword\";\n\n    case \"undefined\":\n      return \"TSUndefinedKeyword\";\n\n    case \"unknown\":\n      return \"TSUnknownKeyword\";\n\n    default:\n      return undefined;\n  }\n}\n\nfunction tsIsAccessModifier(modifier) {\n  return modifier === \"private\" || modifier === \"public\" || modifier === \"protected\";\n}\n\nfunction tsIsVarianceAnnotations(modifier) {\n  return modifier === \"in\" || modifier === \"out\";\n}\n\nvar typescript = (superClass => class extends superClass {\n  getScopeHandler() {\n    return TypeScriptScopeHandler;\n  }\n\n  tsIsIdentifier() {\n    return tokenIsIdentifier(this.state.type);\n  }\n\n  tsTokenCanFollowModifier() {\n    return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(134) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();\n  }\n\n  tsNextTokenCanFollowModifier() {\n    this.next();\n    return this.tsTokenCanFollowModifier();\n  }\n\n  tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {\n    if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58) {\n      return undefined;\n    }\n\n    const modifier = this.state.value;\n\n    if (allowedModifiers.indexOf(modifier) !== -1) {\n      if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {\n        return undefined;\n      }\n\n      if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {\n        return modifier;\n      }\n    }\n\n    return undefined;\n  }\n\n  tsParseModifiers({\n    modified,\n    allowedModifiers,\n    disallowedModifiers,\n    stopOnStartOfClassStaticBlock,\n    errorTemplate = TSErrors.InvalidModifierOnTypeMember\n  }) {\n    const enforceOrder = (loc, modifier, before, after) => {\n      if (modifier === before && modified[after]) {\n        this.raise(TSErrors.InvalidModifiersOrder, {\n          at: loc,\n          orderedModifiers: [before, after]\n        });\n      }\n    };\n\n    const incompatible = (loc, modifier, mod1, mod2) => {\n      if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {\n        this.raise(TSErrors.IncompatibleModifiers, {\n          at: loc,\n          modifiers: [mod1, mod2]\n        });\n      }\n    };\n\n    for (;;) {\n      const {\n        startLoc\n      } = this.state;\n      const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);\n      if (!modifier) break;\n\n      if (tsIsAccessModifier(modifier)) {\n        if (modified.accessibility) {\n          this.raise(TSErrors.DuplicateAccessibilityModifier, {\n            at: startLoc,\n            modifier\n          });\n        } else {\n          enforceOrder(startLoc, modifier, modifier, \"override\");\n          enforceOrder(startLoc, modifier, modifier, \"static\");\n          enforceOrder(startLoc, modifier, modifier, \"readonly\");\n          modified.accessibility = modifier;\n        }\n      } else if (tsIsVarianceAnnotations(modifier)) {\n        if (modified[modifier]) {\n          this.raise(TSErrors.DuplicateModifier, {\n            at: startLoc,\n            modifier\n          });\n        }\n\n        modified[modifier] = true;\n        enforceOrder(startLoc, modifier, \"in\", \"out\");\n      } else {\n        if (Object.hasOwnProperty.call(modified, modifier)) {\n          this.raise(TSErrors.DuplicateModifier, {\n            at: startLoc,\n            modifier\n          });\n        } else {\n          enforceOrder(startLoc, modifier, \"static\", \"readonly\");\n          enforceOrder(startLoc, modifier, \"static\", \"override\");\n          enforceOrder(startLoc, modifier, \"override\", \"readonly\");\n          enforceOrder(startLoc, modifier, \"abstract\", \"override\");\n          incompatible(startLoc, modifier, \"declare\", \"override\");\n          incompatible(startLoc, modifier, \"static\", \"abstract\");\n        }\n\n        modified[modifier] = true;\n      }\n\n      if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {\n        this.raise(errorTemplate, {\n          at: startLoc,\n          modifier\n        });\n      }\n    }\n  }\n\n  tsIsListTerminator(kind) {\n    switch (kind) {\n      case \"EnumMembers\":\n      case \"TypeMembers\":\n        return this.match(8);\n\n      case \"HeritageClauseElement\":\n        return this.match(5);\n\n      case \"TupleElementTypes\":\n        return this.match(3);\n\n      case \"TypeParametersOrArguments\":\n        return this.match(48);\n    }\n\n    throw new Error(\"Unreachable\");\n  }\n\n  tsParseList(kind, parseElement) {\n    const result = [];\n\n    while (!this.tsIsListTerminator(kind)) {\n      result.push(parseElement());\n    }\n\n    return result;\n  }\n\n  tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {\n    return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));\n  }\n\n  tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {\n    const result = [];\n    let trailingCommaPos = -1;\n\n    for (;;) {\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n\n      trailingCommaPos = -1;\n      const element = parseElement();\n\n      if (element == null) {\n        return undefined;\n      }\n\n      result.push(element);\n\n      if (this.eat(12)) {\n        trailingCommaPos = this.state.lastTokStart;\n        continue;\n      }\n\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n\n      if (expectSuccess) {\n        this.expect(12);\n      }\n\n      return undefined;\n    }\n\n    if (refTrailingCommaPos) {\n      refTrailingCommaPos.value = trailingCommaPos;\n    }\n\n    return result;\n  }\n\n  tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {\n    if (!skipFirstToken) {\n      if (bracket) {\n        this.expect(0);\n      } else {\n        this.expect(47);\n      }\n    }\n\n    const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);\n\n    if (bracket) {\n      this.expect(3);\n    } else {\n      this.expect(48);\n    }\n\n    return result;\n  }\n\n  tsParseImportType() {\n    const node = this.startNode();\n    this.expect(83);\n    this.expect(10);\n\n    if (!this.match(129)) {\n      this.raise(TSErrors.UnsupportedImportTypeArgument, {\n        at: this.state.startLoc\n      });\n    }\n\n    node.argument = this.parseExprAtom();\n    this.expect(11);\n\n    if (this.eat(16)) {\n      node.qualifier = this.tsParseEntityName();\n    }\n\n    if (this.match(47)) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n\n    return this.finishNode(node, \"TSImportType\");\n  }\n\n  tsParseEntityName(allowReservedWords = true) {\n    let entity = this.parseIdentifier(allowReservedWords);\n\n    while (this.eat(16)) {\n      const node = this.startNodeAtNode(entity);\n      node.left = entity;\n      node.right = this.parseIdentifier(allowReservedWords);\n      entity = this.finishNode(node, \"TSQualifiedName\");\n    }\n\n    return entity;\n  }\n\n  tsParseTypeReference() {\n    const node = this.startNode();\n    node.typeName = this.tsParseEntityName();\n\n    if (!this.hasPrecedingLineBreak() && this.match(47)) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n\n    return this.finishNode(node, \"TSTypeReference\");\n  }\n\n  tsParseThisTypePredicate(lhs) {\n    this.next();\n    const node = this.startNodeAtNode(lhs);\n    node.parameterName = lhs;\n    node.typeAnnotation = this.tsParseTypeAnnotation(false);\n    node.asserts = false;\n    return this.finishNode(node, \"TSTypePredicate\");\n  }\n\n  tsParseThisTypeNode() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"TSThisType\");\n  }\n\n  tsParseTypeQuery() {\n    const node = this.startNode();\n    this.expect(87);\n\n    if (this.match(83)) {\n      node.exprName = this.tsParseImportType();\n    } else {\n      node.exprName = this.tsParseEntityName();\n    }\n\n    if (!this.hasPrecedingLineBreak() && this.match(47)) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n\n    return this.finishNode(node, \"TSTypeQuery\");\n  }\n\n  tsParseInOutModifiers(node) {\n    this.tsParseModifiers({\n      modified: node,\n      allowedModifiers: [\"in\", \"out\"],\n      disallowedModifiers: [\"public\", \"private\", \"protected\", \"readonly\", \"declare\", \"abstract\", \"override\"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameter\n    });\n  }\n\n  tsParseNoneModifiers(node) {\n    this.tsParseModifiers({\n      modified: node,\n      allowedModifiers: [],\n      disallowedModifiers: [\"in\", \"out\"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions\n    });\n  }\n\n  tsParseTypeParameter(parseModifiers = this.tsParseNoneModifiers.bind(this)) {\n    const node = this.startNode();\n    parseModifiers(node);\n    node.name = this.tsParseTypeParameterName();\n    node.constraint = this.tsEatThenParseType(81);\n    node.default = this.tsEatThenParseType(29);\n    return this.finishNode(node, \"TSTypeParameter\");\n  }\n\n  tsTryParseTypeParameters(parseModifiers) {\n    if (this.match(47)) {\n      return this.tsParseTypeParameters(parseModifiers);\n    }\n  }\n\n  tsParseTypeParameters(parseModifiers) {\n    const node = this.startNode();\n\n    if (this.match(47) || this.match(138)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n\n    const refTrailingCommaPos = {\n      value: -1\n    };\n    node.params = this.tsParseBracketedList(\"TypeParametersOrArguments\", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);\n\n    if (node.params.length === 0) {\n      this.raise(TSErrors.EmptyTypeParameters, {\n        at: node\n      });\n    }\n\n    if (refTrailingCommaPos.value !== -1) {\n      this.addExtra(node, \"trailingComma\", refTrailingCommaPos.value);\n    }\n\n    return this.finishNode(node, \"TSTypeParameterDeclaration\");\n  }\n\n  tsTryNextParseConstantContext() {\n    if (this.lookahead().type !== 75) return null;\n    this.next();\n    const typeReference = this.tsParseTypeReference();\n\n    if (typeReference.typeParameters) {\n      this.raise(TSErrors.CannotFindName, {\n        at: typeReference.typeName,\n        name: \"const\"\n      });\n    }\n\n    return typeReference;\n  }\n\n  tsFillSignature(returnToken, signature) {\n    const returnTokenRequired = returnToken === 19;\n    const paramsKey = \"parameters\";\n    const returnTypeKey = \"typeAnnotation\";\n    signature.typeParameters = this.tsTryParseTypeParameters();\n    this.expect(10);\n    signature[paramsKey] = this.tsParseBindingListForSignature();\n\n    if (returnTokenRequired) {\n      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    } else if (this.match(returnToken)) {\n      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    }\n  }\n\n  tsParseBindingListForSignature() {\n    return this.parseBindingList(11, 41).map(pattern => {\n      if (pattern.type !== \"Identifier\" && pattern.type !== \"RestElement\" && pattern.type !== \"ObjectPattern\" && pattern.type !== \"ArrayPattern\") {\n        this.raise(TSErrors.UnsupportedSignatureParameterKind, {\n          at: pattern,\n          type: pattern.type\n        });\n      }\n\n      return pattern;\n    });\n  }\n\n  tsParseTypeMemberSemicolon() {\n    if (!this.eat(12) && !this.isLineTerminator()) {\n      this.expect(13);\n    }\n  }\n\n  tsParseSignatureMember(kind, node) {\n    this.tsFillSignature(14, node);\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, kind);\n  }\n\n  tsIsUnambiguouslyIndexSignature() {\n    this.next();\n\n    if (tokenIsIdentifier(this.state.type)) {\n      this.next();\n      return this.match(14);\n    }\n\n    return false;\n  }\n\n  tsTryParseIndexSignature(node) {\n    if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {\n      return undefined;\n    }\n\n    this.expect(0);\n    const id = this.parseIdentifier();\n    id.typeAnnotation = this.tsParseTypeAnnotation();\n    this.resetEndLocation(id);\n    this.expect(3);\n    node.parameters = [id];\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, \"TSIndexSignature\");\n  }\n\n  tsParsePropertyOrMethodSignature(node, readonly) {\n    if (this.eat(17)) node.optional = true;\n    const nodeAny = node;\n\n    if (this.match(10) || this.match(47)) {\n      if (readonly) {\n        this.raise(TSErrors.ReadonlyForMethodSignature, {\n          at: node\n        });\n      }\n\n      const method = nodeAny;\n\n      if (method.kind && this.match(47)) {\n        this.raise(TSErrors.AccesorCannotHaveTypeParameters, {\n          at: this.state.curPosition()\n        });\n      }\n\n      this.tsFillSignature(14, method);\n      this.tsParseTypeMemberSemicolon();\n      const paramsKey = \"parameters\";\n      const returnTypeKey = \"typeAnnotation\";\n\n      if (method.kind === \"get\") {\n        if (method[paramsKey].length > 0) {\n          this.raise(Errors.BadGetterArity, {\n            at: this.state.curPosition()\n          });\n\n          if (this.isThisParam(method[paramsKey][0])) {\n            this.raise(TSErrors.AccesorCannotDeclareThisParameter, {\n              at: this.state.curPosition()\n            });\n          }\n        }\n      } else if (method.kind === \"set\") {\n        if (method[paramsKey].length !== 1) {\n          this.raise(Errors.BadSetterArity, {\n            at: this.state.curPosition()\n          });\n        } else {\n          const firstParameter = method[paramsKey][0];\n\n          if (this.isThisParam(firstParameter)) {\n            this.raise(TSErrors.AccesorCannotDeclareThisParameter, {\n              at: this.state.curPosition()\n            });\n          }\n\n          if (firstParameter.type === \"Identifier\" && firstParameter.optional) {\n            this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, {\n              at: this.state.curPosition()\n            });\n          }\n\n          if (firstParameter.type === \"RestElement\") {\n            this.raise(TSErrors.SetAccesorCannotHaveRestParameter, {\n              at: this.state.curPosition()\n            });\n          }\n        }\n\n        if (method[returnTypeKey]) {\n          this.raise(TSErrors.SetAccesorCannotHaveReturnType, {\n            at: method[returnTypeKey]\n          });\n        }\n      } else {\n        method.kind = \"method\";\n      }\n\n      return this.finishNode(method, \"TSMethodSignature\");\n    } else {\n      const property = nodeAny;\n      if (readonly) property.readonly = true;\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) property.typeAnnotation = type;\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(property, \"TSPropertySignature\");\n    }\n  }\n\n  tsParseTypeMember() {\n    const node = this.startNode();\n\n    if (this.match(10) || this.match(47)) {\n      return this.tsParseSignatureMember(\"TSCallSignatureDeclaration\", node);\n    }\n\n    if (this.match(77)) {\n      const id = this.startNode();\n      this.next();\n\n      if (this.match(10) || this.match(47)) {\n        return this.tsParseSignatureMember(\"TSConstructSignatureDeclaration\", node);\n      } else {\n        node.key = this.createIdentifier(id, \"new\");\n        return this.tsParsePropertyOrMethodSignature(node, false);\n      }\n    }\n\n    this.tsParseModifiers({\n      modified: node,\n      allowedModifiers: [\"readonly\"],\n      disallowedModifiers: [\"declare\", \"abstract\", \"private\", \"protected\", \"public\", \"static\", \"override\"]\n    });\n    const idx = this.tsTryParseIndexSignature(node);\n\n    if (idx) {\n      return idx;\n    }\n\n    this.parsePropertyName(node);\n\n    if (!node.computed && node.key.type === \"Identifier\" && (node.key.name === \"get\" || node.key.name === \"set\") && this.tsTokenCanFollowModifier()) {\n      node.kind = node.key.name;\n      this.parsePropertyName(node);\n    }\n\n    return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);\n  }\n\n  tsParseTypeLiteral() {\n    const node = this.startNode();\n    node.members = this.tsParseObjectTypeMembers();\n    return this.finishNode(node, \"TSTypeLiteral\");\n  }\n\n  tsParseObjectTypeMembers() {\n    this.expect(5);\n    const members = this.tsParseList(\"TypeMembers\", this.tsParseTypeMember.bind(this));\n    this.expect(8);\n    return members;\n  }\n\n  tsIsStartOfMappedType() {\n    this.next();\n\n    if (this.eat(53)) {\n      return this.isContextual(118);\n    }\n\n    if (this.isContextual(118)) {\n      this.next();\n    }\n\n    if (!this.match(0)) {\n      return false;\n    }\n\n    this.next();\n\n    if (!this.tsIsIdentifier()) {\n      return false;\n    }\n\n    this.next();\n    return this.match(58);\n  }\n\n  tsParseMappedTypeParameter() {\n    const node = this.startNode();\n    node.name = this.tsParseTypeParameterName();\n    node.constraint = this.tsExpectThenParseType(58);\n    return this.finishNode(node, \"TSTypeParameter\");\n  }\n\n  tsParseMappedType() {\n    const node = this.startNode();\n    this.expect(5);\n\n    if (this.match(53)) {\n      node.readonly = this.state.value;\n      this.next();\n      this.expectContextual(118);\n    } else if (this.eatContextual(118)) {\n      node.readonly = true;\n    }\n\n    this.expect(0);\n    node.typeParameter = this.tsParseMappedTypeParameter();\n    node.nameType = this.eatContextual(93) ? this.tsParseType() : null;\n    this.expect(3);\n\n    if (this.match(53)) {\n      node.optional = this.state.value;\n      this.next();\n      this.expect(17);\n    } else if (this.eat(17)) {\n      node.optional = true;\n    }\n\n    node.typeAnnotation = this.tsTryParseType();\n    this.semicolon();\n    this.expect(8);\n    return this.finishNode(node, \"TSMappedType\");\n  }\n\n  tsParseTupleType() {\n    const node = this.startNode();\n    node.elementTypes = this.tsParseBracketedList(\"TupleElementTypes\", this.tsParseTupleElementType.bind(this), true, false);\n    let seenOptionalElement = false;\n    let labeledElements = null;\n    node.elementTypes.forEach(elementNode => {\n      var _labeledElements;\n\n      let {\n        type\n      } = elementNode;\n\n      if (seenOptionalElement && type !== \"TSRestType\" && type !== \"TSOptionalType\" && !(type === \"TSNamedTupleMember\" && elementNode.optional)) {\n        this.raise(TSErrors.OptionalTypeBeforeRequired, {\n          at: elementNode\n        });\n      }\n\n      seenOptionalElement = seenOptionalElement || type === \"TSNamedTupleMember\" && elementNode.optional || type === \"TSOptionalType\";\n\n      if (type === \"TSRestType\") {\n        elementNode = elementNode.typeAnnotation;\n        type = elementNode.type;\n      }\n\n      const isLabeled = type === \"TSNamedTupleMember\";\n      labeledElements = (_labeledElements = labeledElements) != null ? _labeledElements : isLabeled;\n\n      if (labeledElements !== isLabeled) {\n        this.raise(TSErrors.MixedLabeledAndUnlabeledElements, {\n          at: elementNode\n        });\n      }\n    });\n    return this.finishNode(node, \"TSTupleType\");\n  }\n\n  tsParseTupleElementType() {\n    const {\n      start: startPos,\n      startLoc\n    } = this.state;\n    const rest = this.eat(21);\n    let type = this.tsParseType();\n    const optional = this.eat(17);\n    const labeled = this.eat(14);\n\n    if (labeled) {\n      const labeledNode = this.startNodeAtNode(type);\n      labeledNode.optional = optional;\n\n      if (type.type === \"TSTypeReference\" && !type.typeParameters && type.typeName.type === \"Identifier\") {\n        labeledNode.label = type.typeName;\n      } else {\n        this.raise(TSErrors.InvalidTupleMemberLabel, {\n          at: type\n        });\n        labeledNode.label = type;\n      }\n\n      labeledNode.elementType = this.tsParseType();\n      type = this.finishNode(labeledNode, \"TSNamedTupleMember\");\n    } else if (optional) {\n      const optionalTypeNode = this.startNodeAtNode(type);\n      optionalTypeNode.typeAnnotation = type;\n      type = this.finishNode(optionalTypeNode, \"TSOptionalType\");\n    }\n\n    if (rest) {\n      const restNode = this.startNodeAt(startPos, startLoc);\n      restNode.typeAnnotation = type;\n      type = this.finishNode(restNode, \"TSRestType\");\n    }\n\n    return type;\n  }\n\n  tsParseParenthesizedType() {\n    const node = this.startNode();\n    this.expect(10);\n    node.typeAnnotation = this.tsParseType();\n    this.expect(11);\n    return this.finishNode(node, \"TSParenthesizedType\");\n  }\n\n  tsParseFunctionOrConstructorType(type, abstract) {\n    const node = this.startNode();\n\n    if (type === \"TSConstructorType\") {\n      node.abstract = !!abstract;\n      if (abstract) this.next();\n      this.next();\n    }\n\n    this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node));\n    return this.finishNode(node, type);\n  }\n\n  tsParseLiteralTypeNode() {\n    const node = this.startNode();\n\n    node.literal = (() => {\n      switch (this.state.type) {\n        case 130:\n        case 131:\n        case 129:\n        case 85:\n        case 86:\n          return this.parseExprAtom();\n\n        default:\n          throw this.unexpected();\n      }\n    })();\n\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n\n  tsParseTemplateLiteralType() {\n    const node = this.startNode();\n    node.literal = this.parseTemplate(false);\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n\n  parseTemplateSubstitution() {\n    if (this.state.inType) return this.tsParseType();\n    return super.parseTemplateSubstitution();\n  }\n\n  tsParseThisTypeOrThisTypePredicate() {\n    const thisKeyword = this.tsParseThisTypeNode();\n\n    if (this.isContextual(113) && !this.hasPrecedingLineBreak()) {\n      return this.tsParseThisTypePredicate(thisKeyword);\n    } else {\n      return thisKeyword;\n    }\n  }\n\n  tsParseNonArrayType() {\n    switch (this.state.type) {\n      case 129:\n      case 130:\n      case 131:\n      case 85:\n      case 86:\n        return this.tsParseLiteralTypeNode();\n\n      case 53:\n        if (this.state.value === \"-\") {\n          const node = this.startNode();\n          const nextToken = this.lookahead();\n\n          if (nextToken.type !== 130 && nextToken.type !== 131) {\n            throw this.unexpected();\n          }\n\n          node.literal = this.parseMaybeUnary();\n          return this.finishNode(node, \"TSLiteralType\");\n        }\n\n        break;\n\n      case 78:\n        return this.tsParseThisTypeOrThisTypePredicate();\n\n      case 87:\n        return this.tsParseTypeQuery();\n\n      case 83:\n        return this.tsParseImportType();\n\n      case 5:\n        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();\n\n      case 0:\n        return this.tsParseTupleType();\n\n      case 10:\n        return this.tsParseParenthesizedType();\n\n      case 25:\n      case 24:\n        return this.tsParseTemplateLiteralType();\n\n      default:\n        {\n          const {\n            type\n          } = this.state;\n\n          if (tokenIsIdentifier(type) || type === 88 || type === 84) {\n            const nodeType = type === 88 ? \"TSVoidKeyword\" : type === 84 ? \"TSNullKeyword\" : keywordTypeFromName(this.state.value);\n\n            if (nodeType !== undefined && this.lookaheadCharCode() !== 46) {\n              const node = this.startNode();\n              this.next();\n              return this.finishNode(node, nodeType);\n            }\n\n            return this.tsParseTypeReference();\n          }\n        }\n    }\n\n    throw this.unexpected();\n  }\n\n  tsParseArrayTypeOrHigher() {\n    let type = this.tsParseNonArrayType();\n\n    while (!this.hasPrecedingLineBreak() && this.eat(0)) {\n      if (this.match(3)) {\n        const node = this.startNodeAtNode(type);\n        node.elementType = type;\n        this.expect(3);\n        type = this.finishNode(node, \"TSArrayType\");\n      } else {\n        const node = this.startNodeAtNode(type);\n        node.objectType = type;\n        node.indexType = this.tsParseType();\n        this.expect(3);\n        type = this.finishNode(node, \"TSIndexedAccessType\");\n      }\n    }\n\n    return type;\n  }\n\n  tsParseTypeOperator() {\n    const node = this.startNode();\n    const operator = this.state.value;\n    this.next();\n    node.operator = operator;\n    node.typeAnnotation = this.tsParseTypeOperatorOrHigher();\n\n    if (operator === \"readonly\") {\n      this.tsCheckTypeAnnotationForReadOnly(node);\n    }\n\n    return this.finishNode(node, \"TSTypeOperator\");\n  }\n\n  tsCheckTypeAnnotationForReadOnly(node) {\n    switch (node.typeAnnotation.type) {\n      case \"TSTupleType\":\n      case \"TSArrayType\":\n        return;\n\n      default:\n        this.raise(TSErrors.UnexpectedReadonly, {\n          at: node\n        });\n    }\n  }\n\n  tsParseInferType() {\n    const node = this.startNode();\n    this.expectContextual(112);\n    const typeParameter = this.startNode();\n    typeParameter.name = this.tsParseTypeParameterName();\n    typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());\n    node.typeParameter = this.finishNode(typeParameter, \"TSTypeParameter\");\n    return this.finishNode(node, \"TSInferType\");\n  }\n\n  tsParseConstraintForInferType() {\n    if (this.eat(81)) {\n      const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());\n\n      if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {\n        return constraint;\n      }\n    }\n  }\n\n  tsParseTypeOperatorOrHigher() {\n    const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;\n    return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(112) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());\n  }\n\n  tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {\n    const node = this.startNode();\n    const hasLeadingOperator = this.eat(operator);\n    const types = [];\n\n    do {\n      types.push(parseConstituentType());\n    } while (this.eat(operator));\n\n    if (types.length === 1 && !hasLeadingOperator) {\n      return types[0];\n    }\n\n    node.types = types;\n    return this.finishNode(node, kind);\n  }\n\n  tsParseIntersectionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSIntersectionType\", this.tsParseTypeOperatorOrHigher.bind(this), 45);\n  }\n\n  tsParseUnionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSUnionType\", this.tsParseIntersectionTypeOrHigher.bind(this), 43);\n  }\n\n  tsIsStartOfFunctionType() {\n    if (this.match(47)) {\n      return true;\n    }\n\n    return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));\n  }\n\n  tsSkipParameterStart() {\n    if (tokenIsIdentifier(this.state.type) || this.match(78)) {\n      this.next();\n      return true;\n    }\n\n    if (this.match(5)) {\n      const {\n        errors\n      } = this.state;\n      const previousErrorCount = errors.length;\n\n      try {\n        this.parseObjectLike(8, true);\n        return errors.length === previousErrorCount;\n      } catch (_unused) {\n        return false;\n      }\n    }\n\n    if (this.match(0)) {\n      this.next();\n      const {\n        errors\n      } = this.state;\n      const previousErrorCount = errors.length;\n\n      try {\n        this.parseBindingList(3, 93, true);\n        return errors.length === previousErrorCount;\n      } catch (_unused2) {\n        return false;\n      }\n    }\n\n    return false;\n  }\n\n  tsIsUnambiguouslyStartOfFunctionType() {\n    this.next();\n\n    if (this.match(11) || this.match(21)) {\n      return true;\n    }\n\n    if (this.tsSkipParameterStart()) {\n      if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {\n        return true;\n      }\n\n      if (this.match(11)) {\n        this.next();\n\n        if (this.match(19)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  tsParseTypeOrTypePredicateAnnotation(returnToken) {\n    return this.tsInType(() => {\n      const t = this.startNode();\n      this.expect(returnToken);\n      const node = this.startNode();\n      const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));\n\n      if (asserts && this.match(78)) {\n        let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();\n\n        if (thisTypePredicate.type === \"TSThisType\") {\n          node.parameterName = thisTypePredicate;\n          node.asserts = true;\n          node.typeAnnotation = null;\n          thisTypePredicate = this.finishNode(node, \"TSTypePredicate\");\n        } else {\n          this.resetStartLocationFromNode(thisTypePredicate, node);\n          thisTypePredicate.asserts = true;\n        }\n\n        t.typeAnnotation = thisTypePredicate;\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n\n      const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));\n\n      if (!typePredicateVariable) {\n        if (!asserts) {\n          return this.tsParseTypeAnnotation(false, t);\n        }\n\n        node.parameterName = this.parseIdentifier();\n        node.asserts = asserts;\n        node.typeAnnotation = null;\n        t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n\n      const type = this.tsParseTypeAnnotation(false);\n      node.parameterName = typePredicateVariable;\n      node.typeAnnotation = type;\n      node.asserts = asserts;\n      t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n      return this.finishNode(t, \"TSTypeAnnotation\");\n    });\n  }\n\n  tsTryParseTypeOrTypePredicateAnnotation() {\n    return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : undefined;\n  }\n\n  tsTryParseTypeAnnotation() {\n    return this.match(14) ? this.tsParseTypeAnnotation() : undefined;\n  }\n\n  tsTryParseType() {\n    return this.tsEatThenParseType(14);\n  }\n\n  tsParseTypePredicatePrefix() {\n    const id = this.parseIdentifier();\n\n    if (this.isContextual(113) && !this.hasPrecedingLineBreak()) {\n      this.next();\n      return id;\n    }\n  }\n\n  tsParseTypePredicateAsserts() {\n    if (this.state.type !== 106) {\n      return false;\n    }\n\n    const containsEsc = this.state.containsEsc;\n    this.next();\n\n    if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {\n      return false;\n    }\n\n    if (containsEsc) {\n      this.raise(Errors.InvalidEscapedReservedWord, {\n        at: this.state.lastTokStartLoc,\n        reservedWord: \"asserts\"\n      });\n    }\n\n    return true;\n  }\n\n  tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {\n    this.tsInType(() => {\n      if (eatColon) this.expect(14);\n      t.typeAnnotation = this.tsParseType();\n    });\n    return this.finishNode(t, \"TSTypeAnnotation\");\n  }\n\n  tsParseType() {\n    assert(this.state.inType);\n    const type = this.tsParseNonConditionalType();\n\n    if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {\n      return type;\n    }\n\n    const node = this.startNodeAtNode(type);\n    node.checkType = type;\n    node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());\n    this.expect(17);\n    node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());\n    this.expect(14);\n    node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());\n    return this.finishNode(node, \"TSConditionalType\");\n  }\n\n  isAbstractConstructorSignature() {\n    return this.isContextual(120) && this.lookahead().type === 77;\n  }\n\n  tsParseNonConditionalType() {\n    if (this.tsIsStartOfFunctionType()) {\n      return this.tsParseFunctionOrConstructorType(\"TSFunctionType\");\n    }\n\n    if (this.match(77)) {\n      return this.tsParseFunctionOrConstructorType(\"TSConstructorType\");\n    } else if (this.isAbstractConstructorSignature()) {\n      return this.tsParseFunctionOrConstructorType(\"TSConstructorType\", true);\n    }\n\n    return this.tsParseUnionTypeOrHigher();\n  }\n\n  tsParseTypeAssertion() {\n    if (this.getPluginOption(\"typescript\", \"disallowAmbiguousJSXLike\")) {\n      this.raise(TSErrors.ReservedTypeAssertion, {\n        at: this.state.startLoc\n      });\n    }\n\n    const node = this.startNode();\n\n    const _const = this.tsTryNextParseConstantContext();\n\n    node.typeAnnotation = _const || this.tsNextThenParseType();\n    this.expect(48);\n    node.expression = this.parseMaybeUnary();\n    return this.finishNode(node, \"TSTypeAssertion\");\n  }\n\n  tsParseHeritageClause(token) {\n    const originalStartLoc = this.state.startLoc;\n    const delimitedList = this.tsParseDelimitedList(\"HeritageClauseElement\", () => {\n      const node = this.startNode();\n      node.expression = this.tsParseEntityName();\n\n      if (this.match(47)) {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n\n      return this.finishNode(node, \"TSExpressionWithTypeArguments\");\n    });\n\n    if (!delimitedList.length) {\n      this.raise(TSErrors.EmptyHeritageClauseType, {\n        at: originalStartLoc,\n        token\n      });\n    }\n\n    return delimitedList;\n  }\n\n  tsParseInterfaceDeclaration(node, properties = {}) {\n    if (this.hasFollowingLineBreak()) return null;\n    this.expectContextual(125);\n    if (properties.declare) node.declare = true;\n\n    if (tokenIsIdentifier(this.state.type)) {\n      node.id = this.parseIdentifier();\n      this.checkIdentifier(node.id, BIND_TS_INTERFACE);\n    } else {\n      node.id = null;\n      this.raise(TSErrors.MissingInterfaceName, {\n        at: this.state.startLoc\n      });\n    }\n\n    node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));\n\n    if (this.eat(81)) {\n      node.extends = this.tsParseHeritageClause(\"extends\");\n    }\n\n    const body = this.startNode();\n    body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));\n    node.body = this.finishNode(body, \"TSInterfaceBody\");\n    return this.finishNode(node, \"TSInterfaceDeclaration\");\n  }\n\n  tsParseTypeAliasDeclaration(node) {\n    node.id = this.parseIdentifier();\n    this.checkIdentifier(node.id, BIND_TS_TYPE);\n    node.typeAnnotation = this.tsInType(() => {\n      node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));\n      this.expect(29);\n\n      if (this.isContextual(111) && this.lookahead().type !== 16) {\n        const node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"TSIntrinsicKeyword\");\n      }\n\n      return this.tsParseType();\n    });\n    this.semicolon();\n    return this.finishNode(node, \"TSTypeAliasDeclaration\");\n  }\n\n  tsInNoContext(cb) {\n    const oldContext = this.state.context;\n    this.state.context = [oldContext[0]];\n\n    try {\n      return cb();\n    } finally {\n      this.state.context = oldContext;\n    }\n  }\n\n  tsInType(cb) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n\n    try {\n      return cb();\n    } finally {\n      this.state.inType = oldInType;\n    }\n  }\n\n  tsInDisallowConditionalTypesContext(cb) {\n    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;\n    this.state.inDisallowConditionalTypesContext = true;\n\n    try {\n      return cb();\n    } finally {\n      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n    }\n  }\n\n  tsInAllowConditionalTypesContext(cb) {\n    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;\n    this.state.inDisallowConditionalTypesContext = false;\n\n    try {\n      return cb();\n    } finally {\n      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n    }\n  }\n\n  tsEatThenParseType(token) {\n    return !this.match(token) ? undefined : this.tsNextThenParseType();\n  }\n\n  tsExpectThenParseType(token) {\n    return this.tsDoThenParseType(() => this.expect(token));\n  }\n\n  tsNextThenParseType() {\n    return this.tsDoThenParseType(() => this.next());\n  }\n\n  tsDoThenParseType(cb) {\n    return this.tsInType(() => {\n      cb();\n      return this.tsParseType();\n    });\n  }\n\n  tsParseEnumMember() {\n    const node = this.startNode();\n    node.id = this.match(129) ? this.parseExprAtom() : this.parseIdentifier(true);\n\n    if (this.eat(29)) {\n      node.initializer = this.parseMaybeAssignAllowIn();\n    }\n\n    return this.finishNode(node, \"TSEnumMember\");\n  }\n\n  tsParseEnumDeclaration(node, properties = {}) {\n    if (properties.const) node.const = true;\n    if (properties.declare) node.declare = true;\n    this.expectContextual(122);\n    node.id = this.parseIdentifier();\n    this.checkIdentifier(node.id, node.const ? BIND_TS_CONST_ENUM : BIND_TS_ENUM);\n    this.expect(5);\n    node.members = this.tsParseDelimitedList(\"EnumMembers\", this.tsParseEnumMember.bind(this));\n    this.expect(8);\n    return this.finishNode(node, \"TSEnumDeclaration\");\n  }\n\n  tsParseModuleBlock() {\n    const node = this.startNode();\n    this.scope.enter(SCOPE_OTHER);\n    this.expect(5);\n    this.parseBlockOrModuleBlockBody(node.body = [], undefined, true, 8);\n    this.scope.exit();\n    return this.finishNode(node, \"TSModuleBlock\");\n  }\n\n  tsParseModuleOrNamespaceDeclaration(node, nested = false) {\n    node.id = this.parseIdentifier();\n\n    if (!nested) {\n      this.checkIdentifier(node.id, BIND_TS_NAMESPACE);\n    }\n\n    if (this.eat(16)) {\n      const inner = this.startNode();\n      this.tsParseModuleOrNamespaceDeclaration(inner, true);\n      node.body = inner;\n    } else {\n      this.scope.enter(SCOPE_TS_MODULE);\n      this.prodParam.enter(PARAM);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    }\n\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n\n  tsParseAmbientExternalModuleDeclaration(node) {\n    if (this.isContextual(109)) {\n      node.global = true;\n      node.id = this.parseIdentifier();\n    } else if (this.match(129)) {\n      node.id = this.parseExprAtom();\n    } else {\n      this.unexpected();\n    }\n\n    if (this.match(5)) {\n      this.scope.enter(SCOPE_TS_MODULE);\n      this.prodParam.enter(PARAM);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    } else {\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n\n  tsParseImportEqualsDeclaration(node, isExport) {\n    node.isExport = isExport || false;\n    node.id = this.parseIdentifier();\n    this.checkIdentifier(node.id, BIND_LEXICAL);\n    this.expect(29);\n    const moduleReference = this.tsParseModuleReference();\n\n    if (node.importKind === \"type\" && moduleReference.type !== \"TSExternalModuleReference\") {\n      this.raise(TSErrors.ImportAliasHasImportType, {\n        at: moduleReference\n      });\n    }\n\n    node.moduleReference = moduleReference;\n    this.semicolon();\n    return this.finishNode(node, \"TSImportEqualsDeclaration\");\n  }\n\n  tsIsExternalModuleReference() {\n    return this.isContextual(116) && this.lookaheadCharCode() === 40;\n  }\n\n  tsParseModuleReference() {\n    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);\n  }\n\n  tsParseExternalModuleReference() {\n    const node = this.startNode();\n    this.expectContextual(116);\n    this.expect(10);\n\n    if (!this.match(129)) {\n      throw this.unexpected();\n    }\n\n    node.expression = this.parseExprAtom();\n    this.expect(11);\n    return this.finishNode(node, \"TSExternalModuleReference\");\n  }\n\n  tsLookAhead(f) {\n    const state = this.state.clone();\n    const res = f();\n    this.state = state;\n    return res;\n  }\n\n  tsTryParseAndCatch(f) {\n    const result = this.tryParse(abort => f() || abort());\n    if (result.aborted || !result.node) return undefined;\n    if (result.error) this.state = result.failState;\n    return result.node;\n  }\n\n  tsTryParse(f) {\n    const state = this.state.clone();\n    const result = f();\n\n    if (result !== undefined && result !== false) {\n      return result;\n    } else {\n      this.state = state;\n      return undefined;\n    }\n  }\n\n  tsTryParseDeclare(nany) {\n    if (this.isLineTerminator()) {\n      return;\n    }\n\n    let starttype = this.state.type;\n    let kind;\n\n    if (this.isContextual(99)) {\n      starttype = 74;\n      kind = \"let\";\n    }\n\n    return this.tsInAmbientContext(() => {\n      if (starttype === 68) {\n        nany.declare = true;\n        return this.parseFunctionStatement(nany, false, true);\n      }\n\n      if (starttype === 80) {\n        nany.declare = true;\n        return this.parseClass(nany, true, false);\n      }\n\n      if (starttype === 122) {\n        return this.tsParseEnumDeclaration(nany, {\n          declare: true\n        });\n      }\n\n      if (starttype === 109) {\n        return this.tsParseAmbientExternalModuleDeclaration(nany);\n      }\n\n      if (starttype === 75 || starttype === 74) {\n        if (!this.match(75) || !this.isLookaheadContextual(\"enum\")) {\n          nany.declare = true;\n          return this.parseVarStatement(nany, kind || this.state.value, true);\n        }\n\n        this.expect(75);\n        return this.tsParseEnumDeclaration(nany, {\n          const: true,\n          declare: true\n        });\n      }\n\n      if (starttype === 125) {\n        const result = this.tsParseInterfaceDeclaration(nany, {\n          declare: true\n        });\n        if (result) return result;\n      }\n\n      if (tokenIsIdentifier(starttype)) {\n        return this.tsParseDeclaration(nany, this.state.value, true);\n      }\n    });\n  }\n\n  tsTryParseExportDeclaration() {\n    return this.tsParseDeclaration(this.startNode(), this.state.value, true);\n  }\n\n  tsParseExpressionStatement(node, expr) {\n    switch (expr.name) {\n      case \"declare\":\n        {\n          const declaration = this.tsTryParseDeclare(node);\n\n          if (declaration) {\n            declaration.declare = true;\n            return declaration;\n          }\n\n          break;\n        }\n\n      case \"global\":\n        if (this.match(5)) {\n          this.scope.enter(SCOPE_TS_MODULE);\n          this.prodParam.enter(PARAM);\n          const mod = node;\n          mod.global = true;\n          mod.id = expr;\n          mod.body = this.tsParseModuleBlock();\n          this.scope.exit();\n          this.prodParam.exit();\n          return this.finishNode(mod, \"TSModuleDeclaration\");\n        }\n\n        break;\n\n      default:\n        return this.tsParseDeclaration(node, expr.name, false);\n    }\n  }\n\n  tsParseDeclaration(node, value, next) {\n    switch (value) {\n      case \"abstract\":\n        if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {\n          return this.tsParseAbstractDeclaration(node);\n        }\n\n        break;\n\n      case \"module\":\n        if (this.tsCheckLineTerminator(next)) {\n          if (this.match(129)) {\n            return this.tsParseAmbientExternalModuleDeclaration(node);\n          } else if (tokenIsIdentifier(this.state.type)) {\n            return this.tsParseModuleOrNamespaceDeclaration(node);\n          }\n        }\n\n        break;\n\n      case \"namespace\":\n        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {\n          return this.tsParseModuleOrNamespaceDeclaration(node);\n        }\n\n        break;\n\n      case \"type\":\n        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {\n          return this.tsParseTypeAliasDeclaration(node);\n        }\n\n        break;\n    }\n  }\n\n  tsCheckLineTerminator(next) {\n    if (next) {\n      if (this.hasFollowingLineBreak()) return false;\n      this.next();\n      return true;\n    }\n\n    return !this.isLineTerminator();\n  }\n\n  tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {\n    if (!this.match(47)) {\n      return undefined;\n    }\n\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = true;\n    const res = this.tsTryParseAndCatch(() => {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.typeParameters = this.tsParseTypeParameters();\n      super.parseFunctionParams(node);\n      node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();\n      this.expect(19);\n      return node;\n    });\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n\n    if (!res) {\n      return undefined;\n    }\n\n    return this.parseArrowExpression(res, null, true);\n  }\n\n  tsParseTypeArgumentsInExpression() {\n    if (this.reScan_lt() !== 47) {\n      return undefined;\n    }\n\n    return this.tsParseTypeArguments();\n  }\n\n  tsParseTypeArguments() {\n    const node = this.startNode();\n    node.params = this.tsInType(() => this.tsInNoContext(() => {\n      this.expect(47);\n      return this.tsParseDelimitedList(\"TypeParametersOrArguments\", this.tsParseType.bind(this));\n    }));\n\n    if (node.params.length === 0) {\n      this.raise(TSErrors.EmptyTypeArguments, {\n        at: node\n      });\n    }\n\n    this.expect(48);\n    return this.finishNode(node, \"TSTypeParameterInstantiation\");\n  }\n\n  tsIsDeclarationStart() {\n    return tokenIsTSDeclarationStart(this.state.type);\n  }\n\n  isExportDefaultSpecifier() {\n    if (this.tsIsDeclarationStart()) return false;\n    return super.isExportDefaultSpecifier();\n  }\n\n  parseAssignableListItem(allowModifiers, decorators) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let accessibility;\n    let readonly = false;\n    let override = false;\n\n    if (allowModifiers !== undefined) {\n      const modified = {};\n      this.tsParseModifiers({\n        modified,\n        allowedModifiers: [\"public\", \"private\", \"protected\", \"override\", \"readonly\"]\n      });\n      accessibility = modified.accessibility;\n      override = modified.override;\n      readonly = modified.readonly;\n\n      if (allowModifiers === false && (accessibility || readonly || override)) {\n        this.raise(TSErrors.UnexpectedParameterModifier, {\n          at: startLoc\n        });\n      }\n    }\n\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left);\n    const elt = this.parseMaybeDefault(left.start, left.loc.start, left);\n\n    if (accessibility || readonly || override) {\n      const pp = this.startNodeAt(startPos, startLoc);\n\n      if (decorators.length) {\n        pp.decorators = decorators;\n      }\n\n      if (accessibility) pp.accessibility = accessibility;\n      if (readonly) pp.readonly = readonly;\n      if (override) pp.override = override;\n\n      if (elt.type !== \"Identifier\" && elt.type !== \"AssignmentPattern\") {\n        this.raise(TSErrors.UnsupportedParameterPropertyKind, {\n          at: pp\n        });\n      }\n\n      pp.parameter = elt;\n      return this.finishNode(pp, \"TSParameterProperty\");\n    }\n\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n\n    return elt;\n  }\n\n  isSimpleParameter(node) {\n    return node.type === \"TSParameterProperty\" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);\n  }\n\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(14)) {\n      node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);\n    }\n\n    const bodilessType = type === \"FunctionDeclaration\" ? \"TSDeclareFunction\" : type === \"ClassMethod\" || type === \"ClassPrivateMethod\" ? \"TSDeclareMethod\" : undefined;\n\n    if (bodilessType && !this.match(5) && this.isLineTerminator()) {\n      this.finishNode(node, bodilessType);\n      return;\n    }\n\n    if (bodilessType === \"TSDeclareFunction\" && this.state.isAmbientContext) {\n      this.raise(TSErrors.DeclareFunctionHasImplementation, {\n        at: node\n      });\n\n      if (node.declare) {\n        super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);\n        return;\n      }\n    }\n\n    super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n\n  registerFunctionStatementId(node) {\n    if (!node.body && node.id) {\n      this.checkIdentifier(node.id, BIND_TS_AMBIENT);\n    } else {\n      super.registerFunctionStatementId(...arguments);\n    }\n  }\n\n  tsCheckForInvalidTypeCasts(items) {\n    items.forEach(node => {\n      if ((node == null ? void 0 : node.type) === \"TSTypeCastExpression\") {\n        this.raise(TSErrors.UnexpectedTypeAnnotation, {\n          at: node.typeAnnotation\n        });\n      }\n    });\n  }\n\n  toReferencedList(exprList, isInParens) {\n    this.tsCheckForInvalidTypeCasts(exprList);\n    return exprList;\n  }\n\n  parseArrayLike(...args) {\n    const node = super.parseArrayLike(...args);\n\n    if (node.type === \"ArrayExpression\") {\n      this.tsCheckForInvalidTypeCasts(node.elements);\n    }\n\n    return node;\n  }\n\n  parseSubscript(base, startPos, startLoc, noCalls, state) {\n    if (!this.hasPrecedingLineBreak() && this.match(35)) {\n      this.state.canStartJSXElement = false;\n      this.next();\n      const nonNullExpression = this.startNodeAt(startPos, startLoc);\n      nonNullExpression.expression = base;\n      return this.finishNode(nonNullExpression, \"TSNonNullExpression\");\n    }\n\n    let isOptionalCall = false;\n\n    if (this.match(18) && this.lookaheadCharCode() === 60) {\n      if (noCalls) {\n        state.stop = true;\n        return base;\n      }\n\n      state.optionalChainMember = isOptionalCall = true;\n      this.next();\n    }\n\n    if (this.match(47) || this.match(51)) {\n      let missingParenErrorLoc;\n      const result = this.tsTryParseAndCatch(() => {\n        if (!noCalls && this.atPossibleAsyncArrow(base)) {\n          const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);\n\n          if (asyncArrowFn) {\n            return asyncArrowFn;\n          }\n        }\n\n        const typeArguments = this.tsParseTypeArgumentsInExpression();\n        if (!typeArguments) throw this.unexpected();\n\n        if (isOptionalCall && !this.match(10)) {\n          missingParenErrorLoc = this.state.curPosition();\n          throw this.unexpected();\n        }\n\n        if (tokenIsTemplate(this.state.type)) {\n          const result = this.parseTaggedTemplateExpression(base, startPos, startLoc, state);\n          result.typeParameters = typeArguments;\n          return result;\n        }\n\n        if (!noCalls && this.eat(10)) {\n          const node = this.startNodeAt(startPos, startLoc);\n          node.callee = base;\n          node.arguments = this.parseCallExpressionArguments(11, false);\n          this.tsCheckForInvalidTypeCasts(node.arguments);\n          node.typeParameters = typeArguments;\n\n          if (state.optionalChainMember) {\n            node.optional = isOptionalCall;\n          }\n\n          return this.finishCallExpression(node, state.optionalChainMember);\n        }\n\n        if (tsTokenCanStartExpression(this.state.type) && this.state.type !== 10) {\n          throw this.unexpected();\n        }\n\n        const node = this.startNodeAt(startPos, startLoc);\n        node.expression = base;\n        node.typeParameters = typeArguments;\n        return this.finishNode(node, \"TSInstantiationExpression\");\n      });\n\n      if (missingParenErrorLoc) {\n        this.unexpected(missingParenErrorLoc, 10);\n      }\n\n      if (result) return result;\n    }\n\n    return super.parseSubscript(base, startPos, startLoc, noCalls, state);\n  }\n\n  parseNewCallee(node) {\n    var _callee$extra;\n\n    super.parseNewCallee(node);\n    const {\n      callee\n    } = node;\n\n    if (callee.type === \"TSInstantiationExpression\" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {\n      node.typeParameters = callee.typeParameters;\n      node.callee = callee.expression;\n    }\n  }\n\n  parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {\n    if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual(93)) {\n      const node = this.startNodeAt(leftStartPos, leftStartLoc);\n      node.expression = left;\n\n      const _const = this.tsTryNextParseConstantContext();\n\n      if (_const) {\n        node.typeAnnotation = _const;\n      } else {\n        node.typeAnnotation = this.tsNextThenParseType();\n      }\n\n      this.finishNode(node, \"TSAsExpression\");\n      this.reScan_lt_gt();\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);\n    }\n\n    return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec);\n  }\n\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (!this.state.isAmbientContext) {\n      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\n    }\n  }\n\n  checkDuplicateExports() {}\n\n  parseImport(node) {\n    node.importKind = \"value\";\n\n    if (tokenIsIdentifier(this.state.type) || this.match(55) || this.match(5)) {\n      let ahead = this.lookahead();\n\n      if (this.isContextual(126) && ahead.type !== 12 && ahead.type !== 97 && ahead.type !== 29) {\n        node.importKind = \"type\";\n        this.next();\n        ahead = this.lookahead();\n      }\n\n      if (tokenIsIdentifier(this.state.type) && ahead.type === 29) {\n        return this.tsParseImportEqualsDeclaration(node);\n      }\n    }\n\n    const importNode = super.parseImport(node);\n\n    if (importNode.importKind === \"type\" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === \"ImportDefaultSpecifier\") {\n      this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, {\n        at: importNode\n      });\n    }\n\n    return importNode;\n  }\n\n  parseExport(node) {\n    if (this.match(83)) {\n      this.next();\n\n      if (this.isContextual(126) && this.lookaheadCharCode() !== 61) {\n        node.importKind = \"type\";\n        this.next();\n      } else {\n        node.importKind = \"value\";\n      }\n\n      return this.tsParseImportEqualsDeclaration(node, true);\n    } else if (this.eat(29)) {\n      const assign = node;\n      assign.expression = this.parseExpression();\n      this.semicolon();\n      return this.finishNode(assign, \"TSExportAssignment\");\n    } else if (this.eatContextual(93)) {\n      const decl = node;\n      this.expectContextual(124);\n      decl.id = this.parseIdentifier();\n      this.semicolon();\n      return this.finishNode(decl, \"TSNamespaceExportDeclaration\");\n    } else {\n      if (this.isContextual(126) && this.lookahead().type === 5) {\n        this.next();\n        node.exportKind = \"type\";\n      } else {\n        node.exportKind = \"value\";\n      }\n\n      return super.parseExport(node);\n    }\n  }\n\n  isAbstractClass() {\n    return this.isContextual(120) && this.lookahead().type === 80;\n  }\n\n  parseExportDefaultExpression() {\n    if (this.isAbstractClass()) {\n      const cls = this.startNode();\n      this.next();\n      cls.abstract = true;\n      this.parseClass(cls, true, true);\n      return cls;\n    }\n\n    if (this.match(125)) {\n      const result = this.tsParseInterfaceDeclaration(this.startNode());\n      if (result) return result;\n    }\n\n    return super.parseExportDefaultExpression();\n  }\n\n  parseVarStatement(node, kind, allowMissingInitializer = false) {\n    const {\n      isAmbientContext\n    } = this.state;\n    const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);\n    if (!isAmbientContext) return declaration;\n\n    for (const {\n      id,\n      init\n    } of declaration.declarations) {\n      if (!init) continue;\n\n      if (kind !== \"const\" || !!id.typeAnnotation) {\n        this.raise(TSErrors.InitializerNotAllowedInAmbientContext, {\n          at: init\n        });\n      } else if (init.type !== \"StringLiteral\" && init.type !== \"BooleanLiteral\" && init.type !== \"NumericLiteral\" && init.type !== \"BigIntLiteral\" && (init.type !== \"TemplateLiteral\" || init.expressions.length > 0) && !isPossiblyLiteralEnum(init)) {\n        this.raise(TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, {\n          at: init\n        });\n      }\n    }\n\n    return declaration;\n  }\n\n  parseStatementContent(context, topLevel) {\n    if (this.match(75) && this.isLookaheadContextual(\"enum\")) {\n      const node = this.startNode();\n      this.expect(75);\n      return this.tsParseEnumDeclaration(node, {\n        const: true\n      });\n    }\n\n    if (this.isContextual(122)) {\n      return this.tsParseEnumDeclaration(this.startNode());\n    }\n\n    if (this.isContextual(125)) {\n      const result = this.tsParseInterfaceDeclaration(this.startNode());\n      if (result) return result;\n    }\n\n    return super.parseStatementContent(context, topLevel);\n  }\n\n  parseAccessModifier() {\n    return this.tsParseModifier([\"public\", \"protected\", \"private\"]);\n  }\n\n  tsHasSomeModifiers(member, modifiers) {\n    return modifiers.some(modifier => {\n      if (tsIsAccessModifier(modifier)) {\n        return member.accessibility === modifier;\n      }\n\n      return !!member[modifier];\n    });\n  }\n\n  tsIsStartOfStaticBlocks() {\n    return this.isContextual(104) && this.lookaheadCharCode() === 123;\n  }\n\n  parseClassMember(classBody, member, state) {\n    const modifiers = [\"declare\", \"private\", \"public\", \"protected\", \"override\", \"abstract\", \"readonly\", \"static\"];\n    this.tsParseModifiers({\n      modified: member,\n      allowedModifiers: modifiers,\n      disallowedModifiers: [\"in\", \"out\"],\n      stopOnStartOfClassStaticBlock: true,\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions\n    });\n\n    const callParseClassMemberWithIsStatic = () => {\n      if (this.tsIsStartOfStaticBlocks()) {\n        this.next();\n        this.next();\n\n        if (this.tsHasSomeModifiers(member, modifiers)) {\n          this.raise(TSErrors.StaticBlockCannotHaveModifier, {\n            at: this.state.curPosition()\n          });\n        }\n\n        this.parseClassStaticBlock(classBody, member);\n      } else {\n        this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);\n      }\n    };\n\n    if (member.declare) {\n      this.tsInAmbientContext(callParseClassMemberWithIsStatic);\n    } else {\n      callParseClassMemberWithIsStatic();\n    }\n  }\n\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    const idx = this.tsTryParseIndexSignature(member);\n\n    if (idx) {\n      classBody.body.push(idx);\n\n      if (member.abstract) {\n        this.raise(TSErrors.IndexSignatureHasAbstract, {\n          at: member\n        });\n      }\n\n      if (member.accessibility) {\n        this.raise(TSErrors.IndexSignatureHasAccessibility, {\n          at: member,\n          modifier: member.accessibility\n        });\n      }\n\n      if (member.declare) {\n        this.raise(TSErrors.IndexSignatureHasDeclare, {\n          at: member\n        });\n      }\n\n      if (member.override) {\n        this.raise(TSErrors.IndexSignatureHasOverride, {\n          at: member\n        });\n      }\n\n      return;\n    }\n\n    if (!this.state.inAbstractClass && member.abstract) {\n      this.raise(TSErrors.NonAbstractClassHasAbstractMethod, {\n        at: member\n      });\n    }\n\n    if (member.override) {\n      if (!state.hadSuperClass) {\n        this.raise(TSErrors.OverrideNotInSubClass, {\n          at: member\n        });\n      }\n    }\n\n    super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n\n  parsePostMemberNameModifiers(methodOrProp) {\n    const optional = this.eat(17);\n    if (optional) methodOrProp.optional = true;\n\n    if (methodOrProp.readonly && this.match(10)) {\n      this.raise(TSErrors.ClassMethodHasReadonly, {\n        at: methodOrProp\n      });\n    }\n\n    if (methodOrProp.declare && this.match(10)) {\n      this.raise(TSErrors.ClassMethodHasDeclare, {\n        at: methodOrProp\n      });\n    }\n  }\n\n  parseExpressionStatement(node, expr) {\n    const decl = expr.type === \"Identifier\" ? this.tsParseExpressionStatement(node, expr) : undefined;\n    return decl || super.parseExpressionStatement(node, expr);\n  }\n\n  shouldParseExportDeclaration() {\n    if (this.tsIsDeclarationStart()) return true;\n    return super.shouldParseExportDeclaration();\n  }\n\n  parseConditional(expr, startPos, startLoc, refExpressionErrors) {\n    if (!this.state.maybeInArrowParameters || !this.match(17)) {\n      return super.parseConditional(expr, startPos, startLoc, refExpressionErrors);\n    }\n\n    const result = this.tryParse(() => super.parseConditional(expr, startPos, startLoc));\n\n    if (!result.node) {\n      if (result.error) {\n        super.setOptionalParametersError(refExpressionErrors, result.error);\n      }\n\n      return expr;\n    }\n\n    if (result.error) this.state = result.failState;\n    return result.node;\n  }\n\n  parseParenItem(node, startPos, startLoc) {\n    node = super.parseParenItem(node, startPos, startLoc);\n\n    if (this.eat(17)) {\n      node.optional = true;\n      this.resetEndLocation(node);\n    }\n\n    if (this.match(14)) {\n      const typeCastNode = this.startNodeAt(startPos, startLoc);\n      typeCastNode.expression = node;\n      typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TSTypeCastExpression\");\n    }\n\n    return node;\n  }\n\n  parseExportDeclaration(node) {\n    if (!this.state.isAmbientContext && this.isContextual(121)) {\n      return this.tsInAmbientContext(() => this.parseExportDeclaration(node));\n    }\n\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const isDeclare = this.eatContextual(121);\n\n    if (isDeclare && (this.isContextual(121) || !this.shouldParseExportDeclaration())) {\n      throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, {\n        at: this.state.startLoc\n      });\n    }\n\n    const isIdentifier = tokenIsIdentifier(this.state.type);\n    const declaration = isIdentifier && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);\n    if (!declaration) return null;\n\n    if (declaration.type === \"TSInterfaceDeclaration\" || declaration.type === \"TSTypeAliasDeclaration\" || isDeclare) {\n      node.exportKind = \"type\";\n    }\n\n    if (isDeclare) {\n      this.resetStartLocation(declaration, startPos, startLoc);\n      declaration.declare = true;\n    }\n\n    return declaration;\n  }\n\n  parseClassId(node, isStatement, optionalId) {\n    if ((!isStatement || optionalId) && this.isContextual(110)) {\n      return;\n    }\n\n    super.parseClassId(node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));\n    if (typeParameters) node.typeParameters = typeParameters;\n  }\n\n  parseClassPropertyAnnotation(node) {\n    if (!node.optional && this.eat(35)) {\n      node.definite = true;\n    }\n\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n  }\n\n  parseClassProperty(node) {\n    this.parseClassPropertyAnnotation(node);\n\n    if (this.state.isAmbientContext && this.match(29)) {\n      this.raise(TSErrors.DeclareClassFieldHasInitializer, {\n        at: this.state.startLoc\n      });\n    }\n\n    if (node.abstract && this.match(29)) {\n      const {\n        key\n      } = node;\n      this.raise(TSErrors.AbstractPropertyHasInitializer, {\n        at: this.state.startLoc,\n        propertyName: key.type === \"Identifier\" && !node.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`\n      });\n    }\n\n    return super.parseClassProperty(node);\n  }\n\n  parseClassPrivateProperty(node) {\n    if (node.abstract) {\n      this.raise(TSErrors.PrivateElementHasAbstract, {\n        at: node\n      });\n    }\n\n    if (node.accessibility) {\n      this.raise(TSErrors.PrivateElementHasAccessibility, {\n        at: node,\n        modifier: node.accessibility\n      });\n    }\n\n    this.parseClassPropertyAnnotation(node);\n    return super.parseClassPrivateProperty(node);\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    const typeParameters = this.tsTryParseTypeParameters();\n\n    if (typeParameters && isConstructor) {\n      this.raise(TSErrors.ConstructorHasTypeParameters, {\n        at: typeParameters\n      });\n    }\n\n    const {\n      declare = false,\n      kind\n    } = method;\n\n    if (declare && (kind === \"get\" || kind === \"set\")) {\n      this.raise(TSErrors.DeclareAccessor, {\n        at: method,\n        kind\n      });\n    }\n\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n  }\n\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n\n  declareClassPrivateMethodInScope(node, kind) {\n    if (node.type === \"TSDeclareMethod\") return;\n    if (node.type === \"MethodDefinition\" && !node.value.body) return;\n    super.declareClassPrivateMethodInScope(node, kind);\n  }\n\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n\n    if (node.superClass && (this.match(47) || this.match(51))) {\n      node.superTypeParameters = this.tsParseTypeArgumentsInExpression();\n    }\n\n    if (this.eatContextual(110)) {\n      node.implements = this.tsParseHeritageClause(\"implements\");\n    }\n  }\n\n  parseObjPropValue(prop, ...args) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) prop.typeParameters = typeParameters;\n    super.parseObjPropValue(prop, ...args);\n  }\n\n  parseFunctionParams(node, allowModifiers) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) node.typeParameters = typeParameters;\n    super.parseFunctionParams(node, allowModifiers);\n  }\n\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n\n    if (decl.id.type === \"Identifier\" && !this.hasPrecedingLineBreak() && this.eat(35)) {\n      decl.definite = true;\n    }\n\n    const type = this.tsTryParseTypeAnnotation();\n\n    if (type) {\n      decl.id.typeAnnotation = type;\n      this.resetEndLocation(decl.id);\n    }\n  }\n\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(14)) {\n      node.returnType = this.tsParseTypeAnnotation();\n    }\n\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n\n  parseMaybeAssign(...args) {\n    var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3;\n\n    let state;\n    let jsx;\n    let typeCast;\n\n    if (this.hasPlugin(\"jsx\") && (this.match(138) || this.match(47))) {\n      state = this.state.clone();\n      jsx = this.tryParse(() => super.parseMaybeAssign(...args), state);\n      if (!jsx.error) return jsx.node;\n      const {\n        context\n      } = this.state;\n      const currentContext = context[context.length - 1];\n\n      if (currentContext === types.j_oTag || currentContext === types.j_expr) {\n        context.pop();\n      }\n    }\n\n    if (!((_jsx = jsx) != null && _jsx.error) && !this.match(47)) {\n      return super.parseMaybeAssign(...args);\n    }\n\n    if (!state || state === this.state) state = this.state.clone();\n    let typeParameters;\n    const arrow = this.tryParse(abort => {\n      var _expr$extra, _typeParameters;\n\n      typeParameters = this.tsParseTypeParameters();\n      const expr = super.parseMaybeAssign(...args);\n\n      if (expr.type !== \"ArrowFunctionExpression\" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {\n        abort();\n      }\n\n      if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {\n        this.resetStartLocationFromNode(expr, typeParameters);\n      }\n\n      expr.typeParameters = typeParameters;\n      return expr;\n    }, state);\n\n    if (!arrow.error && !arrow.aborted) {\n      if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\n      return arrow.node;\n    }\n\n    if (!jsx) {\n      assert(!this.hasPlugin(\"jsx\"));\n      typeCast = this.tryParse(() => super.parseMaybeAssign(...args), state);\n      if (!typeCast.error) return typeCast.node;\n    }\n\n    if ((_jsx2 = jsx) != null && _jsx2.node) {\n      this.state = jsx.failState;\n      return jsx.node;\n    }\n\n    if (arrow.node) {\n      this.state = arrow.failState;\n      if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\n      return arrow.node;\n    }\n\n    if ((_typeCast = typeCast) != null && _typeCast.node) {\n      this.state = typeCast.failState;\n      return typeCast.node;\n    }\n\n    if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;\n    if (arrow.thrown) throw arrow.error;\n    if ((_typeCast2 = typeCast) != null && _typeCast2.thrown) throw typeCast.error;\n    throw ((_jsx4 = jsx) == null ? void 0 : _jsx4.error) || arrow.error || ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error);\n  }\n\n  reportReservedArrowTypeParam(node) {\n    var _node$extra;\n\n    if (node.params.length === 1 && !((_node$extra = node.extra) != null && _node$extra.trailingComma) && this.getPluginOption(\"typescript\", \"disallowAmbiguousJSXLike\")) {\n      this.raise(TSErrors.ReservedArrowTypeParam, {\n        at: node\n      });\n    }\n  }\n\n  parseMaybeUnary(refExpressionErrors) {\n    if (!this.hasPlugin(\"jsx\") && this.match(47)) {\n      return this.tsParseTypeAssertion();\n    } else {\n      return super.parseMaybeUnary(refExpressionErrors);\n    }\n  }\n\n  parseArrow(node) {\n    if (this.match(14)) {\n      const result = this.tryParse(abort => {\n        const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);\n        if (this.canInsertSemicolon() || !this.match(19)) abort();\n        return returnType;\n      });\n      if (result.aborted) return;\n\n      if (!result.thrown) {\n        if (result.error) this.state = result.failState;\n        node.returnType = result.node;\n      }\n    }\n\n    return super.parseArrow(node);\n  }\n\n  parseAssignableListItemTypes(param) {\n    if (this.eat(17)) {\n      if (param.type !== \"Identifier\" && !this.state.isAmbientContext && !this.state.inType) {\n        this.raise(TSErrors.PatternIsOptional, {\n          at: param\n        });\n      }\n\n      param.optional = true;\n    }\n\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) param.typeAnnotation = type;\n    this.resetEndLocation(param);\n    return param;\n  }\n\n  isAssignable(node, isBinding) {\n    switch (node.type) {\n      case \"TSTypeCastExpression\":\n        return this.isAssignable(node.expression, isBinding);\n\n      case \"TSParameterProperty\":\n        return true;\n\n      default:\n        return super.isAssignable(node, isBinding);\n    }\n  }\n\n  toAssignable(node, isLHS = false) {\n    switch (node.type) {\n      case \"ParenthesizedExpression\":\n        this.toAssignableParenthesizedExpression(node, isLHS);\n        break;\n\n      case \"TSAsExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n        if (isLHS) {\n          this.expressionScope.recordArrowParemeterBindingError(TSErrors.UnexpectedTypeCastInParameter, {\n            at: node\n          });\n        } else {\n          this.raise(TSErrors.UnexpectedTypeCastInParameter, {\n            at: node\n          });\n        }\n\n        this.toAssignable(node.expression, isLHS);\n        break;\n\n      case \"AssignmentExpression\":\n        if (!isLHS && node.left.type === \"TSTypeCastExpression\") {\n          node.left = this.typeCastToParameter(node.left);\n        }\n\n      default:\n        super.toAssignable(node, isLHS);\n    }\n  }\n\n  toAssignableParenthesizedExpression(node, isLHS) {\n    switch (node.expression.type) {\n      case \"TSAsExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n      case \"ParenthesizedExpression\":\n        this.toAssignable(node.expression, isLHS);\n        break;\n\n      default:\n        super.toAssignable(node, isLHS);\n    }\n  }\n\n  checkToRestConversion(node, allowPattern) {\n    switch (node.type) {\n      case \"TSAsExpression\":\n      case \"TSTypeAssertion\":\n      case \"TSNonNullExpression\":\n        this.checkToRestConversion(node.expression, false);\n        break;\n\n      default:\n        super.checkToRestConversion(node, allowPattern);\n    }\n  }\n\n  isValidLVal(type, isUnparenthesizedInAssign, binding) {\n    return getOwn$1({\n      TSTypeCastExpression: true,\n      TSParameterProperty: \"parameter\",\n      TSNonNullExpression: \"expression\",\n      TSAsExpression: (binding !== BIND_NONE || !isUnparenthesizedInAssign) && [\"expression\", true],\n      TSTypeAssertion: (binding !== BIND_NONE || !isUnparenthesizedInAssign) && [\"expression\", true]\n    }, type) || super.isValidLVal(type, isUnparenthesizedInAssign, binding);\n  }\n\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case 78:\n        return this.parseIdentifier(true);\n\n      default:\n        return super.parseBindingAtom();\n    }\n  }\n\n  parseMaybeDecoratorArguments(expr) {\n    if (this.match(47) || this.match(51)) {\n      const typeArguments = this.tsParseTypeArgumentsInExpression();\n\n      if (this.match(10)) {\n        const call = super.parseMaybeDecoratorArguments(expr);\n        call.typeParameters = typeArguments;\n        return call;\n      }\n\n      this.unexpected(null, 10);\n    }\n\n    return super.parseMaybeDecoratorArguments(expr);\n  }\n\n  checkCommaAfterRest(close) {\n    if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {\n      this.next();\n      return false;\n    } else {\n      return super.checkCommaAfterRest(close);\n    }\n  }\n\n  isClassMethod() {\n    return this.match(47) || super.isClassMethod();\n  }\n\n  isClassProperty() {\n    return this.match(35) || this.match(14) || super.isClassProperty();\n  }\n\n  parseMaybeDefault(...args) {\n    const node = super.parseMaybeDefault(...args);\n\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(TSErrors.TypeAnnotationAfterAssign, {\n        at: node.typeAnnotation\n      });\n    }\n\n    return node;\n  }\n\n  getTokenFromCode(code) {\n    if (this.state.inType) {\n      if (code === 62) {\n        return this.finishOp(48, 1);\n      }\n\n      if (code === 60) {\n        return this.finishOp(47, 1);\n      }\n    }\n\n    return super.getTokenFromCode(code);\n  }\n\n  reScan_lt_gt() {\n    const {\n      type\n    } = this.state;\n\n    if (type === 47) {\n      this.state.pos -= 1;\n      this.readToken_lt();\n    } else if (type === 48) {\n      this.state.pos -= 1;\n      this.readToken_gt();\n    }\n  }\n\n  reScan_lt() {\n    const {\n      type\n    } = this.state;\n\n    if (type === 51) {\n      this.state.pos -= 2;\n      this.finishOp(47, 1);\n      return 47;\n    }\n\n    return type;\n  }\n\n  toAssignableList(exprList) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n\n      if ((expr == null ? void 0 : expr.type) === \"TSTypeCastExpression\") {\n        exprList[i] = this.typeCastToParameter(expr);\n      }\n    }\n\n    super.toAssignableList(...arguments);\n  }\n\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n\n  shouldParseArrow(params) {\n    if (this.match(14)) {\n      return params.every(expr => this.isAssignable(expr, true));\n    }\n\n    return super.shouldParseArrow(params);\n  }\n\n  shouldParseAsyncArrow() {\n    return this.match(14) || super.shouldParseAsyncArrow();\n  }\n\n  canHaveLeadingDecorator() {\n    return super.canHaveLeadingDecorator() || this.isAbstractClass();\n  }\n\n  jsxParseOpeningElementAfterName(node) {\n    if (this.match(47) || this.match(51)) {\n      const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());\n      if (typeArguments) node.typeParameters = typeArguments;\n    }\n\n    return super.jsxParseOpeningElementAfterName(node);\n  }\n\n  getGetterSetterExpectedParamCount(method) {\n    const baseCount = super.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    const firstParam = params[0];\n    const hasContextParam = firstParam && this.isThisParam(firstParam);\n    return hasContextParam ? baseCount + 1 : baseCount;\n  }\n\n  parseCatchClauseParam() {\n    const param = super.parseCatchClauseParam();\n    const type = this.tsTryParseTypeAnnotation();\n\n    if (type) {\n      param.typeAnnotation = type;\n      this.resetEndLocation(param);\n    }\n\n    return param;\n  }\n\n  tsInAmbientContext(cb) {\n    const oldIsAmbientContext = this.state.isAmbientContext;\n    this.state.isAmbientContext = true;\n\n    try {\n      return cb();\n    } finally {\n      this.state.isAmbientContext = oldIsAmbientContext;\n    }\n  }\n\n  parseClass(node, ...args) {\n    const oldInAbstractClass = this.state.inAbstractClass;\n    this.state.inAbstractClass = !!node.abstract;\n\n    try {\n      return super.parseClass(node, ...args);\n    } finally {\n      this.state.inAbstractClass = oldInAbstractClass;\n    }\n  }\n\n  tsParseAbstractDeclaration(node) {\n    if (this.match(80)) {\n      node.abstract = true;\n      return this.parseClass(node, true, false);\n    } else if (this.isContextual(125)) {\n      if (!this.hasFollowingLineBreak()) {\n        node.abstract = true;\n        this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, {\n          at: node\n        });\n        return this.tsParseInterfaceDeclaration(node);\n      }\n    } else {\n      this.unexpected(null, 80);\n    }\n  }\n\n  parseMethod(...args) {\n    const method = super.parseMethod(...args);\n\n    if (method.abstract) {\n      const hasBody = this.hasPlugin(\"estree\") ? !!method.value.body : !!method.body;\n\n      if (hasBody) {\n        const {\n          key\n        } = method;\n        this.raise(TSErrors.AbstractMethodHasImplementation, {\n          at: method,\n          methodName: key.type === \"Identifier\" && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`\n        });\n      }\n    }\n\n    return method;\n  }\n\n  tsParseTypeParameterName() {\n    const typeName = this.parseIdentifier();\n    return typeName.name;\n  }\n\n  shouldParseAsAmbientContext() {\n    return !!this.getPluginOption(\"typescript\", \"dts\");\n  }\n\n  parse() {\n    if (this.shouldParseAsAmbientContext()) {\n      this.state.isAmbientContext = true;\n    }\n\n    return super.parse();\n  }\n\n  getExpression() {\n    if (this.shouldParseAsAmbientContext()) {\n      this.state.isAmbientContext = true;\n    }\n\n    return super.getExpression();\n  }\n\n  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {\n    if (!isString && isMaybeTypeOnly) {\n      this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);\n      return this.finishNode(node, \"ExportSpecifier\");\n    }\n\n    node.exportKind = \"value\";\n    return super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly);\n  }\n\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {\n    if (!importedIsString && isMaybeTypeOnly) {\n      this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);\n      return this.finishNode(specifier, \"ImportSpecifier\");\n    }\n\n    specifier.importKind = \"value\";\n    return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly);\n  }\n\n  parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {\n    const leftOfAsKey = isImport ? \"imported\" : \"local\";\n    const rightOfAsKey = isImport ? \"local\" : \"exported\";\n    let leftOfAs = node[leftOfAsKey];\n    let rightOfAs;\n    let hasTypeSpecifier = false;\n    let canParseAsKeyword = true;\n    const loc = leftOfAs.loc.start;\n\n    if (this.isContextual(93)) {\n      const firstAs = this.parseIdentifier();\n\n      if (this.isContextual(93)) {\n        const secondAs = this.parseIdentifier();\n\n        if (tokenIsKeywordOrIdentifier(this.state.type)) {\n          hasTypeSpecifier = true;\n          leftOfAs = firstAs;\n          rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n          canParseAsKeyword = false;\n        } else {\n          rightOfAs = secondAs;\n          canParseAsKeyword = false;\n        }\n      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n        canParseAsKeyword = false;\n        rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n      } else {\n        hasTypeSpecifier = true;\n        leftOfAs = firstAs;\n      }\n    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n      hasTypeSpecifier = true;\n\n      if (isImport) {\n        leftOfAs = this.parseIdentifier(true);\n\n        if (!this.isContextual(93)) {\n          this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);\n        }\n      } else {\n        leftOfAs = this.parseModuleExportName();\n      }\n    }\n\n    if (hasTypeSpecifier && isInTypeOnlyImportExport) {\n      this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, {\n        at: loc\n      });\n    }\n\n    node[leftOfAsKey] = leftOfAs;\n    node[rightOfAsKey] = rightOfAs;\n    const kindKey = isImport ? \"importKind\" : \"exportKind\";\n    node[kindKey] = hasTypeSpecifier ? \"type\" : \"value\";\n\n    if (canParseAsKeyword && this.eatContextual(93)) {\n      node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n    }\n\n    if (!node[rightOfAsKey]) {\n      node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);\n    }\n\n    if (isImport) {\n      this.checkIdentifier(node[rightOfAsKey], BIND_LEXICAL);\n    }\n  }\n\n});\n\nfunction isPossiblyLiteralEnum(expression) {\n  if (expression.type !== \"MemberExpression\") return false;\n  const {\n    computed,\n    property\n  } = expression;\n\n  if (computed && property.type !== \"StringLiteral\" && (property.type !== \"TemplateLiteral\" || property.expressions.length > 0)) {\n    return false;\n  }\n\n  return isUncomputedMemberExpressionChain(expression.object);\n}\n\nfunction isUncomputedMemberExpressionChain(expression) {\n  if (expression.type === \"Identifier\") return true;\n  if (expression.type !== \"MemberExpression\") return false;\n  if (expression.computed) return false;\n  return isUncomputedMemberExpressionChain(expression.object);\n}\n\nconst PlaceholderErrors = ParseErrorEnum`placeholders`(_ => ({\n  ClassNameIsRequired: _(\"A class name is required.\"),\n  UnexpectedSpace: _(\"Unexpected space in placeholder.\")\n}));\nvar placeholders = (superClass => class extends superClass {\n  parsePlaceholder(expectedNode) {\n    if (this.match(140)) {\n      const node = this.startNode();\n      this.next();\n      this.assertNoSpace();\n      node.name = super.parseIdentifier(true);\n      this.assertNoSpace();\n      this.expect(140);\n      return this.finishPlaceholder(node, expectedNode);\n    }\n  }\n\n  finishPlaceholder(node, expectedNode) {\n    const isFinished = !!(node.expectedNode && node.type === \"Placeholder\");\n    node.expectedNode = expectedNode;\n    return isFinished ? node : this.finishNode(node, \"Placeholder\");\n  }\n\n  getTokenFromCode(code) {\n    if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {\n      return this.finishOp(140, 2);\n    }\n\n    return super.getTokenFromCode(...arguments);\n  }\n\n  parseExprAtom() {\n    return this.parsePlaceholder(\"Expression\") || super.parseExprAtom(...arguments);\n  }\n\n  parseIdentifier() {\n    return this.parsePlaceholder(\"Identifier\") || super.parseIdentifier(...arguments);\n  }\n\n  checkReservedWord(word) {\n    if (word !== undefined) super.checkReservedWord(...arguments);\n  }\n\n  parseBindingAtom() {\n    return this.parsePlaceholder(\"Pattern\") || super.parseBindingAtom(...arguments);\n  }\n\n  isValidLVal(type, ...rest) {\n    return type === \"Placeholder\" || super.isValidLVal(type, ...rest);\n  }\n\n  toAssignable(node) {\n    if (node && node.type === \"Placeholder\" && node.expectedNode === \"Expression\") {\n      node.expectedNode = \"Pattern\";\n    } else {\n      super.toAssignable(...arguments);\n    }\n  }\n\n  isLet(context) {\n    if (super.isLet(context)) {\n      return true;\n    }\n\n    if (!this.isContextual(99)) {\n      return false;\n    }\n\n    if (context) return false;\n    const nextToken = this.lookahead();\n\n    if (nextToken.type === 140) {\n      return true;\n    }\n\n    return false;\n  }\n\n  verifyBreakContinue(node) {\n    if (node.label && node.label.type === \"Placeholder\") return;\n    super.verifyBreakContinue(...arguments);\n  }\n\n  parseExpressionStatement(node, expr) {\n    if (expr.type !== \"Placeholder\" || expr.extra && expr.extra.parenthesized) {\n      return super.parseExpressionStatement(...arguments);\n    }\n\n    if (this.match(14)) {\n      const stmt = node;\n      stmt.label = this.finishPlaceholder(expr, \"Identifier\");\n      this.next();\n      stmt.body = this.parseStatement(\"label\");\n      return this.finishNode(stmt, \"LabeledStatement\");\n    }\n\n    this.semicolon();\n    node.name = expr.name;\n    return this.finishPlaceholder(node, \"Statement\");\n  }\n\n  parseBlock() {\n    return this.parsePlaceholder(\"BlockStatement\") || super.parseBlock(...arguments);\n  }\n\n  parseFunctionId() {\n    return this.parsePlaceholder(\"Identifier\") || super.parseFunctionId(...arguments);\n  }\n\n  parseClass(node, isStatement, optionalId) {\n    const type = isStatement ? \"ClassDeclaration\" : \"ClassExpression\";\n    this.next();\n    this.takeDecorators(node);\n    const oldStrict = this.state.strict;\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n\n    if (placeholder) {\n      if (this.match(81) || this.match(140) || this.match(5)) {\n        node.id = placeholder;\n      } else if (optionalId || !isStatement) {\n        node.id = null;\n        node.body = this.finishPlaceholder(placeholder, \"ClassBody\");\n        return this.finishNode(node, type);\n      } else {\n        throw this.raise(PlaceholderErrors.ClassNameIsRequired, {\n          at: this.state.startLoc\n        });\n      }\n    } else {\n      this.parseClassId(node, isStatement, optionalId);\n    }\n\n    this.parseClassSuper(node);\n    node.body = this.parsePlaceholder(\"ClassBody\") || this.parseClassBody(!!node.superClass, oldStrict);\n    return this.finishNode(node, type);\n  }\n\n  parseExport(node) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder) return super.parseExport(...arguments);\n\n    if (!this.isContextual(97) && !this.match(12)) {\n      node.specifiers = [];\n      node.source = null;\n      node.declaration = this.finishPlaceholder(placeholder, \"Declaration\");\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n\n    this.expectPlugin(\"exportDefaultFrom\");\n    const specifier = this.startNode();\n    specifier.exported = placeholder;\n    node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n    return super.parseExport(node);\n  }\n\n  isExportDefaultSpecifier() {\n    if (this.match(65)) {\n      const next = this.nextTokenStart();\n\n      if (this.isUnparsedContextual(next, \"from\")) {\n        if (this.input.startsWith(tokenLabelName(140), this.nextTokenStartSince(next + 4))) {\n          return true;\n        }\n      }\n    }\n\n    return super.isExportDefaultSpecifier();\n  }\n\n  maybeParseExportDefaultSpecifier(node) {\n    if (node.specifiers && node.specifiers.length > 0) {\n      return true;\n    }\n\n    return super.maybeParseExportDefaultSpecifier(...arguments);\n  }\n\n  checkExport(node) {\n    const {\n      specifiers\n    } = node;\n\n    if (specifiers != null && specifiers.length) {\n      node.specifiers = specifiers.filter(node => node.exported.type === \"Placeholder\");\n    }\n\n    super.checkExport(node);\n    node.specifiers = specifiers;\n  }\n\n  parseImport(node) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder) return super.parseImport(...arguments);\n    node.specifiers = [];\n\n    if (!this.isContextual(97) && !this.match(12)) {\n      node.source = this.finishPlaceholder(placeholder, \"StringLiteral\");\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n\n    const specifier = this.startNodeAtNode(placeholder);\n    specifier.local = placeholder;\n    this.finishNode(specifier, \"ImportDefaultSpecifier\");\n    node.specifiers.push(specifier);\n\n    if (this.eat(12)) {\n      const hasStarImport = this.maybeParseStarImportSpecifier(node);\n      if (!hasStarImport) this.parseNamedImportSpecifiers(node);\n    }\n\n    this.expectContextual(97);\n    node.source = this.parseImportSource();\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n\n  parseImportSource() {\n    return this.parsePlaceholder(\"StringLiteral\") || super.parseImportSource(...arguments);\n  }\n\n  assertNoSpace() {\n    if (this.state.start > this.state.lastTokEndLoc.index) {\n      this.raise(PlaceholderErrors.UnexpectedSpace, {\n        at: this.state.lastTokEndLoc\n      });\n    }\n  }\n\n});\n\nvar v8intrinsic = (superClass => class extends superClass {\n  parseV8Intrinsic() {\n    if (this.match(54)) {\n      const v8IntrinsicStartLoc = this.state.startLoc;\n      const node = this.startNode();\n      this.next();\n\n      if (tokenIsIdentifier(this.state.type)) {\n        const name = this.parseIdentifierName(this.state.start);\n        const identifier = this.createIdentifier(node, name);\n        identifier.type = \"V8IntrinsicIdentifier\";\n\n        if (this.match(10)) {\n          return identifier;\n        }\n      }\n\n      this.unexpected(v8IntrinsicStartLoc);\n    }\n  }\n\n  parseExprAtom() {\n    return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);\n  }\n\n});\n\nfunction hasPlugin(plugins, expectedConfig) {\n  const [expectedName, expectedOptions] = typeof expectedConfig === \"string\" ? [expectedConfig, {}] : expectedConfig;\n  const expectedKeys = Object.keys(expectedOptions);\n  const expectedOptionsIsEmpty = expectedKeys.length === 0;\n  return plugins.some(p => {\n    if (typeof p === \"string\") {\n      return expectedOptionsIsEmpty && p === expectedName;\n    } else {\n      const [pluginName, pluginOptions] = p;\n\n      if (pluginName !== expectedName) {\n        return false;\n      }\n\n      for (const key of expectedKeys) {\n        if (pluginOptions[key] !== expectedOptions[key]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  });\n}\nfunction getPluginOption(plugins, name, option) {\n  const plugin = plugins.find(plugin => {\n    if (Array.isArray(plugin)) {\n      return plugin[0] === name;\n    } else {\n      return plugin === name;\n    }\n  });\n\n  if (plugin && Array.isArray(plugin)) {\n    return plugin[1][option];\n  }\n\n  return null;\n}\nconst PIPELINE_PROPOSALS = [\"minimal\", \"fsharp\", \"hack\", \"smart\"];\nconst TOPIC_TOKENS = [\"^^\", \"@@\", \"^\", \"%\", \"#\"];\nconst RECORD_AND_TUPLE_SYNTAX_TYPES = [\"hash\", \"bar\"];\nfunction validatePlugins(plugins) {\n  if (hasPlugin(plugins, \"decorators\")) {\n    if (hasPlugin(plugins, \"decorators-legacy\")) {\n      throw new Error(\"Cannot use the decorators and decorators-legacy plugin together\");\n    }\n\n    const decoratorsBeforeExport = getPluginOption(plugins, \"decorators\", \"decoratorsBeforeExport\");\n\n    if (decoratorsBeforeExport == null) {\n      throw new Error(\"The 'decorators' plugin requires a 'decoratorsBeforeExport' option,\" + \" whose value must be a boolean. If you are migrating from\" + \" Babylon/Babel 6 or want to use the old decorators proposal, you\" + \" should use the 'decorators-legacy' plugin instead of 'decorators'.\");\n    } else if (typeof decoratorsBeforeExport !== \"boolean\") {\n      throw new Error(\"'decoratorsBeforeExport' must be a boolean.\");\n    }\n  }\n\n  if (hasPlugin(plugins, \"flow\") && hasPlugin(plugins, \"typescript\")) {\n    throw new Error(\"Cannot combine flow and typescript plugins.\");\n  }\n\n  if (hasPlugin(plugins, \"placeholders\") && hasPlugin(plugins, \"v8intrinsic\")) {\n    throw new Error(\"Cannot combine placeholders and v8intrinsic plugins.\");\n  }\n\n  if (hasPlugin(plugins, \"pipelineOperator\")) {\n    const proposal = getPluginOption(plugins, \"pipelineOperator\", \"proposal\");\n\n    if (!PIPELINE_PROPOSALS.includes(proposal)) {\n      const proposalList = PIPELINE_PROPOSALS.map(p => `\"${p}\"`).join(\", \");\n      throw new Error(`\"pipelineOperator\" requires \"proposal\" option whose value must be one of: ${proposalList}.`);\n    }\n\n    const tupleSyntaxIsHash = hasPlugin(plugins, [\"recordAndTuple\", {\n      syntaxType: \"hash\"\n    }]);\n\n    if (proposal === \"hack\") {\n      if (hasPlugin(plugins, \"placeholders\")) {\n        throw new Error(\"Cannot combine placeholders plugin and Hack-style pipes.\");\n      }\n\n      if (hasPlugin(plugins, \"v8intrinsic\")) {\n        throw new Error(\"Cannot combine v8intrinsic plugin and Hack-style pipes.\");\n      }\n\n      const topicToken = getPluginOption(plugins, \"pipelineOperator\", \"topicToken\");\n\n      if (!TOPIC_TOKENS.includes(topicToken)) {\n        const tokenList = TOPIC_TOKENS.map(t => `\"${t}\"`).join(\", \");\n        throw new Error(`\"pipelineOperator\" in \"proposal\": \"hack\" mode also requires a \"topicToken\" option whose value must be one of: ${tokenList}.`);\n      }\n\n      if (topicToken === \"#\" && tupleSyntaxIsHash) {\n        throw new Error('Plugin conflict between `[\"pipelineOperator\", { proposal: \"hack\", topicToken: \"#\" }]` and `[\"recordAndtuple\", { syntaxType: \"hash\"}]`.');\n      }\n    } else if (proposal === \"smart\" && tupleSyntaxIsHash) {\n      throw new Error('Plugin conflict between `[\"pipelineOperator\", { proposal: \"smart\" }]` and `[\"recordAndtuple\", { syntaxType: \"hash\"}]`.');\n    }\n  }\n\n  if (hasPlugin(plugins, \"moduleAttributes\")) {\n    {\n      if (hasPlugin(plugins, \"importAssertions\")) {\n        throw new Error(\"Cannot combine importAssertions and moduleAttributes plugins.\");\n      }\n\n      const moduleAttributesVersionPluginOption = getPluginOption(plugins, \"moduleAttributes\", \"version\");\n\n      if (moduleAttributesVersionPluginOption !== \"may-2020\") {\n        throw new Error(\"The 'moduleAttributes' plugin requires a 'version' option,\" + \" representing the last proposal update. Currently, the\" + \" only supported value is 'may-2020'.\");\n      }\n    }\n  }\n\n  if (hasPlugin(plugins, \"recordAndTuple\") && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, \"recordAndTuple\", \"syntaxType\"))) {\n    throw new Error(\"'recordAndTuple' requires 'syntaxType' option whose value should be one of: \" + RECORD_AND_TUPLE_SYNTAX_TYPES.map(p => `'${p}'`).join(\", \"));\n  }\n\n  if (hasPlugin(plugins, \"asyncDoExpressions\") && !hasPlugin(plugins, \"doExpressions\")) {\n    const error = new Error(\"'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.\");\n    error.missingPlugins = \"doExpressions\";\n    throw error;\n  }\n}\nconst mixinPlugins = {\n  estree,\n  jsx,\n  flow,\n  typescript,\n  v8intrinsic,\n  placeholders\n};\nconst mixinPluginNames = Object.keys(mixinPlugins);\n\nconst defaultOptions = {\n  sourceType: \"script\",\n  sourceFilename: undefined,\n  startColumn: 0,\n  startLine: 1,\n  allowAwaitOutsideFunction: false,\n  allowReturnOutsideFunction: false,\n  allowImportExportEverywhere: false,\n  allowSuperOutsideMethod: false,\n  allowUndeclaredExports: false,\n  plugins: [],\n  strictMode: null,\n  ranges: false,\n  tokens: false,\n  createParenthesizedExpressions: false,\n  errorRecovery: false,\n  attachComment: true\n};\nfunction getOptions(opts) {\n  const options = {};\n\n  for (const key of Object.keys(defaultOptions)) {\n    options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];\n  }\n\n  return options;\n}\n\nconst getOwn = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];\n\nconst unwrapParenthesizedExpression = node => {\n  return node.type === \"ParenthesizedExpression\" ? unwrapParenthesizedExpression(node.expression) : node;\n};\n\nclass LValParser extends NodeUtils {\n  toAssignable(node, isLHS = false) {\n    var _node$extra, _node$extra3;\n\n    let parenthesized = undefined;\n\n    if (node.type === \"ParenthesizedExpression\" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {\n      parenthesized = unwrapParenthesizedExpression(node);\n\n      if (isLHS) {\n        if (parenthesized.type === \"Identifier\") {\n          this.expressionScope.recordArrowParemeterBindingError(Errors.InvalidParenthesizedAssignment, {\n            at: node\n          });\n        } else if (parenthesized.type !== \"MemberExpression\") {\n          this.raise(Errors.InvalidParenthesizedAssignment, {\n            at: node\n          });\n        }\n      } else {\n        this.raise(Errors.InvalidParenthesizedAssignment, {\n          at: node\n        });\n      }\n    }\n\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n        break;\n\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n\n        for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {\n          var _node$extra2;\n\n          const prop = node.properties[i];\n          const isLast = i === last;\n          this.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n\n          if (isLast && prop.type === \"RestElement\" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {\n            this.raise(Errors.RestTrailingComma, {\n              at: node.extra.trailingCommaLoc\n            });\n          }\n        }\n\n        break;\n\n      case \"ObjectProperty\":\n        {\n          const {\n            key,\n            value\n          } = node;\n\n          if (this.isPrivateName(key)) {\n            this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);\n          }\n\n          this.toAssignable(value, isLHS);\n          break;\n        }\n\n      case \"SpreadElement\":\n        {\n          throw new Error(\"Internal @babel/parser error (this is a bug, please report it).\" + \" SpreadElement should be converted by .toAssignable's caller.\");\n        }\n\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n        this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);\n        break;\n\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") {\n          this.raise(Errors.MissingEqInAssignment, {\n            at: node.left.loc.end\n          });\n        }\n\n        node.type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left, isLHS);\n        break;\n\n      case \"ParenthesizedExpression\":\n        this.toAssignable(parenthesized, isLHS);\n        break;\n    }\n  }\n\n  toAssignableObjectExpressionProp(prop, isLast, isLHS) {\n    if (prop.type === \"ObjectMethod\") {\n      this.raise(prop.kind === \"get\" || prop.kind === \"set\" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, {\n        at: prop.key\n      });\n    } else if (prop.type === \"SpreadElement\") {\n      prop.type = \"RestElement\";\n      const arg = prop.argument;\n      this.checkToRestConversion(arg, false);\n      this.toAssignable(arg, isLHS);\n\n      if (!isLast) {\n        this.raise(Errors.RestTrailingComma, {\n          at: prop\n        });\n      }\n    } else {\n      this.toAssignable(prop, isLHS);\n    }\n  }\n\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\n    const end = exprList.length - 1;\n\n    for (let i = 0; i <= end; i++) {\n      const elt = exprList[i];\n      if (!elt) continue;\n\n      if (elt.type === \"SpreadElement\") {\n        elt.type = \"RestElement\";\n        const arg = elt.argument;\n        this.checkToRestConversion(arg, true);\n        this.toAssignable(arg, isLHS);\n      } else {\n        this.toAssignable(elt, isLHS);\n      }\n\n      if (elt.type === \"RestElement\") {\n        if (i < end) {\n          this.raise(Errors.RestTrailingComma, {\n            at: elt\n          });\n        } else if (trailingCommaLoc) {\n          this.raise(Errors.RestTrailingComma, {\n            at: trailingCommaLoc\n          });\n        }\n      }\n    }\n  }\n\n  isAssignable(node, isBinding) {\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n        return true;\n\n      case \"ObjectExpression\":\n        {\n          const last = node.properties.length - 1;\n          return node.properties.every((prop, i) => {\n            return prop.type !== \"ObjectMethod\" && (i === last || prop.type !== \"SpreadElement\") && this.isAssignable(prop);\n          });\n        }\n\n      case \"ObjectProperty\":\n        return this.isAssignable(node.value);\n\n      case \"SpreadElement\":\n        return this.isAssignable(node.argument);\n\n      case \"ArrayExpression\":\n        return node.elements.every(element => element === null || this.isAssignable(element));\n\n      case \"AssignmentExpression\":\n        return node.operator === \"=\";\n\n      case \"ParenthesizedExpression\":\n        return this.isAssignable(node.expression);\n\n      case \"MemberExpression\":\n      case \"OptionalMemberExpression\":\n        return !isBinding;\n\n      default:\n        return false;\n    }\n  }\n\n  toReferencedList(exprList, isParenthesizedExpr) {\n    return exprList;\n  }\n\n  toReferencedListDeep(exprList, isParenthesizedExpr) {\n    this.toReferencedList(exprList, isParenthesizedExpr);\n\n    for (const expr of exprList) {\n      if ((expr == null ? void 0 : expr.type) === \"ArrayExpression\") {\n        this.toReferencedListDeep(expr.elements);\n      }\n    }\n  }\n\n  parseSpread(refExpressionErrors, refNeedsArrowPos) {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, undefined, refNeedsArrowPos);\n    return this.finishNode(node, \"SpreadElement\");\n  }\n\n  parseRestBinding() {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseBindingAtom();\n    return this.finishNode(node, \"RestElement\");\n  }\n\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case 0:\n        {\n          const node = this.startNode();\n          this.next();\n          node.elements = this.parseBindingList(3, 93, true);\n          return this.finishNode(node, \"ArrayPattern\");\n        }\n\n      case 5:\n        return this.parseObjectLike(8, true);\n    }\n\n    return this.parseIdentifier();\n  }\n\n  parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {\n    const elts = [];\n    let first = true;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n      }\n\n      if (allowEmpty && this.match(12)) {\n        elts.push(null);\n      } else if (this.eat(close)) {\n        break;\n      } else if (this.match(21)) {\n        elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));\n\n        if (!this.checkCommaAfterRest(closeCharCode)) {\n          this.expect(close);\n          break;\n        }\n      } else {\n        const decorators = [];\n\n        if (this.match(26) && this.hasPlugin(\"decorators\")) {\n          this.raise(Errors.UnsupportedParameterDecorator, {\n            at: this.state.startLoc\n          });\n        }\n\n        while (this.match(26)) {\n          decorators.push(this.parseDecorator());\n        }\n\n        elts.push(this.parseAssignableListItem(allowModifiers, decorators));\n      }\n    }\n\n    return elts;\n  }\n\n  parseBindingRestProperty(prop) {\n    this.next();\n    prop.argument = this.parseIdentifier();\n    this.checkCommaAfterRest(125);\n    return this.finishNode(prop, \"RestElement\");\n  }\n\n  parseBindingProperty() {\n    const prop = this.startNode();\n    const {\n      type,\n      start: startPos,\n      startLoc\n    } = this.state;\n\n    if (type === 21) {\n      return this.parseBindingRestProperty(prop);\n    } else if (type === 134) {\n      this.expectPlugin(\"destructuringPrivate\", startLoc);\n      this.classScope.usePrivateName(this.state.value, startLoc);\n      prop.key = this.parsePrivateName();\n    } else {\n      this.parsePropertyName(prop);\n    }\n\n    prop.method = false;\n    this.parseObjPropValue(prop, startPos, startLoc, false, false, true, false);\n    return prop;\n  }\n\n  parseAssignableListItem(allowModifiers, decorators) {\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left);\n    const elt = this.parseMaybeDefault(left.start, left.loc.start, left);\n\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n\n    return elt;\n  }\n\n  parseAssignableListItemTypes(param) {\n    return param;\n  }\n\n  parseMaybeDefault(startPos, startLoc, left) {\n    var _startLoc, _startPos, _left;\n\n    startLoc = (_startLoc = startLoc) != null ? _startLoc : this.state.startLoc;\n    startPos = (_startPos = startPos) != null ? _startPos : this.state.start;\n    left = (_left = left) != null ? _left : this.parseBindingAtom();\n    if (!this.eat(29)) return left;\n    const node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssignAllowIn();\n    return this.finishNode(node, \"AssignmentPattern\");\n  }\n\n  isValidLVal(type, isUnparenthesizedInAssign, binding) {\n    return getOwn({\n      AssignmentPattern: \"left\",\n      RestElement: \"argument\",\n      ObjectProperty: \"value\",\n      ParenthesizedExpression: \"expression\",\n      ArrayPattern: \"elements\",\n      ObjectPattern: \"properties\"\n    }, type);\n  }\n\n  checkLVal(expression, {\n    in: ancestor,\n    binding = BIND_NONE,\n    checkClashes = false,\n    strictModeChanged = false,\n    allowingSloppyLetBinding = !(binding & BIND_SCOPE_LEXICAL),\n    hasParenthesizedAncestor = false\n  }) {\n    var _expression$extra;\n\n    const type = expression.type;\n    if (this.isObjectMethod(expression)) return;\n\n    if (type === \"MemberExpression\") {\n      if (binding !== BIND_NONE) {\n        this.raise(Errors.InvalidPropertyBindingPattern, {\n          at: expression\n        });\n      }\n\n      return;\n    }\n\n    if (expression.type === \"Identifier\") {\n      this.checkIdentifier(expression, binding, strictModeChanged, allowingSloppyLetBinding);\n      const {\n        name\n      } = expression;\n\n      if (checkClashes) {\n        if (checkClashes.has(name)) {\n          this.raise(Errors.ParamDupe, {\n            at: expression\n          });\n        } else {\n          checkClashes.add(name);\n        }\n      }\n\n      return;\n    }\n\n    const validity = this.isValidLVal(expression.type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === \"AssignmentExpression\", binding);\n    if (validity === true) return;\n\n    if (validity === false) {\n      const ParseErrorClass = binding === BIND_NONE ? Errors.InvalidLhs : Errors.InvalidLhsBinding;\n      this.raise(ParseErrorClass, {\n        at: expression,\n        ancestor: ancestor.type === \"UpdateExpression\" ? {\n          type: \"UpdateExpression\",\n          prefix: ancestor.prefix\n        } : {\n          type: ancestor.type\n        }\n      });\n      return;\n    }\n\n    const [key, isParenthesizedExpression] = Array.isArray(validity) ? validity : [validity, type === \"ParenthesizedExpression\"];\n    const nextAncestor = expression.type === \"ArrayPattern\" || expression.type === \"ObjectPattern\" || expression.type === \"ParenthesizedExpression\" ? expression : ancestor;\n\n    for (const child of [].concat(expression[key])) {\n      if (child) {\n        this.checkLVal(child, {\n          in: nextAncestor,\n          binding,\n          checkClashes,\n          allowingSloppyLetBinding,\n          strictModeChanged,\n          hasParenthesizedAncestor: isParenthesizedExpression\n        });\n      }\n    }\n  }\n\n  checkIdentifier(at, bindingType, strictModeChanged = false, allowLetBinding = !(bindingType & BIND_SCOPE_LEXICAL)) {\n    if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {\n      if (bindingType === BIND_NONE) {\n        this.raise(Errors.StrictEvalArguments, {\n          at,\n          referenceName: at.name\n        });\n      } else {\n        this.raise(Errors.StrictEvalArgumentsBinding, {\n          at,\n          bindingName: at.name\n        });\n      }\n    }\n\n    if (!allowLetBinding && at.name === \"let\") {\n      this.raise(Errors.LetInLexicalBinding, {\n        at\n      });\n    }\n\n    if (!(bindingType & BIND_NONE)) {\n      this.declareNameFromIdentifier(at, bindingType);\n    }\n  }\n\n  declareNameFromIdentifier(identifier, binding) {\n    this.scope.declareName(identifier.name, binding, identifier.loc.start);\n  }\n\n  checkToRestConversion(node, allowPattern) {\n    switch (node.type) {\n      case \"ParenthesizedExpression\":\n        this.checkToRestConversion(node.expression, allowPattern);\n        break;\n\n      case \"Identifier\":\n      case \"MemberExpression\":\n        break;\n\n      case \"ArrayExpression\":\n      case \"ObjectExpression\":\n        if (allowPattern) break;\n\n      default:\n        this.raise(Errors.InvalidRestAssignmentPattern, {\n          at: node\n        });\n    }\n  }\n\n  checkCommaAfterRest(close) {\n    if (!this.match(12)) {\n      return false;\n    }\n\n    this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, {\n      at: this.state.startLoc\n    });\n    return true;\n  }\n\n}\n\nclass ExpressionParser extends LValParser {\n  checkProto(prop, isRecord, protoRef, refExpressionErrors) {\n    if (prop.type === \"SpreadElement\" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {\n      return;\n    }\n\n    const key = prop.key;\n    const name = key.type === \"Identifier\" ? key.name : key.value;\n\n    if (name === \"__proto__\") {\n      if (isRecord) {\n        this.raise(Errors.RecordNoProto, {\n          at: key\n        });\n        return;\n      }\n\n      if (protoRef.used) {\n        if (refExpressionErrors) {\n          if (refExpressionErrors.doubleProtoLoc === null) {\n            refExpressionErrors.doubleProtoLoc = key.loc.start;\n          }\n        } else {\n          this.raise(Errors.DuplicateProto, {\n            at: key\n          });\n        }\n      }\n\n      protoRef.used = true;\n    }\n  }\n\n  shouldExitDescending(expr, potentialArrowAt) {\n    return expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt;\n  }\n\n  getExpression() {\n    this.enterInitialScopes();\n    this.nextToken();\n    const expr = this.parseExpression();\n\n    if (!this.match(135)) {\n      this.unexpected();\n    }\n\n    this.finalizeRemainingComments();\n    expr.comments = this.state.comments;\n    expr.errors = this.state.errors;\n\n    if (this.options.tokens) {\n      expr.tokens = this.tokens;\n    }\n\n    return expr;\n  }\n\n  parseExpression(disallowIn, refExpressionErrors) {\n    if (disallowIn) {\n      return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n    }\n\n    return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n  }\n\n  parseExpressionBase(refExpressionErrors) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const expr = this.parseMaybeAssign(refExpressionErrors);\n\n    if (this.match(12)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.expressions = [expr];\n\n      while (this.eat(12)) {\n        node.expressions.push(this.parseMaybeAssign(refExpressionErrors));\n      }\n\n      this.toReferencedList(node.expressions);\n      return this.finishNode(node, \"SequenceExpression\");\n    }\n\n    return expr;\n  }\n\n  parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {\n    return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));\n  }\n\n  parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {\n    return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));\n  }\n\n  setOptionalParametersError(refExpressionErrors, resultError) {\n    var _resultError$loc;\n\n    refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == null ? void 0 : resultError.loc) != null ? _resultError$loc : this.state.startLoc;\n  }\n\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n\n    if (this.isContextual(105)) {\n      if (this.prodParam.hasYield) {\n        let left = this.parseYield();\n\n        if (afterLeftParse) {\n          left = afterLeftParse.call(this, left, startPos, startLoc);\n        }\n\n        return left;\n      }\n    }\n\n    let ownExpressionErrors;\n\n    if (refExpressionErrors) {\n      ownExpressionErrors = false;\n    } else {\n      refExpressionErrors = new ExpressionErrors();\n      ownExpressionErrors = true;\n    }\n\n    const {\n      type\n    } = this.state;\n\n    if (type === 10 || tokenIsIdentifier(type)) {\n      this.state.potentialArrowAt = this.state.start;\n    }\n\n    let left = this.parseMaybeConditional(refExpressionErrors);\n\n    if (afterLeftParse) {\n      left = afterLeftParse.call(this, left, startPos, startLoc);\n    }\n\n    if (tokenIsAssignment(this.state.type)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      const operator = this.state.value;\n      node.operator = operator;\n\n      if (this.match(29)) {\n        this.toAssignable(left, true);\n        node.left = left;\n\n        if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startPos) {\n          refExpressionErrors.doubleProtoLoc = null;\n        }\n\n        if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startPos) {\n          refExpressionErrors.shorthandAssignLoc = null;\n        }\n\n        if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startPos) {\n          this.checkDestructuringPrivate(refExpressionErrors);\n          refExpressionErrors.privateKeyLoc = null;\n        }\n      } else {\n        node.left = left;\n      }\n\n      this.next();\n      node.right = this.parseMaybeAssign();\n      this.checkLVal(left, {\n        in: this.finishNode(node, \"AssignmentExpression\")\n      });\n      return node;\n    } else if (ownExpressionErrors) {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n\n    return left;\n  }\n\n  parseMaybeConditional(refExpressionErrors) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprOps(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseConditional(expr, startPos, startLoc, refExpressionErrors);\n  }\n\n  parseConditional(expr, startPos, startLoc, refExpressionErrors) {\n    if (this.eat(17)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssignAllowIn();\n      this.expect(14);\n      node.alternate = this.parseMaybeAssign();\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n\n    return expr;\n  }\n\n  parseMaybeUnaryOrPrivate(refExpressionErrors) {\n    return this.match(134) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);\n  }\n\n  parseExprOps(refExpressionErrors) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseExprOp(expr, startPos, startLoc, -1);\n  }\n\n  parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {\n    if (this.isPrivateName(left)) {\n      const value = this.getPrivateNameSV(left);\n\n      if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {\n        this.raise(Errors.PrivateInExpectedIn, {\n          at: left,\n          identifierName: value\n        });\n      }\n\n      this.classScope.usePrivateName(value, left.loc.start);\n    }\n\n    const op = this.state.type;\n\n    if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {\n      let prec = tokenOperatorPrecedence(op);\n\n      if (prec > minPrec) {\n        if (op === 39) {\n          this.expectPlugin(\"pipelineOperator\");\n\n          if (this.state.inFSharpPipelineDirectBody) {\n            return left;\n          }\n\n          this.checkPipelineAtInfixOperator(left, leftStartLoc);\n        }\n\n        const node = this.startNodeAt(leftStartPos, leftStartLoc);\n        node.left = left;\n        node.operator = this.state.value;\n        const logical = op === 41 || op === 42;\n        const coalesce = op === 40;\n\n        if (coalesce) {\n          prec = tokenOperatorPrecedence(42);\n        }\n\n        this.next();\n\n        if (op === 39 && this.hasPlugin([\"pipelineOperator\", {\n          proposal: \"minimal\"\n        }])) {\n          if (this.state.type === 96 && this.prodParam.hasAwait) {\n            throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, {\n              at: this.state.startLoc\n            });\n          }\n        }\n\n        node.right = this.parseExprOpRightExpr(op, prec);\n        this.finishNode(node, logical || coalesce ? \"LogicalExpression\" : \"BinaryExpression\");\n        const nextOp = this.state.type;\n\n        if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {\n          throw this.raise(Errors.MixingCoalesceWithLogical, {\n            at: this.state.startLoc\n          });\n        }\n\n        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);\n      }\n    }\n\n    return left;\n  }\n\n  parseExprOpRightExpr(op, prec) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n\n    switch (op) {\n      case 39:\n        switch (this.getPluginOption(\"pipelineOperator\", \"proposal\")) {\n          case \"hack\":\n            return this.withTopicBindingContext(() => {\n              return this.parseHackPipeBody();\n            });\n\n          case \"smart\":\n            return this.withTopicBindingContext(() => {\n              if (this.prodParam.hasYield && this.isContextual(105)) {\n                throw this.raise(Errors.PipeBodyIsTighter, {\n                  at: this.state.startLoc\n                });\n              }\n\n              return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startPos, startLoc);\n            });\n\n          case \"fsharp\":\n            return this.withSoloAwaitPermittingContext(() => {\n              return this.parseFSharpPipelineBody(prec);\n            });\n        }\n\n      default:\n        return this.parseExprOpBaseRightExpr(op, prec);\n    }\n  }\n\n  parseExprOpBaseRightExpr(op, prec) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startPos, startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);\n  }\n\n  parseHackPipeBody() {\n    var _body$extra;\n\n    const {\n      startLoc\n    } = this.state;\n    const body = this.parseMaybeAssign();\n    const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);\n\n    if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {\n      this.raise(Errors.PipeUnparenthesizedBody, {\n        at: startLoc,\n        type: body.type\n      });\n    }\n\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      this.raise(Errors.PipeTopicUnused, {\n        at: startLoc\n      });\n    }\n\n    return body;\n  }\n\n  checkExponentialAfterUnary(node) {\n    if (this.match(57)) {\n      this.raise(Errors.UnexpectedTokenUnaryExponentiation, {\n        at: node.argument\n      });\n    }\n  }\n\n  parseMaybeUnary(refExpressionErrors, sawUnary) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const isAwait = this.isContextual(96);\n\n    if (isAwait && this.isAwaitAllowed()) {\n      this.next();\n      const expr = this.parseAwait(startPos, startLoc);\n      if (!sawUnary) this.checkExponentialAfterUnary(expr);\n      return expr;\n    }\n\n    const update = this.match(34);\n    const node = this.startNode();\n\n    if (tokenIsPrefix(this.state.type)) {\n      node.operator = this.state.value;\n      node.prefix = true;\n\n      if (this.match(72)) {\n        this.expectPlugin(\"throwExpressions\");\n      }\n\n      const isDelete = this.match(89);\n      this.next();\n      node.argument = this.parseMaybeUnary(null, true);\n      this.checkExpressionErrors(refExpressionErrors, true);\n\n      if (this.state.strict && isDelete) {\n        const arg = node.argument;\n\n        if (arg.type === \"Identifier\") {\n          this.raise(Errors.StrictDelete, {\n            at: node\n          });\n        } else if (this.hasPropertyAsPrivateName(arg)) {\n          this.raise(Errors.DeletePrivateField, {\n            at: node\n          });\n        }\n      }\n\n      if (!update) {\n        if (!sawUnary) this.checkExponentialAfterUnary(node);\n        return this.finishNode(node, \"UnaryExpression\");\n      }\n    }\n\n    const expr = this.parseUpdate(node, update, refExpressionErrors);\n\n    if (isAwait) {\n      const {\n        type\n      } = this.state;\n      const startsExpr = this.hasPlugin(\"v8intrinsic\") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);\n\n      if (startsExpr && !this.isAmbiguousAwait()) {\n        this.raiseOverwrite(Errors.AwaitNotInAsyncContext, {\n          at: startLoc\n        });\n        return this.parseAwait(startPos, startLoc);\n      }\n    }\n\n    return expr;\n  }\n\n  parseUpdate(node, update, refExpressionErrors) {\n    if (update) {\n      this.checkLVal(node.argument, {\n        in: this.finishNode(node, \"UpdateExpression\")\n      });\n      return node;\n    }\n\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let expr = this.parseExprSubscripts(refExpressionErrors);\n    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;\n\n    while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.operator = this.state.value;\n      node.prefix = false;\n      node.argument = expr;\n      this.next();\n      this.checkLVal(expr, {\n        in: expr = this.finishNode(node, \"UpdateExpression\")\n      });\n    }\n\n    return expr;\n  }\n\n  parseExprSubscripts(refExpressionErrors) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprAtom(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseSubscripts(expr, startPos, startLoc);\n  }\n\n  parseSubscripts(base, startPos, startLoc, noCalls) {\n    const state = {\n      optionalChainMember: false,\n      maybeAsyncArrow: this.atPossibleAsyncArrow(base),\n      stop: false\n    };\n\n    do {\n      base = this.parseSubscript(base, startPos, startLoc, noCalls, state);\n      state.maybeAsyncArrow = false;\n    } while (!state.stop);\n\n    return base;\n  }\n\n  parseSubscript(base, startPos, startLoc, noCalls, state) {\n    const {\n      type\n    } = this.state;\n\n    if (!noCalls && type === 15) {\n      return this.parseBind(base, startPos, startLoc, noCalls, state);\n    } else if (tokenIsTemplate(type)) {\n      return this.parseTaggedTemplateExpression(base, startPos, startLoc, state);\n    }\n\n    let optional = false;\n\n    if (type === 18) {\n      if (noCalls && this.lookaheadCharCode() === 40) {\n        state.stop = true;\n        return base;\n      }\n\n      state.optionalChainMember = optional = true;\n      this.next();\n    }\n\n    if (!noCalls && this.match(10)) {\n      return this.parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional);\n    } else {\n      const computed = this.eat(0);\n\n      if (computed || optional || this.eat(16)) {\n        return this.parseMember(base, startPos, startLoc, state, computed, optional);\n      } else {\n        state.stop = true;\n        return base;\n      }\n    }\n  }\n\n  parseMember(base, startPos, startLoc, state, computed, optional) {\n    const node = this.startNodeAt(startPos, startLoc);\n    node.object = base;\n    node.computed = computed;\n\n    if (computed) {\n      node.property = this.parseExpression();\n      this.expect(3);\n    } else if (this.match(134)) {\n      if (base.type === \"Super\") {\n        this.raise(Errors.SuperPrivateField, {\n          at: startLoc\n        });\n      }\n\n      this.classScope.usePrivateName(this.state.value, this.state.startLoc);\n      node.property = this.parsePrivateName();\n    } else {\n      node.property = this.parseIdentifier(true);\n    }\n\n    if (state.optionalChainMember) {\n      node.optional = optional;\n      return this.finishNode(node, \"OptionalMemberExpression\");\n    } else {\n      return this.finishNode(node, \"MemberExpression\");\n    }\n  }\n\n  parseBind(base, startPos, startLoc, noCalls, state) {\n    const node = this.startNodeAt(startPos, startLoc);\n    node.object = base;\n    this.next();\n    node.callee = this.parseNoCallExpr();\n    state.stop = true;\n    return this.parseSubscripts(this.finishNode(node, \"BindExpression\"), startPos, startLoc, noCalls);\n  }\n\n  parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional) {\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    let refExpressionErrors = null;\n    this.state.maybeInArrowParameters = true;\n    this.next();\n    let node = this.startNodeAt(startPos, startLoc);\n    node.callee = base;\n    const {\n      maybeAsyncArrow,\n      optionalChainMember\n    } = state;\n\n    if (maybeAsyncArrow) {\n      this.expressionScope.enter(newAsyncArrowScope());\n      refExpressionErrors = new ExpressionErrors();\n    }\n\n    if (optionalChainMember) {\n      node.optional = optional;\n    }\n\n    if (optional) {\n      node.arguments = this.parseCallExpressionArguments(11);\n    } else {\n      node.arguments = this.parseCallExpressionArguments(11, base.type === \"Import\", base.type !== \"Super\", node, refExpressionErrors);\n    }\n\n    this.finishCallExpression(node, optionalChainMember);\n\n    if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {\n      state.stop = true;\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      node = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), node);\n    } else {\n      if (maybeAsyncArrow) {\n        this.checkExpressionErrors(refExpressionErrors, true);\n        this.expressionScope.exit();\n      }\n\n      this.toReferencedArguments(node);\n    }\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return node;\n  }\n\n  toReferencedArguments(node, isParenthesizedExpr) {\n    this.toReferencedListDeep(node.arguments, isParenthesizedExpr);\n  }\n\n  parseTaggedTemplateExpression(base, startPos, startLoc, state) {\n    const node = this.startNodeAt(startPos, startLoc);\n    node.tag = base;\n    node.quasi = this.parseTemplate(true);\n\n    if (state.optionalChainMember) {\n      this.raise(Errors.OptionalChainingNoTemplate, {\n        at: startLoc\n      });\n    }\n\n    return this.finishNode(node, \"TaggedTemplateExpression\");\n  }\n\n  atPossibleAsyncArrow(base) {\n    return base.type === \"Identifier\" && base.name === \"async\" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;\n  }\n\n  finishCallExpression(node, optional) {\n    if (node.callee.type === \"Import\") {\n      if (node.arguments.length === 2) {\n        {\n          if (!this.hasPlugin(\"moduleAttributes\")) {\n            this.expectPlugin(\"importAssertions\");\n          }\n        }\n      }\n\n      if (node.arguments.length === 0 || node.arguments.length > 2) {\n        this.raise(Errors.ImportCallArity, {\n          at: node,\n          maxArgumentCount: this.hasPlugin(\"importAssertions\") || this.hasPlugin(\"moduleAttributes\") ? 2 : 1\n        });\n      } else {\n        for (const arg of node.arguments) {\n          if (arg.type === \"SpreadElement\") {\n            this.raise(Errors.ImportCallSpreadArgument, {\n              at: arg\n            });\n          }\n        }\n      }\n    }\n\n    return this.finishNode(node, optional ? \"OptionalCallExpression\" : \"CallExpression\");\n  }\n\n  parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {\n    const elts = [];\n    let first = true;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n\n        if (this.match(close)) {\n          if (dynamicImport && !this.hasPlugin(\"importAssertions\") && !this.hasPlugin(\"moduleAttributes\")) {\n            this.raise(Errors.ImportCallArgumentTrailingComma, {\n              at: this.state.lastTokStartLoc\n            });\n          }\n\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n\n          this.next();\n          break;\n        }\n      }\n\n      elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));\n    }\n\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return elts;\n  }\n\n  shouldParseAsyncArrow() {\n    return this.match(19) && !this.canInsertSemicolon();\n  }\n\n  parseAsyncArrowFromCallExpression(node, call) {\n    var _call$extra;\n\n    this.resetPreviousNodeTrailingComments(call);\n    this.expect(19);\n    this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);\n\n    if (call.innerComments) {\n      setInnerComments(node, call.innerComments);\n    }\n\n    if (call.callee.trailingComments) {\n      setInnerComments(node, call.callee.trailingComments);\n    }\n\n    return node;\n  }\n\n  parseNoCallExpr() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n  }\n\n  parseExprAtom(refExpressionErrors) {\n    let node;\n    const {\n      type\n    } = this.state;\n\n    switch (type) {\n      case 79:\n        return this.parseSuper();\n\n      case 83:\n        node = this.startNode();\n        this.next();\n\n        if (this.match(16)) {\n          return this.parseImportMetaProperty(node);\n        }\n\n        if (!this.match(10)) {\n          this.raise(Errors.UnsupportedImport, {\n            at: this.state.lastTokStartLoc\n          });\n        }\n\n        return this.finishNode(node, \"Import\");\n\n      case 78:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"ThisExpression\");\n\n      case 90:\n        {\n          return this.parseDo(this.startNode(), false);\n        }\n\n      case 56:\n      case 31:\n        {\n          this.readRegexp();\n          return this.parseRegExpLiteral(this.state.value);\n        }\n\n      case 130:\n        return this.parseNumericLiteral(this.state.value);\n\n      case 131:\n        return this.parseBigIntLiteral(this.state.value);\n\n      case 132:\n        return this.parseDecimalLiteral(this.state.value);\n\n      case 129:\n        return this.parseStringLiteral(this.state.value);\n\n      case 84:\n        return this.parseNullLiteral();\n\n      case 85:\n        return this.parseBooleanLiteral(true);\n\n      case 86:\n        return this.parseBooleanLiteral(false);\n\n      case 10:\n        {\n          const canBeArrow = this.state.potentialArrowAt === this.state.start;\n          return this.parseParenAndDistinguishExpression(canBeArrow);\n        }\n\n      case 2:\n      case 1:\n        {\n          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);\n        }\n\n      case 0:\n        {\n          return this.parseArrayLike(3, true, false, refExpressionErrors);\n        }\n\n      case 6:\n      case 7:\n        {\n          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);\n        }\n\n      case 5:\n        {\n          return this.parseObjectLike(8, false, false, refExpressionErrors);\n        }\n\n      case 68:\n        return this.parseFunctionOrFunctionSent();\n\n      case 26:\n        this.parseDecorators();\n\n      case 80:\n        node = this.startNode();\n        this.takeDecorators(node);\n        return this.parseClass(node, false);\n\n      case 77:\n        return this.parseNewOrNewTarget();\n\n      case 25:\n      case 24:\n        return this.parseTemplate(false);\n\n      case 15:\n        {\n          node = this.startNode();\n          this.next();\n          node.object = null;\n          const callee = node.callee = this.parseNoCallExpr();\n\n          if (callee.type === \"MemberExpression\") {\n            return this.finishNode(node, \"BindExpression\");\n          } else {\n            throw this.raise(Errors.UnsupportedBind, {\n              at: callee\n            });\n          }\n        }\n\n      case 134:\n        {\n          this.raise(Errors.PrivateInExpectedIn, {\n            at: this.state.startLoc,\n            identifierName: this.state.value\n          });\n          return this.parsePrivateName();\n        }\n\n      case 33:\n        {\n          return this.parseTopicReferenceThenEqualsSign(54, \"%\");\n        }\n\n      case 32:\n        {\n          return this.parseTopicReferenceThenEqualsSign(44, \"^\");\n        }\n\n      case 37:\n      case 38:\n        {\n          return this.parseTopicReference(\"hack\");\n        }\n\n      case 44:\n      case 54:\n      case 27:\n        {\n          const pipeProposal = this.getPluginOption(\"pipelineOperator\", \"proposal\");\n\n          if (pipeProposal) {\n            return this.parseTopicReference(pipeProposal);\n          } else {\n            throw this.unexpected();\n          }\n        }\n\n      case 47:\n        {\n          const lookaheadCh = this.input.codePointAt(this.nextTokenStart());\n\n          if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {\n            this.expectOnePlugin([\"jsx\", \"flow\", \"typescript\"]);\n            break;\n          } else {\n            throw this.unexpected();\n          }\n        }\n\n      default:\n        if (tokenIsIdentifier(type)) {\n          if (this.isContextual(123) && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak()) {\n            return this.parseModuleExpression();\n          }\n\n          const canBeArrow = this.state.potentialArrowAt === this.state.start;\n          const containsEsc = this.state.containsEsc;\n          const id = this.parseIdentifier();\n\n          if (!containsEsc && id.name === \"async\" && !this.canInsertSemicolon()) {\n            const {\n              type\n            } = this.state;\n\n            if (type === 68) {\n              this.resetPreviousNodeTrailingComments(id);\n              this.next();\n              return this.parseFunction(this.startNodeAtNode(id), undefined, true);\n            } else if (tokenIsIdentifier(type)) {\n              if (this.lookaheadCharCode() === 61) {\n                return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));\n              } else {\n                return id;\n              }\n            } else if (type === 90) {\n              this.resetPreviousNodeTrailingComments(id);\n              return this.parseDo(this.startNodeAtNode(id), true);\n            }\n          }\n\n          if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {\n            this.next();\n            return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);\n          }\n\n          return id;\n        } else {\n          throw this.unexpected();\n        }\n\n    }\n  }\n\n  parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {\n    const pipeProposal = this.getPluginOption(\"pipelineOperator\", \"proposal\");\n\n    if (pipeProposal) {\n      this.state.type = topicTokenType;\n      this.state.value = topicTokenValue;\n      this.state.pos--;\n      this.state.end--;\n      this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);\n      return this.parseTopicReference(pipeProposal);\n    } else {\n      throw this.unexpected();\n    }\n  }\n\n  parseTopicReference(pipeProposal) {\n    const node = this.startNode();\n    const startLoc = this.state.startLoc;\n    const tokenType = this.state.type;\n    this.next();\n    return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);\n  }\n\n  finishTopicReference(node, startLoc, pipeProposal, tokenType) {\n    if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {\n      const nodeType = pipeProposal === \"smart\" ? \"PipelinePrimaryTopicReference\" : \"TopicReference\";\n\n      if (!this.topicReferenceIsAllowedInCurrentContext()) {\n        this.raise(pipeProposal === \"smart\" ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound, {\n          at: startLoc\n        });\n      }\n\n      this.registerTopicReference();\n      return this.finishNode(node, nodeType);\n    } else {\n      throw this.raise(Errors.PipeTopicUnconfiguredToken, {\n        at: startLoc,\n        token: tokenLabelName(tokenType)\n      });\n    }\n  }\n\n  testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {\n    switch (pipeProposal) {\n      case \"hack\":\n        {\n          return this.hasPlugin([\"pipelineOperator\", {\n            topicToken: tokenLabelName(tokenType)\n          }]);\n        }\n\n      case \"smart\":\n        return tokenType === 27;\n\n      default:\n        throw this.raise(Errors.PipeTopicRequiresHackPipes, {\n          at: startLoc\n        });\n    }\n  }\n\n  parseAsyncArrowUnaryFunction(node) {\n    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));\n    const params = [this.parseIdentifier()];\n    this.prodParam.exit();\n\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.LineTerminatorBeforeArrow, {\n        at: this.state.curPosition()\n      });\n    }\n\n    this.expect(19);\n    this.parseArrowExpression(node, params, true);\n    return node;\n  }\n\n  parseDo(node, isAsync) {\n    this.expectPlugin(\"doExpressions\");\n\n    if (isAsync) {\n      this.expectPlugin(\"asyncDoExpressions\");\n    }\n\n    node.async = isAsync;\n    this.next();\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n\n    if (isAsync) {\n      this.prodParam.enter(PARAM_AWAIT);\n      node.body = this.parseBlock();\n      this.prodParam.exit();\n    } else {\n      node.body = this.parseBlock();\n    }\n\n    this.state.labels = oldLabels;\n    return this.finishNode(node, \"DoExpression\");\n  }\n\n  parseSuper() {\n    const node = this.startNode();\n    this.next();\n\n    if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {\n      this.raise(Errors.SuperNotAllowed, {\n        at: node\n      });\n    } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {\n      this.raise(Errors.UnexpectedSuper, {\n        at: node\n      });\n    }\n\n    if (!this.match(10) && !this.match(0) && !this.match(16)) {\n      this.raise(Errors.UnsupportedSuper, {\n        at: node\n      });\n    }\n\n    return this.finishNode(node, \"Super\");\n  }\n\n  parsePrivateName() {\n    const node = this.startNode();\n    const id = this.startNodeAt(this.state.start + 1, new Position(this.state.curLine, this.state.start + 1 - this.state.lineStart, this.state.start + 1));\n    const name = this.state.value;\n    this.next();\n    node.id = this.createIdentifier(id, name);\n    return this.finishNode(node, \"PrivateName\");\n  }\n\n  parseFunctionOrFunctionSent() {\n    const node = this.startNode();\n    this.next();\n\n    if (this.prodParam.hasYield && this.match(16)) {\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \"function\");\n      this.next();\n\n      if (this.match(102)) {\n        this.expectPlugin(\"functionSent\");\n      } else if (!this.hasPlugin(\"functionSent\")) {\n        this.unexpected();\n      }\n\n      return this.parseMetaProperty(node, meta, \"sent\");\n    }\n\n    return this.parseFunction(node);\n  }\n\n  parseMetaProperty(node, meta, propertyName) {\n    node.meta = meta;\n    const containsEsc = this.state.containsEsc;\n    node.property = this.parseIdentifier(true);\n\n    if (node.property.name !== propertyName || containsEsc) {\n      this.raise(Errors.UnsupportedMetaProperty, {\n        at: node.property,\n        target: meta.name,\n        onlyValidPropertyName: propertyName\n      });\n    }\n\n    return this.finishNode(node, \"MetaProperty\");\n  }\n\n  parseImportMetaProperty(node) {\n    const id = this.createIdentifier(this.startNodeAtNode(node), \"import\");\n    this.next();\n\n    if (this.isContextual(100)) {\n      if (!this.inModule) {\n        this.raise(Errors.ImportMetaOutsideModule, {\n          at: id\n        });\n      }\n\n      this.sawUnambiguousESM = true;\n    }\n\n    return this.parseMetaProperty(node, id, \"meta\");\n  }\n\n  parseLiteralAtNode(value, type, node) {\n    this.addExtra(node, \"rawValue\", value);\n    this.addExtra(node, \"raw\", this.input.slice(node.start, this.state.end));\n    node.value = value;\n    this.next();\n    return this.finishNode(node, type);\n  }\n\n  parseLiteral(value, type) {\n    const node = this.startNode();\n    return this.parseLiteralAtNode(value, type, node);\n  }\n\n  parseStringLiteral(value) {\n    return this.parseLiteral(value, \"StringLiteral\");\n  }\n\n  parseNumericLiteral(value) {\n    return this.parseLiteral(value, \"NumericLiteral\");\n  }\n\n  parseBigIntLiteral(value) {\n    return this.parseLiteral(value, \"BigIntLiteral\");\n  }\n\n  parseDecimalLiteral(value) {\n    return this.parseLiteral(value, \"DecimalLiteral\");\n  }\n\n  parseRegExpLiteral(value) {\n    const node = this.parseLiteral(value.value, \"RegExpLiteral\");\n    node.pattern = value.pattern;\n    node.flags = value.flags;\n    return node;\n  }\n\n  parseBooleanLiteral(value) {\n    const node = this.startNode();\n    node.value = value;\n    this.next();\n    return this.finishNode(node, \"BooleanLiteral\");\n  }\n\n  parseNullLiteral() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"NullLiteral\");\n  }\n\n  parseParenAndDistinguishExpression(canBeArrow) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let val;\n    this.next();\n    this.expressionScope.enter(newArrowHeadScope());\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.maybeInArrowParameters = true;\n    this.state.inFSharpPipelineDirectBody = false;\n    const innerStartPos = this.state.start;\n    const innerStartLoc = this.state.startLoc;\n    const exprList = [];\n    const refExpressionErrors = new ExpressionErrors();\n    let first = true;\n    let spreadStartLoc;\n    let optionalCommaStartLoc;\n\n    while (!this.match(11)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);\n\n        if (this.match(11)) {\n          optionalCommaStartLoc = this.state.startLoc;\n          break;\n        }\n      }\n\n      if (this.match(21)) {\n        const spreadNodeStartPos = this.state.start;\n        const spreadNodeStartLoc = this.state.startLoc;\n        spreadStartLoc = this.state.startLoc;\n        exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc));\n\n        if (!this.checkCommaAfterRest(41)) {\n          break;\n        }\n      } else {\n        exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));\n      }\n    }\n\n    const innerEndLoc = this.state.lastTokEndLoc;\n    this.expect(11);\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let arrowNode = this.startNodeAt(startPos, startLoc);\n\n    if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      this.parseArrowExpression(arrowNode, exprList, false);\n      return arrowNode;\n    }\n\n    this.expressionScope.exit();\n\n    if (!exprList.length) {\n      this.unexpected(this.state.lastTokStartLoc);\n    }\n\n    if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);\n    if (spreadStartLoc) this.unexpected(spreadStartLoc);\n    this.checkExpressionErrors(refExpressionErrors, true);\n    this.toReferencedListDeep(exprList, true);\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.finishNode(val, \"SequenceExpression\");\n      this.resetEndLocation(val, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n\n    return this.wrapParenthesis(startPos, startLoc, val);\n  }\n\n  wrapParenthesis(startPos, startLoc, expression) {\n    if (!this.options.createParenthesizedExpressions) {\n      this.addExtra(expression, \"parenthesized\", true);\n      this.addExtra(expression, \"parenStart\", startPos);\n      this.takeSurroundingComments(expression, startPos, this.state.lastTokEndLoc.index);\n      return expression;\n    }\n\n    const parenExpression = this.startNodeAt(startPos, startLoc);\n    parenExpression.expression = expression;\n    this.finishNode(parenExpression, \"ParenthesizedExpression\");\n    return parenExpression;\n  }\n\n  shouldParseArrow(params) {\n    return !this.canInsertSemicolon();\n  }\n\n  parseArrow(node) {\n    if (this.eat(19)) {\n      return node;\n    }\n  }\n\n  parseParenItem(node, startPos, startLoc) {\n    return node;\n  }\n\n  parseNewOrNewTarget() {\n    const node = this.startNode();\n    this.next();\n\n    if (this.match(16)) {\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \"new\");\n      this.next();\n      const metaProp = this.parseMetaProperty(node, meta, \"target\");\n\n      if (!this.scope.inNonArrowFunction && !this.scope.inClass) {\n        this.raise(Errors.UnexpectedNewTarget, {\n          at: metaProp\n        });\n      }\n\n      return metaProp;\n    }\n\n    return this.parseNew(node);\n  }\n\n  parseNew(node) {\n    this.parseNewCallee(node);\n\n    if (this.eat(10)) {\n      const args = this.parseExprList(11);\n      this.toReferencedList(args);\n      node.arguments = args;\n    } else {\n      node.arguments = [];\n    }\n\n    return this.finishNode(node, \"NewExpression\");\n  }\n\n  parseNewCallee(node) {\n    node.callee = this.parseNoCallExpr();\n\n    if (node.callee.type === \"Import\") {\n      this.raise(Errors.ImportCallNotNewExpression, {\n        at: node.callee\n      });\n    } else if (this.isOptionalChain(node.callee)) {\n      this.raise(Errors.OptionalChainingNoNew, {\n        at: this.state.lastTokEndLoc\n      });\n    } else if (this.eat(18)) {\n      this.raise(Errors.OptionalChainingNoNew, {\n        at: this.state.startLoc\n      });\n    }\n  }\n\n  parseTemplateElement(isTagged) {\n    const {\n      start,\n      startLoc,\n      end,\n      value\n    } = this.state;\n    const elemStart = start + 1;\n    const elem = this.startNodeAt(elemStart, createPositionWithColumnOffset(startLoc, 1));\n\n    if (value === null) {\n      if (!isTagged) {\n        this.raise(Errors.InvalidEscapeSequenceTemplate, {\n          at: createPositionWithColumnOffset(startLoc, 2)\n        });\n      }\n    }\n\n    const isTail = this.match(24);\n    const endOffset = isTail ? -1 : -2;\n    const elemEnd = end + endOffset;\n    elem.value = {\n      raw: this.input.slice(elemStart, elemEnd).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: value === null ? null : value.slice(1, endOffset)\n    };\n    elem.tail = isTail;\n    this.next();\n    this.finishNode(elem, \"TemplateElement\");\n    this.resetEndLocation(elem, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));\n    return elem;\n  }\n\n  parseTemplate(isTagged) {\n    const node = this.startNode();\n    node.expressions = [];\n    let curElt = this.parseTemplateElement(isTagged);\n    node.quasis = [curElt];\n\n    while (!curElt.tail) {\n      node.expressions.push(this.parseTemplateSubstitution());\n      this.readTemplateContinuation();\n      node.quasis.push(curElt = this.parseTemplateElement(isTagged));\n    }\n\n    return this.finishNode(node, \"TemplateLiteral\");\n  }\n\n  parseTemplateSubstitution() {\n    return this.parseExpression();\n  }\n\n  parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {\n    if (isRecord) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const propHash = Object.create(null);\n    let first = true;\n    const node = this.startNode();\n    node.properties = [];\n    this.next();\n\n    while (!this.match(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n\n        if (this.match(close)) {\n          this.addTrailingCommaExtraToNode(node);\n          break;\n        }\n      }\n\n      let prop;\n\n      if (isPattern) {\n        prop = this.parseBindingProperty();\n      } else {\n        prop = this.parsePropertyDefinition(refExpressionErrors);\n        this.checkProto(prop, isRecord, propHash, refExpressionErrors);\n      }\n\n      if (isRecord && !this.isObjectProperty(prop) && prop.type !== \"SpreadElement\") {\n        this.raise(Errors.InvalidRecordProperty, {\n          at: prop\n        });\n      }\n\n      if (prop.shorthand) {\n        this.addExtra(prop, \"shorthand\", true);\n      }\n\n      node.properties.push(prop);\n    }\n\n    this.next();\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let type = \"ObjectExpression\";\n\n    if (isPattern) {\n      type = \"ObjectPattern\";\n    } else if (isRecord) {\n      type = \"RecordExpression\";\n    }\n\n    return this.finishNode(node, type);\n  }\n\n  addTrailingCommaExtraToNode(node) {\n    this.addExtra(node, \"trailingComma\", this.state.lastTokStart);\n    this.addExtra(node, \"trailingCommaLoc\", this.state.lastTokStartLoc, false);\n  }\n\n  maybeAsyncOrAccessorProp(prop) {\n    return !prop.computed && prop.key.type === \"Identifier\" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));\n  }\n\n  parsePropertyDefinition(refExpressionErrors) {\n    let decorators = [];\n\n    if (this.match(26)) {\n      if (this.hasPlugin(\"decorators\")) {\n        this.raise(Errors.UnsupportedPropertyDecorator, {\n          at: this.state.startLoc\n        });\n      }\n\n      while (this.match(26)) {\n        decorators.push(this.parseDecorator());\n      }\n    }\n\n    const prop = this.startNode();\n    let isAsync = false;\n    let isAccessor = false;\n    let startPos;\n    let startLoc;\n\n    if (this.match(21)) {\n      if (decorators.length) this.unexpected();\n      return this.parseSpread();\n    }\n\n    if (decorators.length) {\n      prop.decorators = decorators;\n      decorators = [];\n    }\n\n    prop.method = false;\n\n    if (refExpressionErrors) {\n      startPos = this.state.start;\n      startLoc = this.state.startLoc;\n    }\n\n    let isGenerator = this.eat(55);\n    this.parsePropertyNamePrefixOperator(prop);\n    const containsEsc = this.state.containsEsc;\n    const key = this.parsePropertyName(prop, refExpressionErrors);\n\n    if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {\n      const keyName = key.name;\n\n      if (keyName === \"async\" && !this.hasPrecedingLineBreak()) {\n        isAsync = true;\n        this.resetPreviousNodeTrailingComments(key);\n        isGenerator = this.eat(55);\n        this.parsePropertyName(prop);\n      }\n\n      if (keyName === \"get\" || keyName === \"set\") {\n        isAccessor = true;\n        this.resetPreviousNodeTrailingComments(key);\n        prop.kind = keyName;\n\n        if (this.match(55)) {\n          isGenerator = true;\n          this.raise(Errors.AccessorIsGenerator, {\n            at: this.state.curPosition(),\n            kind: keyName\n          });\n          this.next();\n        }\n\n        this.parsePropertyName(prop);\n      }\n    }\n\n    this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);\n    return prop;\n  }\n\n  getGetterSetterExpectedParamCount(method) {\n    return method.kind === \"get\" ? 0 : 1;\n  }\n\n  getObjectOrClassMethodParams(method) {\n    return method.params;\n  }\n\n  checkGetterSetterParams(method) {\n    var _params;\n\n    const paramCount = this.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n\n    if (params.length !== paramCount) {\n      this.raise(method.kind === \"get\" ? Errors.BadGetterArity : Errors.BadSetterArity, {\n        at: method\n      });\n    }\n\n    if (method.kind === \"set\" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === \"RestElement\") {\n      this.raise(Errors.BadSetterRestParameter, {\n        at: method\n      });\n    }\n  }\n\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {\n    if (isAccessor) {\n      this.parseMethod(prop, isGenerator, false, false, false, \"ObjectMethod\");\n      this.checkGetterSetterParams(prop);\n      return prop;\n    }\n\n    if (isAsync || isGenerator || this.match(10)) {\n      if (isPattern) this.unexpected();\n      prop.kind = \"method\";\n      prop.method = true;\n      return this.parseMethod(prop, isGenerator, isAsync, false, false, \"ObjectMethod\");\n    }\n  }\n\n  parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {\n    prop.shorthand = false;\n\n    if (this.eat(14)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n\n    if (!prop.computed && prop.key.type === \"Identifier\") {\n      this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);\n\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key));\n      } else if (this.match(29)) {\n        const shorthandAssignLoc = this.state.startLoc;\n\n        if (refExpressionErrors != null) {\n          if (refExpressionErrors.shorthandAssignLoc === null) {\n            refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;\n          }\n        } else {\n          this.raise(Errors.InvalidCoverInitializedName, {\n            at: shorthandAssignLoc\n          });\n        }\n\n        prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key));\n      } else {\n        prop.value = cloneIdentifier(prop.key);\n      }\n\n      prop.shorthand = true;\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n  }\n\n  parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);\n    if (!node) this.unexpected();\n    return node;\n  }\n\n  parsePropertyName(prop, refExpressionErrors) {\n    if (this.eat(0)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssignAllowIn();\n      this.expect(3);\n    } else {\n      const {\n        type,\n        value\n      } = this.state;\n      let key;\n\n      if (tokenIsKeywordOrIdentifier(type)) {\n        key = this.parseIdentifier(true);\n      } else {\n        switch (type) {\n          case 130:\n            key = this.parseNumericLiteral(value);\n            break;\n\n          case 129:\n            key = this.parseStringLiteral(value);\n            break;\n\n          case 131:\n            key = this.parseBigIntLiteral(value);\n            break;\n\n          case 132:\n            key = this.parseDecimalLiteral(value);\n            break;\n\n          case 134:\n            {\n              const privateKeyLoc = this.state.startLoc;\n\n              if (refExpressionErrors != null) {\n                if (refExpressionErrors.privateKeyLoc === null) {\n                  refExpressionErrors.privateKeyLoc = privateKeyLoc;\n                }\n              } else {\n                this.raise(Errors.UnexpectedPrivateField, {\n                  at: privateKeyLoc\n                });\n              }\n\n              key = this.parsePrivateName();\n              break;\n            }\n\n          default:\n            throw this.unexpected();\n        }\n      }\n\n      prop.key = key;\n\n      if (type !== 134) {\n        prop.computed = false;\n      }\n    }\n\n    return prop.key;\n  }\n\n  initFunction(node, isAsync) {\n    node.id = null;\n    node.generator = false;\n    node.async = !!isAsync;\n  }\n\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    this.initFunction(node, isAsync);\n    node.generator = !!isGenerator;\n    const allowModifiers = isConstructor;\n    this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    this.parseFunctionParams(node, allowModifiers);\n    this.parseFunctionBodyAndFinish(node, type, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    return node;\n  }\n\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    if (isTuple) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return this.finishNode(node, isTuple ? \"TupleExpression\" : \"ArrayExpression\");\n  }\n\n  parseArrowExpression(node, params, isAsync, trailingCommaLoc) {\n    this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);\n    let flags = functionFlags(isAsync, false);\n\n    if (!this.match(5) && this.prodParam.hasIn) {\n      flags |= PARAM_IN;\n    }\n\n    this.prodParam.enter(flags);\n    this.initFunction(node, isAsync);\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n\n    if (params) {\n      this.state.maybeInArrowParameters = true;\n      this.setArrowFunctionParameters(node, params, trailingCommaLoc);\n    }\n\n    this.state.maybeInArrowParameters = false;\n    this.parseFunctionBody(node, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n  }\n\n  setArrowFunctionParameters(node, params, trailingCommaLoc) {\n    this.toAssignableList(params, trailingCommaLoc, false);\n    node.params = params;\n  }\n\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    this.parseFunctionBody(node, false, isMethod);\n    this.finishNode(node, type);\n  }\n\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    const isExpression = allowExpression && !this.match(5);\n    this.expressionScope.enter(newExpressionScope());\n\n    if (isExpression) {\n      node.body = this.parseMaybeAssign();\n      this.checkParams(node, false, allowExpression, false);\n    } else {\n      const oldStrict = this.state.strict;\n      const oldLabels = this.state.labels;\n      this.state.labels = [];\n      this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);\n      node.body = this.parseBlock(true, false, hasStrictModeDirective => {\n        const nonSimple = !this.isSimpleParamList(node.params);\n\n        if (hasStrictModeDirective && nonSimple) {\n          this.raise(Errors.IllegalLanguageModeDirective, {\n            at: (node.kind === \"method\" || node.kind === \"constructor\") && !!node.key ? node.key.loc.end : node\n          });\n        }\n\n        const strictModeChanged = !oldStrict && this.state.strict;\n        this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);\n\n        if (this.state.strict && node.id) {\n          this.checkIdentifier(node.id, BIND_OUTSIDE, strictModeChanged);\n        }\n      });\n      this.prodParam.exit();\n      this.state.labels = oldLabels;\n    }\n\n    this.expressionScope.exit();\n  }\n\n  isSimpleParameter(node) {\n    return node.type === \"Identifier\";\n  }\n\n  isSimpleParamList(params) {\n    for (let i = 0, len = params.length; i < len; i++) {\n      if (!this.isSimpleParameter(params[i])) return false;\n    }\n\n    return true;\n  }\n\n  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {\n    const checkClashes = !allowDuplicates && new Set();\n    const formalParameters = {\n      type: \"FormalParameters\"\n    };\n\n    for (const param of node.params) {\n      this.checkLVal(param, {\n        in: formalParameters,\n        binding: BIND_VAR,\n        checkClashes,\n        strictModeChanged\n      });\n    }\n  }\n\n  parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {\n    const elts = [];\n    let first = true;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n\n        if (this.match(close)) {\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n\n          this.next();\n          break;\n        }\n      }\n\n      elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));\n    }\n\n    return elts;\n  }\n\n  parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {\n    let elt;\n\n    if (this.match(12)) {\n      if (!allowEmpty) {\n        this.raise(Errors.UnexpectedToken, {\n          at: this.state.curPosition(),\n          unexpected: \",\"\n        });\n      }\n\n      elt = null;\n    } else if (this.match(21)) {\n      const spreadNodeStartPos = this.state.start;\n      const spreadNodeStartLoc = this.state.startLoc;\n      elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartPos, spreadNodeStartLoc);\n    } else if (this.match(17)) {\n      this.expectPlugin(\"partialApplication\");\n\n      if (!allowPlaceholder) {\n        this.raise(Errors.UnexpectedArgumentPlaceholder, {\n          at: this.state.startLoc\n        });\n      }\n\n      const node = this.startNode();\n      this.next();\n      elt = this.finishNode(node, \"ArgumentPlaceholder\");\n    } else {\n      elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);\n    }\n\n    return elt;\n  }\n\n  parseIdentifier(liberal) {\n    const node = this.startNode();\n    const name = this.parseIdentifierName(node.start, liberal);\n    return this.createIdentifier(node, name);\n  }\n\n  createIdentifier(node, name) {\n    node.name = name;\n    node.loc.identifierName = name;\n    return this.finishNode(node, \"Identifier\");\n  }\n\n  parseIdentifierName(pos, liberal) {\n    let name;\n    const {\n      startLoc,\n      type\n    } = this.state;\n\n    if (tokenIsKeywordOrIdentifier(type)) {\n      name = this.state.value;\n    } else {\n      throw this.unexpected();\n    }\n\n    const tokenIsKeyword = tokenKeywordOrIdentifierIsKeyword(type);\n\n    if (liberal) {\n      if (tokenIsKeyword) {\n        this.replaceToken(128);\n      }\n    } else {\n      this.checkReservedWord(name, startLoc, tokenIsKeyword, false);\n    }\n\n    this.next();\n    return name;\n  }\n\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (word.length > 10) {\n      return;\n    }\n\n    if (!canBeReservedWord(word)) {\n      return;\n    }\n\n    if (word === \"yield\") {\n      if (this.prodParam.hasYield) {\n        this.raise(Errors.YieldBindingIdentifier, {\n          at: startLoc\n        });\n        return;\n      }\n    } else if (word === \"await\") {\n      if (this.prodParam.hasAwait) {\n        this.raise(Errors.AwaitBindingIdentifier, {\n          at: startLoc\n        });\n        return;\n      }\n\n      if (this.scope.inStaticBlock) {\n        this.raise(Errors.AwaitBindingIdentifierInStaticBlock, {\n          at: startLoc\n        });\n        return;\n      }\n\n      this.expressionScope.recordAsyncArrowParametersError({\n        at: startLoc\n      });\n    } else if (word === \"arguments\") {\n      if (this.scope.inClassAndNotInNonArrowFunction) {\n        this.raise(Errors.ArgumentsInClass, {\n          at: startLoc\n        });\n        return;\n      }\n    }\n\n    if (checkKeywords && isKeyword(word)) {\n      this.raise(Errors.UnexpectedKeyword, {\n        at: startLoc,\n        keyword: word\n      });\n      return;\n    }\n\n    const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;\n\n    if (reservedTest(word, this.inModule)) {\n      this.raise(Errors.UnexpectedReservedWord, {\n        at: startLoc,\n        reservedWord: word\n      });\n    }\n  }\n\n  isAwaitAllowed() {\n    if (this.prodParam.hasAwait) return true;\n\n    if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {\n      return true;\n    }\n\n    return false;\n  }\n\n  parseAwait(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n    this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, {\n      at: node\n    });\n\n    if (this.eat(55)) {\n      this.raise(Errors.ObsoleteAwaitStar, {\n        at: node\n      });\n    }\n\n    if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {\n      if (this.isAmbiguousAwait()) {\n        this.ambiguousScriptDifferentAst = true;\n      } else {\n        this.sawUnambiguousESM = true;\n      }\n    }\n\n    if (!this.state.soloAwait) {\n      node.argument = this.parseMaybeUnary(null, true);\n    }\n\n    return this.finishNode(node, \"AwaitExpression\");\n  }\n\n  isAmbiguousAwait() {\n    if (this.hasPrecedingLineBreak()) return true;\n    const {\n      type\n    } = this.state;\n    return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 133 || type === 56 || this.hasPlugin(\"v8intrinsic\") && type === 54;\n  }\n\n  parseYield() {\n    const node = this.startNode();\n    this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, {\n      at: node\n    });\n    this.next();\n    let delegating = false;\n    let argument = null;\n\n    if (!this.hasPrecedingLineBreak()) {\n      delegating = this.eat(55);\n\n      switch (this.state.type) {\n        case 13:\n        case 135:\n        case 8:\n        case 11:\n        case 3:\n        case 9:\n        case 14:\n        case 12:\n          if (!delegating) break;\n\n        default:\n          argument = this.parseMaybeAssign();\n      }\n    }\n\n    node.delegate = delegating;\n    node.argument = argument;\n    return this.finishNode(node, \"YieldExpression\");\n  }\n\n  checkPipelineAtInfixOperator(left, leftStartLoc) {\n    if (this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"smart\"\n    }])) {\n      if (left.type === \"SequenceExpression\") {\n        this.raise(Errors.PipelineHeadSequenceExpression, {\n          at: leftStartLoc\n        });\n      }\n    }\n  }\n\n  parseSmartPipelineBodyInStyle(childExpr, startPos, startLoc) {\n    const bodyNode = this.startNodeAt(startPos, startLoc);\n\n    if (this.isSimpleReference(childExpr)) {\n      bodyNode.callee = childExpr;\n      return this.finishNode(bodyNode, \"PipelineBareFunction\");\n    } else {\n      this.checkSmartPipeTopicBodyEarlyErrors(startLoc);\n      bodyNode.expression = childExpr;\n      return this.finishNode(bodyNode, \"PipelineTopicExpression\");\n    }\n  }\n\n  isSimpleReference(expression) {\n    switch (expression.type) {\n      case \"MemberExpression\":\n        return !expression.computed && this.isSimpleReference(expression.object);\n\n      case \"Identifier\":\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  checkSmartPipeTopicBodyEarlyErrors(startLoc) {\n    if (this.match(19)) {\n      throw this.raise(Errors.PipelineBodyNoArrow, {\n        at: this.state.startLoc\n      });\n    }\n\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      this.raise(Errors.PipelineTopicUnused, {\n        at: startLoc\n      });\n    }\n  }\n\n  withTopicBindingContext(callback) {\n    const outerContextTopicState = this.state.topicContext;\n    this.state.topicContext = {\n      maxNumOfResolvableTopics: 1,\n      maxTopicIndex: null\n    };\n\n    try {\n      return callback();\n    } finally {\n      this.state.topicContext = outerContextTopicState;\n    }\n  }\n\n  withSmartMixTopicForbiddingContext(callback) {\n    if (this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"smart\"\n    }])) {\n      const outerContextTopicState = this.state.topicContext;\n      this.state.topicContext = {\n        maxNumOfResolvableTopics: 0,\n        maxTopicIndex: null\n      };\n\n      try {\n        return callback();\n      } finally {\n        this.state.topicContext = outerContextTopicState;\n      }\n    } else {\n      return callback();\n    }\n  }\n\n  withSoloAwaitPermittingContext(callback) {\n    const outerContextSoloAwaitState = this.state.soloAwait;\n    this.state.soloAwait = true;\n\n    try {\n      return callback();\n    } finally {\n      this.state.soloAwait = outerContextSoloAwaitState;\n    }\n  }\n\n  allowInAnd(callback) {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToSet = PARAM_IN & ~flags;\n\n    if (prodParamToSet) {\n      this.prodParam.enter(flags | PARAM_IN);\n\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n\n    return callback();\n  }\n\n  disallowInAnd(callback) {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToClear = PARAM_IN & flags;\n\n    if (prodParamToClear) {\n      this.prodParam.enter(flags & ~PARAM_IN);\n\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n\n    return callback();\n  }\n\n  registerTopicReference() {\n    this.state.topicContext.maxTopicIndex = 0;\n  }\n\n  topicReferenceIsAllowedInCurrentContext() {\n    return this.state.topicContext.maxNumOfResolvableTopics >= 1;\n  }\n\n  topicReferenceWasUsedInCurrentContext() {\n    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;\n  }\n\n  parseFSharpPipelineBody(prec) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    this.state.potentialArrowAt = this.state.start;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = true;\n    const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startPos, startLoc, prec);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return ret;\n  }\n\n  parseModuleExpression() {\n    this.expectPlugin(\"moduleBlocks\");\n    const node = this.startNode();\n    this.next();\n    this.eat(5);\n    const revertScopes = this.initializeScopes(true);\n    this.enterInitialScopes();\n    const program = this.startNode();\n\n    try {\n      node.body = this.parseProgram(program, 8, \"module\");\n    } finally {\n      revertScopes();\n    }\n\n    this.eat(8);\n    return this.finishNode(node, \"ModuleExpression\");\n  }\n\n  parsePropertyNamePrefixOperator(prop) {}\n\n}\n\nconst loopLabel = {\n  kind: \"loop\"\n},\n      switchLabel = {\n  kind: \"switch\"\n};\nconst FUNC_NO_FLAGS = 0b000,\n      FUNC_STATEMENT = 0b001,\n      FUNC_HANGING_STATEMENT = 0b010,\n      FUNC_NULLABLE_ID = 0b100;\nconst loneSurrogate = /[\\uD800-\\uDFFF]/u;\nconst keywordRelationalOperator = /in(?:stanceof)?/y;\n\nfunction babel7CompatTokens(tokens, input) {\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    const {\n      type\n    } = token;\n\n    if (typeof type === \"number\") {\n      {\n        if (type === 134) {\n          const {\n            loc,\n            start,\n            value,\n            end\n          } = token;\n          const hashEndPos = start + 1;\n          const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);\n          tokens.splice(i, 1, new Token({\n            type: getExportedToken(27),\n            value: \"#\",\n            start: start,\n            end: hashEndPos,\n            startLoc: loc.start,\n            endLoc: hashEndLoc\n          }), new Token({\n            type: getExportedToken(128),\n            value: value,\n            start: hashEndPos,\n            end: end,\n            startLoc: hashEndLoc,\n            endLoc: loc.end\n          }));\n          i++;\n          continue;\n        }\n\n        if (tokenIsTemplate(type)) {\n          const {\n            loc,\n            start,\n            value,\n            end\n          } = token;\n          const backquoteEnd = start + 1;\n          const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);\n          let startToken;\n\n          if (input.charCodeAt(start) === 96) {\n            startToken = new Token({\n              type: getExportedToken(22),\n              value: \"`\",\n              start: start,\n              end: backquoteEnd,\n              startLoc: loc.start,\n              endLoc: backquoteEndLoc\n            });\n          } else {\n            startToken = new Token({\n              type: getExportedToken(8),\n              value: \"}\",\n              start: start,\n              end: backquoteEnd,\n              startLoc: loc.start,\n              endLoc: backquoteEndLoc\n            });\n          }\n\n          let templateValue, templateElementEnd, templateElementEndLoc, endToken;\n\n          if (type === 24) {\n            templateElementEnd = end - 1;\n            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);\n            templateValue = value === null ? null : value.slice(1, -1);\n            endToken = new Token({\n              type: getExportedToken(22),\n              value: \"`\",\n              start: templateElementEnd,\n              end: end,\n              startLoc: templateElementEndLoc,\n              endLoc: loc.end\n            });\n          } else {\n            templateElementEnd = end - 2;\n            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);\n            templateValue = value === null ? null : value.slice(1, -2);\n            endToken = new Token({\n              type: getExportedToken(23),\n              value: \"${\",\n              start: templateElementEnd,\n              end: end,\n              startLoc: templateElementEndLoc,\n              endLoc: loc.end\n            });\n          }\n\n          tokens.splice(i, 1, startToken, new Token({\n            type: getExportedToken(20),\n            value: templateValue,\n            start: backquoteEnd,\n            end: templateElementEnd,\n            startLoc: backquoteEndLoc,\n            endLoc: templateElementEndLoc\n          }), endToken);\n          i += 2;\n          continue;\n        }\n      }\n      token.type = getExportedToken(type);\n    }\n  }\n\n  return tokens;\n}\n\nclass StatementParser extends ExpressionParser {\n  parseTopLevel(file, program) {\n    file.program = this.parseProgram(program);\n    file.comments = this.state.comments;\n\n    if (this.options.tokens) {\n      file.tokens = babel7CompatTokens(this.tokens, this.input);\n    }\n\n    return this.finishNode(file, \"File\");\n  }\n\n  parseProgram(program, end = 135, sourceType = this.options.sourceType) {\n    program.sourceType = sourceType;\n    program.interpreter = this.parseInterpreterDirective();\n    this.parseBlockBody(program, true, true, end);\n\n    if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {\n      for (const [localName, at] of Array.from(this.scope.undefinedExports)) {\n        this.raise(Errors.ModuleExportUndefined, {\n          at,\n          localName\n        });\n      }\n    }\n\n    return this.finishNode(program, \"Program\");\n  }\n\n  stmtToDirective(stmt) {\n    const directive = stmt;\n    directive.type = \"Directive\";\n    directive.value = directive.expression;\n    delete directive.expression;\n    const directiveLiteral = directive.value;\n    const expressionValue = directiveLiteral.value;\n    const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);\n    const val = directiveLiteral.value = raw.slice(1, -1);\n    this.addExtra(directiveLiteral, \"raw\", raw);\n    this.addExtra(directiveLiteral, \"rawValue\", val);\n    this.addExtra(directiveLiteral, \"expressionValue\", expressionValue);\n    directiveLiteral.type = \"DirectiveLiteral\";\n    return directive;\n  }\n\n  parseInterpreterDirective() {\n    if (!this.match(28)) {\n      return null;\n    }\n\n    const node = this.startNode();\n    node.value = this.state.value;\n    this.next();\n    return this.finishNode(node, \"InterpreterDirective\");\n  }\n\n  isLet(context) {\n    if (!this.isContextual(99)) {\n      return false;\n    }\n\n    return this.isLetKeyword(context);\n  }\n\n  isLetKeyword(context) {\n    const next = this.nextTokenStart();\n    const nextCh = this.codePointAtPos(next);\n\n    if (nextCh === 92 || nextCh === 91) {\n      return true;\n    }\n\n    if (context) return false;\n    if (nextCh === 123) return true;\n\n    if (isIdentifierStart(nextCh)) {\n      keywordRelationalOperator.lastIndex = next;\n\n      if (keywordRelationalOperator.test(this.input)) {\n        const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);\n\n        if (!isIdentifierChar(endCh) && endCh !== 92) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  parseStatement(context, topLevel) {\n    if (this.match(26)) {\n      this.parseDecorators(true);\n    }\n\n    return this.parseStatementContent(context, topLevel);\n  }\n\n  parseStatementContent(context, topLevel) {\n    let starttype = this.state.type;\n    const node = this.startNode();\n    let kind;\n\n    if (this.isLet(context)) {\n      starttype = 74;\n      kind = \"let\";\n    }\n\n    switch (starttype) {\n      case 60:\n        return this.parseBreakContinueStatement(node, true);\n\n      case 63:\n        return this.parseBreakContinueStatement(node, false);\n\n      case 64:\n        return this.parseDebuggerStatement(node);\n\n      case 90:\n        return this.parseDoStatement(node);\n\n      case 91:\n        return this.parseForStatement(node);\n\n      case 68:\n        if (this.lookaheadCharCode() === 46) break;\n\n        if (context) {\n          if (this.state.strict) {\n            this.raise(Errors.StrictFunction, {\n              at: this.state.startLoc\n            });\n          } else if (context !== \"if\" && context !== \"label\") {\n            this.raise(Errors.SloppyFunction, {\n              at: this.state.startLoc\n            });\n          }\n        }\n\n        return this.parseFunctionStatement(node, false, !context);\n\n      case 80:\n        if (context) this.unexpected();\n        return this.parseClass(node, true);\n\n      case 69:\n        return this.parseIfStatement(node);\n\n      case 70:\n        return this.parseReturnStatement(node);\n\n      case 71:\n        return this.parseSwitchStatement(node);\n\n      case 72:\n        return this.parseThrowStatement(node);\n\n      case 73:\n        return this.parseTryStatement(node);\n\n      case 75:\n      case 74:\n        kind = kind || this.state.value;\n\n        if (context && kind !== \"var\") {\n          this.raise(Errors.UnexpectedLexicalDeclaration, {\n            at: this.state.startLoc\n          });\n        }\n\n        return this.parseVarStatement(node, kind);\n\n      case 92:\n        return this.parseWhileStatement(node);\n\n      case 76:\n        return this.parseWithStatement(node);\n\n      case 5:\n        return this.parseBlock();\n\n      case 13:\n        return this.parseEmptyStatement(node);\n\n      case 83:\n        {\n          const nextTokenCharCode = this.lookaheadCharCode();\n\n          if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {\n            break;\n          }\n        }\n\n      case 82:\n        {\n          if (!this.options.allowImportExportEverywhere && !topLevel) {\n            this.raise(Errors.UnexpectedImportExport, {\n              at: this.state.startLoc\n            });\n          }\n\n          this.next();\n          let result;\n\n          if (starttype === 83) {\n            result = this.parseImport(node);\n\n            if (result.type === \"ImportDeclaration\" && (!result.importKind || result.importKind === \"value\")) {\n              this.sawUnambiguousESM = true;\n            }\n          } else {\n            result = this.parseExport(node);\n\n            if (result.type === \"ExportNamedDeclaration\" && (!result.exportKind || result.exportKind === \"value\") || result.type === \"ExportAllDeclaration\" && (!result.exportKind || result.exportKind === \"value\") || result.type === \"ExportDefaultDeclaration\") {\n              this.sawUnambiguousESM = true;\n            }\n          }\n\n          this.assertModuleNodeAllowed(node);\n          return result;\n        }\n\n      default:\n        {\n          if (this.isAsyncFunction()) {\n            if (context) {\n              this.raise(Errors.AsyncFunctionInSingleStatementContext, {\n                at: this.state.startLoc\n              });\n            }\n\n            this.next();\n            return this.parseFunctionStatement(node, true, !context);\n          }\n        }\n    }\n\n    const maybeName = this.state.value;\n    const expr = this.parseExpression();\n\n    if (tokenIsIdentifier(starttype) && expr.type === \"Identifier\" && this.eat(14)) {\n      return this.parseLabeledStatement(node, maybeName, expr, context);\n    } else {\n      return this.parseExpressionStatement(node, expr);\n    }\n  }\n\n  assertModuleNodeAllowed(node) {\n    if (!this.options.allowImportExportEverywhere && !this.inModule) {\n      this.raise(Errors.ImportOutsideModule, {\n        at: node\n      });\n    }\n  }\n\n  takeDecorators(node) {\n    const decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    if (decorators.length) {\n      node.decorators = decorators;\n      this.resetStartLocationFromNode(node, decorators[0]);\n      this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];\n    }\n  }\n\n  canHaveLeadingDecorator() {\n    return this.match(80);\n  }\n\n  parseDecorators(allowExport) {\n    const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    while (this.match(26)) {\n      const decorator = this.parseDecorator();\n      currentContextDecorators.push(decorator);\n    }\n\n    if (this.match(82)) {\n      if (!allowExport) {\n        this.unexpected();\n      }\n\n      if (this.hasPlugin(\"decorators\") && !this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n        this.raise(Errors.DecoratorExportClass, {\n          at: this.state.startLoc\n        });\n      }\n    } else if (!this.canHaveLeadingDecorator()) {\n      throw this.raise(Errors.UnexpectedLeadingDecorator, {\n        at: this.state.startLoc\n      });\n    }\n  }\n\n  parseDecorator() {\n    this.expectOnePlugin([\"decorators-legacy\", \"decorators\"]);\n    const node = this.startNode();\n    this.next();\n\n    if (this.hasPlugin(\"decorators\")) {\n      this.state.decoratorStack.push([]);\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      let expr;\n\n      if (this.match(10)) {\n        const startPos = this.state.start;\n        const startLoc = this.state.startLoc;\n        this.next();\n        expr = this.parseExpression();\n        this.expect(11);\n        expr = this.wrapParenthesis(startPos, startLoc, expr);\n      } else {\n        expr = this.parseIdentifier(false);\n\n        while (this.eat(16)) {\n          const node = this.startNodeAt(startPos, startLoc);\n          node.object = expr;\n          node.property = this.parseIdentifier(true);\n          node.computed = false;\n          expr = this.finishNode(node, \"MemberExpression\");\n        }\n      }\n\n      node.expression = this.parseMaybeDecoratorArguments(expr);\n      this.state.decoratorStack.pop();\n    } else {\n      node.expression = this.parseExprSubscripts();\n    }\n\n    return this.finishNode(node, \"Decorator\");\n  }\n\n  parseMaybeDecoratorArguments(expr) {\n    if (this.eat(10)) {\n      const node = this.startNodeAtNode(expr);\n      node.callee = expr;\n      node.arguments = this.parseCallExpressionArguments(11, false);\n      this.toReferencedList(node.arguments);\n      return this.finishNode(node, \"CallExpression\");\n    }\n\n    return expr;\n  }\n\n  parseBreakContinueStatement(node, isBreak) {\n    this.next();\n\n    if (this.isLineTerminator()) {\n      node.label = null;\n    } else {\n      node.label = this.parseIdentifier();\n      this.semicolon();\n    }\n\n    this.verifyBreakContinue(node, isBreak);\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n  }\n\n  verifyBreakContinue(node, isBreak) {\n    let i;\n\n    for (i = 0; i < this.state.labels.length; ++i) {\n      const lab = this.state.labels[i];\n\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n        if (node.label && isBreak) break;\n      }\n    }\n\n    if (i === this.state.labels.length) {\n      const type = isBreak ? \"BreakStatement\" : \"ContinueStatement\";\n      this.raise(Errors.IllegalBreakContinue, {\n        at: node,\n        type\n      });\n    }\n  }\n\n  parseDebuggerStatement(node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n  }\n\n  parseHeaderExpression() {\n    this.expect(10);\n    const val = this.parseExpression();\n    this.expect(11);\n    return val;\n  }\n\n  parseDoStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement(\"do\"));\n    this.state.labels.pop();\n    this.expect(92);\n    node.test = this.parseHeaderExpression();\n    this.eat(13);\n    return this.finishNode(node, \"DoWhileStatement\");\n  }\n\n  parseForStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    let awaitAt = null;\n\n    if (this.isAwaitAllowed() && this.eatContextual(96)) {\n      awaitAt = this.state.lastTokStartLoc;\n    }\n\n    this.scope.enter(SCOPE_OTHER);\n    this.expect(10);\n\n    if (this.match(13)) {\n      if (awaitAt !== null) {\n        this.unexpected(awaitAt);\n      }\n\n      return this.parseFor(node, null);\n    }\n\n    const startsWithLet = this.isContextual(99);\n    const isLet = startsWithLet && this.isLetKeyword();\n\n    if (this.match(74) || this.match(75) || isLet) {\n      const init = this.startNode();\n      const kind = isLet ? \"let\" : this.state.value;\n      this.next();\n      this.parseVar(init, true, kind);\n      this.finishNode(init, \"VariableDeclaration\");\n\n      if ((this.match(58) || this.isContextual(101)) && init.declarations.length === 1) {\n        return this.parseForIn(node, init, awaitAt);\n      }\n\n      if (awaitAt !== null) {\n        this.unexpected(awaitAt);\n      }\n\n      return this.parseFor(node, init);\n    }\n\n    const startsWithAsync = this.isContextual(95);\n    const refExpressionErrors = new ExpressionErrors();\n    const init = this.parseExpression(true, refExpressionErrors);\n    const isForOf = this.isContextual(101);\n\n    if (isForOf) {\n      if (startsWithLet) {\n        this.raise(Errors.ForOfLet, {\n          at: init\n        });\n      }\n\n      if (awaitAt === null && startsWithAsync && init.type === \"Identifier\") {\n        this.raise(Errors.ForOfAsync, {\n          at: init\n        });\n      }\n    }\n\n    if (isForOf || this.match(58)) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.toAssignable(init, true);\n      const type = isForOf ? \"ForOfStatement\" : \"ForInStatement\";\n      this.checkLVal(init, {\n        in: {\n          type\n        }\n      });\n      return this.parseForIn(node, init, awaitAt);\n    } else {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n\n    if (awaitAt !== null) {\n      this.unexpected(awaitAt);\n    }\n\n    return this.parseFor(node, init);\n  }\n\n  parseFunctionStatement(node, isAsync, declarationPosition) {\n    this.next();\n    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);\n  }\n\n  parseIfStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    node.consequent = this.parseStatement(\"if\");\n    node.alternate = this.eat(66) ? this.parseStatement(\"if\") : null;\n    return this.finishNode(node, \"IfStatement\");\n  }\n\n  parseReturnStatement(node) {\n    if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {\n      this.raise(Errors.IllegalReturn, {\n        at: this.state.startLoc\n      });\n    }\n\n    this.next();\n\n    if (this.isLineTerminator()) {\n      node.argument = null;\n    } else {\n      node.argument = this.parseExpression();\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"ReturnStatement\");\n  }\n\n  parseSwitchStatement(node) {\n    this.next();\n    node.discriminant = this.parseHeaderExpression();\n    const cases = node.cases = [];\n    this.expect(5);\n    this.state.labels.push(switchLabel);\n    this.scope.enter(SCOPE_OTHER);\n    let cur;\n\n    for (let sawDefault; !this.match(8);) {\n      if (this.match(61) || this.match(65)) {\n        const isCase = this.match(61);\n        if (cur) this.finishNode(cur, \"SwitchCase\");\n        cases.push(cur = this.startNode());\n        cur.consequent = [];\n        this.next();\n\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) {\n            this.raise(Errors.MultipleDefaultsInSwitch, {\n              at: this.state.lastTokStartLoc\n            });\n          }\n\n          sawDefault = true;\n          cur.test = null;\n        }\n\n        this.expect(14);\n      } else {\n        if (cur) {\n          cur.consequent.push(this.parseStatement(null));\n        } else {\n          this.unexpected();\n        }\n      }\n    }\n\n    this.scope.exit();\n    if (cur) this.finishNode(cur, \"SwitchCase\");\n    this.next();\n    this.state.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n  }\n\n  parseThrowStatement(node) {\n    this.next();\n\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.NewlineAfterThrow, {\n        at: this.state.lastTokEndLoc\n      });\n    }\n\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n  }\n\n  parseCatchClauseParam() {\n    const param = this.parseBindingAtom();\n    const simple = param.type === \"Identifier\";\n    this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);\n    this.checkLVal(param, {\n      in: {\n        type: \"CatchClause\"\n      },\n      binding: BIND_LEXICAL,\n      allowingSloppyLetBinding: true\n    });\n    return param;\n  }\n\n  parseTryStatement(node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n\n    if (this.match(62)) {\n      const clause = this.startNode();\n      this.next();\n\n      if (this.match(10)) {\n        this.expect(10);\n        clause.param = this.parseCatchClauseParam();\n        this.expect(11);\n      } else {\n        clause.param = null;\n        this.scope.enter(SCOPE_OTHER);\n      }\n\n      clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));\n      this.scope.exit();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n\n    node.finalizer = this.eat(67) ? this.parseBlock() : null;\n\n    if (!node.handler && !node.finalizer) {\n      this.raise(Errors.NoCatchOrFinally, {\n        at: node\n      });\n    }\n\n    return this.finishNode(node, \"TryStatement\");\n  }\n\n  parseVarStatement(node, kind, allowMissingInitializer = false) {\n    this.next();\n    this.parseVar(node, false, kind, allowMissingInitializer);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n  }\n\n  parseWhileStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    this.state.labels.push(loopLabel);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement(\"while\"));\n    this.state.labels.pop();\n    return this.finishNode(node, \"WhileStatement\");\n  }\n\n  parseWithStatement(node) {\n    if (this.state.strict) {\n      this.raise(Errors.StrictWith, {\n        at: this.state.startLoc\n      });\n    }\n\n    this.next();\n    node.object = this.parseHeaderExpression();\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement(\"with\"));\n    return this.finishNode(node, \"WithStatement\");\n  }\n\n  parseEmptyStatement(node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n  }\n\n  parseLabeledStatement(node, maybeName, expr, context) {\n    for (const label of this.state.labels) {\n      if (label.name === maybeName) {\n        this.raise(Errors.LabelRedeclaration, {\n          at: expr,\n          labelName: maybeName\n        });\n      }\n    }\n\n    const kind = tokenIsLoop(this.state.type) ? \"loop\" : this.match(71) ? \"switch\" : null;\n\n    for (let i = this.state.labels.length - 1; i >= 0; i--) {\n      const label = this.state.labels[i];\n\n      if (label.statementStart === node.start) {\n        label.statementStart = this.state.start;\n        label.kind = kind;\n      } else {\n        break;\n      }\n    }\n\n    this.state.labels.push({\n      name: maybeName,\n      kind: kind,\n      statementStart: this.state.start\n    });\n    node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n    this.state.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n  }\n\n  parseExpressionStatement(node, expr) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n  }\n\n  parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {\n    const node = this.startNode();\n\n    if (allowDirectives) {\n      this.state.strictErrors.clear();\n    }\n\n    this.expect(5);\n\n    if (createNewLexicalScope) {\n      this.scope.enter(SCOPE_OTHER);\n    }\n\n    this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);\n\n    if (createNewLexicalScope) {\n      this.scope.exit();\n    }\n\n    return this.finishNode(node, \"BlockStatement\");\n  }\n\n  isValidDirective(stmt) {\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"StringLiteral\" && !stmt.expression.extra.parenthesized;\n  }\n\n  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {\n    const body = node.body = [];\n    const directives = node.directives = [];\n    this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);\n  }\n\n  parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {\n    const oldStrict = this.state.strict;\n    let hasStrictModeDirective = false;\n    let parsedNonDirective = false;\n\n    while (!this.match(end)) {\n      const stmt = this.parseStatement(null, topLevel);\n\n      if (directives && !parsedNonDirective) {\n        if (this.isValidDirective(stmt)) {\n          const directive = this.stmtToDirective(stmt);\n          directives.push(directive);\n\n          if (!hasStrictModeDirective && directive.value.value === \"use strict\") {\n            hasStrictModeDirective = true;\n            this.setStrict(true);\n          }\n\n          continue;\n        }\n\n        parsedNonDirective = true;\n        this.state.strictErrors.clear();\n      }\n\n      body.push(stmt);\n    }\n\n    if (afterBlockParse) {\n      afterBlockParse.call(this, hasStrictModeDirective);\n    }\n\n    if (!oldStrict) {\n      this.setStrict(false);\n    }\n\n    this.next();\n  }\n\n  parseFor(node, init) {\n    node.init = init;\n    this.semicolon(false);\n    node.test = this.match(13) ? null : this.parseExpression();\n    this.semicolon(false);\n    node.update = this.match(11) ? null : this.parseExpression();\n    this.expect(11);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement(\"for\"));\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, \"ForStatement\");\n  }\n\n  parseForIn(node, init, awaitAt) {\n    const isForIn = this.match(58);\n    this.next();\n\n    if (isForIn) {\n      if (awaitAt !== null) this.unexpected(awaitAt);\n    } else {\n      node.await = awaitAt !== null;\n    }\n\n    if (init.type === \"VariableDeclaration\" && init.declarations[0].init != null && (!isForIn || this.state.strict || init.kind !== \"var\" || init.declarations[0].id.type !== \"Identifier\")) {\n      this.raise(Errors.ForInOfLoopInitializer, {\n        at: init,\n        type: isForIn ? \"ForInStatement\" : \"ForOfStatement\"\n      });\n    }\n\n    if (init.type === \"AssignmentPattern\") {\n      this.raise(Errors.InvalidLhs, {\n        at: init,\n        ancestor: {\n          type: \"ForStatement\"\n        }\n      });\n    }\n\n    node.left = init;\n    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();\n    this.expect(11);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement(\"for\"));\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n  }\n\n  parseVar(node, isFor, kind, allowMissingInitializer = false) {\n    const declarations = node.declarations = [];\n    node.kind = kind;\n\n    for (;;) {\n      const decl = this.startNode();\n      this.parseVarId(decl, kind);\n      decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();\n\n      if (decl.init === null && !allowMissingInitializer) {\n        if (decl.id.type !== \"Identifier\" && !(isFor && (this.match(58) || this.isContextual(101)))) {\n          this.raise(Errors.DeclarationMissingInitializer, {\n            at: this.state.lastTokEndLoc,\n            kind: \"destructuring\"\n          });\n        } else if (kind === \"const\" && !(this.match(58) || this.isContextual(101))) {\n          this.raise(Errors.DeclarationMissingInitializer, {\n            at: this.state.lastTokEndLoc,\n            kind: \"const\"\n          });\n        }\n      }\n\n      declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(12)) break;\n    }\n\n    return node;\n  }\n\n  parseVarId(decl, kind) {\n    decl.id = this.parseBindingAtom();\n    this.checkLVal(decl.id, {\n      in: {\n        type: \"VariableDeclarator\"\n      },\n      binding: kind === \"var\" ? BIND_VAR : BIND_LEXICAL\n    });\n  }\n\n  parseFunction(node, statement = FUNC_NO_FLAGS, isAsync = false) {\n    const isStatement = statement & FUNC_STATEMENT;\n    const isHangingStatement = statement & FUNC_HANGING_STATEMENT;\n    const requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);\n    this.initFunction(node, isAsync);\n\n    if (this.match(55) && isHangingStatement) {\n      this.raise(Errors.GeneratorInSingleStatementContext, {\n        at: this.state.startLoc\n      });\n    }\n\n    node.generator = this.eat(55);\n\n    if (isStatement) {\n      node.id = this.parseFunctionId(requireId);\n    }\n\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = false;\n    this.scope.enter(SCOPE_FUNCTION);\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n\n    if (!isStatement) {\n      node.id = this.parseFunctionId();\n    }\n\n    this.parseFunctionParams(node, false);\n    this.withSmartMixTopicForbiddingContext(() => {\n      this.parseFunctionBodyAndFinish(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n    });\n    this.prodParam.exit();\n    this.scope.exit();\n\n    if (isStatement && !isHangingStatement) {\n      this.registerFunctionStatementId(node);\n    }\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return node;\n  }\n\n  parseFunctionId(requireId) {\n    return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;\n  }\n\n  parseFunctionParams(node, allowModifiers) {\n    this.expect(10);\n    this.expressionScope.enter(newParameterDeclarationScope());\n    node.params = this.parseBindingList(11, 41, false, allowModifiers);\n    this.expressionScope.exit();\n  }\n\n  registerFunctionStatementId(node) {\n    if (!node.id) return;\n    this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.loc.start);\n  }\n\n  parseClass(node, isStatement, optionalId) {\n    this.next();\n    this.takeDecorators(node);\n    const oldStrict = this.state.strict;\n    this.state.strict = true;\n    this.parseClassId(node, isStatement, optionalId);\n    this.parseClassSuper(node);\n    node.body = this.parseClassBody(!!node.superClass, oldStrict);\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n  }\n\n  isClassProperty() {\n    return this.match(29) || this.match(13) || this.match(8);\n  }\n\n  isClassMethod() {\n    return this.match(10);\n  }\n\n  isNonstaticConstructor(method) {\n    return !method.computed && !method.static && (method.key.name === \"constructor\" || method.key.value === \"constructor\");\n  }\n\n  parseClassBody(hadSuperClass, oldStrict) {\n    this.classScope.enter();\n    const state = {\n      hadConstructor: false,\n      hadSuperClass\n    };\n    let decorators = [];\n    const classBody = this.startNode();\n    classBody.body = [];\n    this.expect(5);\n    this.withSmartMixTopicForbiddingContext(() => {\n      while (!this.match(8)) {\n        if (this.eat(13)) {\n          if (decorators.length > 0) {\n            throw this.raise(Errors.DecoratorSemicolon, {\n              at: this.state.lastTokEndLoc\n            });\n          }\n\n          continue;\n        }\n\n        if (this.match(26)) {\n          decorators.push(this.parseDecorator());\n          continue;\n        }\n\n        const member = this.startNode();\n\n        if (decorators.length) {\n          member.decorators = decorators;\n          this.resetStartLocationFromNode(member, decorators[0]);\n          decorators = [];\n        }\n\n        this.parseClassMember(classBody, member, state);\n\n        if (member.kind === \"constructor\" && member.decorators && member.decorators.length > 0) {\n          this.raise(Errors.DecoratorConstructor, {\n            at: member\n          });\n        }\n      }\n    });\n    this.state.strict = oldStrict;\n    this.next();\n\n    if (decorators.length) {\n      throw this.raise(Errors.TrailingDecorator, {\n        at: this.state.startLoc\n      });\n    }\n\n    this.classScope.exit();\n    return this.finishNode(classBody, \"ClassBody\");\n  }\n\n  parseClassMemberFromModifier(classBody, member) {\n    const key = this.parseIdentifier(true);\n\n    if (this.isClassMethod()) {\n      const method = member;\n      method.kind = \"method\";\n      method.computed = false;\n      method.key = key;\n      method.static = false;\n      this.pushClassMethod(classBody, method, false, false, false, false);\n      return true;\n    } else if (this.isClassProperty()) {\n      const prop = member;\n      prop.computed = false;\n      prop.key = key;\n      prop.static = false;\n      classBody.body.push(this.parseClassProperty(prop));\n      return true;\n    }\n\n    this.resetPreviousNodeTrailingComments(key);\n    return false;\n  }\n\n  parseClassMember(classBody, member, state) {\n    const isStatic = this.isContextual(104);\n\n    if (isStatic) {\n      if (this.parseClassMemberFromModifier(classBody, member)) {\n        return;\n      }\n\n      if (this.eat(5)) {\n        this.parseClassStaticBlock(classBody, member);\n        return;\n      }\n    }\n\n    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    const publicMethod = member;\n    const privateMethod = member;\n    const publicProp = member;\n    const privateProp = member;\n    const accessorProp = member;\n    const method = publicMethod;\n    const publicMember = publicMethod;\n    member.static = isStatic;\n    this.parsePropertyNamePrefixOperator(member);\n\n    if (this.eat(55)) {\n      method.kind = \"method\";\n      const isPrivateName = this.match(134);\n      this.parseClassElementName(method);\n\n      if (isPrivateName) {\n        this.pushClassPrivateMethod(classBody, privateMethod, true, false);\n        return;\n      }\n\n      if (this.isNonstaticConstructor(publicMethod)) {\n        this.raise(Errors.ConstructorIsGenerator, {\n          at: publicMethod.key\n        });\n      }\n\n      this.pushClassMethod(classBody, publicMethod, true, false, false, false);\n      return;\n    }\n\n    const isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc;\n    const isPrivate = this.match(134);\n    const key = this.parseClassElementName(member);\n    const maybeQuestionTokenStartLoc = this.state.startLoc;\n    this.parsePostMemberNameModifiers(publicMember);\n\n    if (this.isClassMethod()) {\n      method.kind = \"method\";\n\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n        return;\n      }\n\n      const isConstructor = this.isNonstaticConstructor(publicMethod);\n      let allowsDirectSuper = false;\n\n      if (isConstructor) {\n        publicMethod.kind = \"constructor\";\n\n        if (state.hadConstructor && !this.hasPlugin(\"typescript\")) {\n          this.raise(Errors.DuplicateConstructor, {\n            at: key\n          });\n        }\n\n        if (isConstructor && this.hasPlugin(\"typescript\") && member.override) {\n          this.raise(Errors.OverrideOnConstructor, {\n            at: key\n          });\n        }\n\n        state.hadConstructor = true;\n        allowsDirectSuper = state.hadSuperClass;\n      }\n\n      this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);\n    } else if (this.isClassProperty()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else if (isContextual && key.name === \"async\" && !this.isLineTerminator()) {\n      this.resetPreviousNodeTrailingComments(key);\n      const isGenerator = this.eat(55);\n\n      if (publicMember.optional) {\n        this.unexpected(maybeQuestionTokenStartLoc);\n      }\n\n      method.kind = \"method\";\n      const isPrivate = this.match(134);\n      this.parseClassElementName(method);\n      this.parsePostMemberNameModifiers(publicMember);\n\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAsync, {\n            at: publicMethod.key\n          });\n        }\n\n        this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);\n      }\n    } else if (isContextual && (key.name === \"get\" || key.name === \"set\") && !(this.match(55) && this.isLineTerminator())) {\n      this.resetPreviousNodeTrailingComments(key);\n      method.kind = key.name;\n      const isPrivate = this.match(134);\n      this.parseClassElementName(publicMethod);\n\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAccessor, {\n            at: publicMethod.key\n          });\n        }\n\n        this.pushClassMethod(classBody, publicMethod, false, false, false, false);\n      }\n\n      this.checkGetterSetterParams(publicMethod);\n    } else if (isContextual && key.name === \"accessor\" && !this.isLineTerminator()) {\n      this.expectPlugin(\"decoratorAutoAccessors\");\n      this.resetPreviousNodeTrailingComments(key);\n      const isPrivate = this.match(134);\n      this.parseClassElementName(publicProp);\n      this.pushClassAccessorProperty(classBody, accessorProp, isPrivate);\n    } else if (this.isLineTerminator()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else {\n      this.unexpected();\n    }\n  }\n\n  parseClassElementName(member) {\n    const {\n      type,\n      value\n    } = this.state;\n\n    if ((type === 128 || type === 129) && member.static && value === \"prototype\") {\n      this.raise(Errors.StaticPrototype, {\n        at: this.state.startLoc\n      });\n    }\n\n    if (type === 134) {\n      if (value === \"constructor\") {\n        this.raise(Errors.ConstructorClassPrivateField, {\n          at: this.state.startLoc\n        });\n      }\n\n      const key = this.parsePrivateName();\n      member.key = key;\n      return key;\n    }\n\n    return this.parsePropertyName(member);\n  }\n\n  parseClassStaticBlock(classBody, member) {\n    var _member$decorators;\n\n    this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    this.prodParam.enter(PARAM);\n    const body = member.body = [];\n    this.parseBlockOrModuleBlockBody(body, undefined, false, 8);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.labels = oldLabels;\n    classBody.body.push(this.finishNode(member, \"StaticBlock\"));\n\n    if ((_member$decorators = member.decorators) != null && _member$decorators.length) {\n      this.raise(Errors.DecoratorStaticBlock, {\n        at: member\n      });\n    }\n  }\n\n  pushClassProperty(classBody, prop) {\n    if (!prop.computed && (prop.key.name === \"constructor\" || prop.key.value === \"constructor\")) {\n      this.raise(Errors.ConstructorClassField, {\n        at: prop.key\n      });\n    }\n\n    classBody.body.push(this.parseClassProperty(prop));\n  }\n\n  pushClassPrivateProperty(classBody, prop) {\n    const node = this.parseClassPrivateProperty(prop);\n    classBody.body.push(node);\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.loc.start);\n  }\n\n  pushClassAccessorProperty(classBody, prop, isPrivate) {\n    if (!isPrivate && !prop.computed) {\n      const key = prop.key;\n\n      if (key.name === \"constructor\" || key.value === \"constructor\") {\n        this.raise(Errors.ConstructorClassField, {\n          at: key\n        });\n      }\n    }\n\n    const node = this.parseClassAccessorProperty(prop);\n    classBody.body.push(node);\n\n    if (isPrivate) {\n      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.loc.start);\n    }\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \"ClassMethod\", true));\n  }\n\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    const node = this.parseMethod(method, isGenerator, isAsync, false, false, \"ClassPrivateMethod\", true);\n    classBody.body.push(node);\n    const kind = node.kind === \"get\" ? node.static ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node.kind === \"set\" ? node.static ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;\n    this.declareClassPrivateMethodInScope(node, kind);\n  }\n\n  declareClassPrivateMethodInScope(node, kind) {\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);\n  }\n\n  parsePostMemberNameModifiers(methodOrProp) {}\n\n  parseClassPrivateProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassPrivateProperty\");\n  }\n\n  parseClassProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassProperty\");\n  }\n\n  parseClassAccessorProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassAccessorProperty\");\n  }\n\n  parseInitializer(node) {\n    this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);\n    this.expressionScope.enter(newExpressionScope());\n    this.prodParam.enter(PARAM);\n    node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;\n    this.expressionScope.exit();\n    this.prodParam.exit();\n    this.scope.exit();\n  }\n\n  parseClassId(node, isStatement, optionalId, bindingType = BIND_CLASS) {\n    if (tokenIsIdentifier(this.state.type)) {\n      node.id = this.parseIdentifier();\n\n      if (isStatement) {\n        this.declareNameFromIdentifier(node.id, bindingType);\n      }\n    } else {\n      if (optionalId || !isStatement) {\n        node.id = null;\n      } else {\n        throw this.raise(Errors.MissingClassName, {\n          at: this.state.startLoc\n        });\n      }\n    }\n  }\n\n  parseClassSuper(node) {\n    node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;\n  }\n\n  parseExport(node) {\n    const hasDefault = this.maybeParseExportDefaultSpecifier(node);\n    const parseAfterDefault = !hasDefault || this.eat(12);\n    const hasStar = parseAfterDefault && this.eatExportStar(node);\n    const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);\n    const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));\n    const isFromRequired = hasDefault || hasStar;\n\n    if (hasStar && !hasNamespace) {\n      if (hasDefault) this.unexpected();\n      this.parseExportFrom(node, true);\n      return this.finishNode(node, \"ExportAllDeclaration\");\n    }\n\n    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);\n\n    if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {\n      throw this.unexpected(null, 5);\n    }\n\n    let hasDeclaration;\n\n    if (isFromRequired || hasSpecifiers) {\n      hasDeclaration = false;\n      this.parseExportFrom(node, isFromRequired);\n    } else {\n      hasDeclaration = this.maybeParseExportDeclaration(node);\n    }\n\n    if (isFromRequired || hasSpecifiers || hasDeclaration) {\n      this.checkExport(node, true, false, !!node.source);\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n\n    if (this.eat(65)) {\n      node.declaration = this.parseExportDefaultExpression();\n      this.checkExport(node, true, true);\n      return this.finishNode(node, \"ExportDefaultDeclaration\");\n    }\n\n    throw this.unexpected(null, 5);\n  }\n\n  eatExportStar(node) {\n    return this.eat(55);\n  }\n\n  maybeParseExportDefaultSpecifier(node) {\n    if (this.isExportDefaultSpecifier()) {\n      this.expectPlugin(\"exportDefaultFrom\");\n      const specifier = this.startNode();\n      specifier.exported = this.parseIdentifier(true);\n      node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportNamespaceSpecifier(node) {\n    if (this.isContextual(93)) {\n      if (!node.specifiers) node.specifiers = [];\n      const specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);\n      this.next();\n      specifier.exported = this.parseModuleExportName();\n      node.specifiers.push(this.finishNode(specifier, \"ExportNamespaceSpecifier\"));\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportNamedSpecifiers(node) {\n    if (this.match(5)) {\n      if (!node.specifiers) node.specifiers = [];\n      const isTypeExport = node.exportKind === \"type\";\n      node.specifiers.push(...this.parseExportSpecifiers(isTypeExport));\n      node.source = null;\n      node.declaration = null;\n\n      if (this.hasPlugin(\"importAssertions\")) {\n        node.assertions = [];\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportDeclaration(node) {\n    if (this.shouldParseExportDeclaration()) {\n      node.specifiers = [];\n      node.source = null;\n\n      if (this.hasPlugin(\"importAssertions\")) {\n        node.assertions = [];\n      }\n\n      node.declaration = this.parseExportDeclaration(node);\n      return true;\n    }\n\n    return false;\n  }\n\n  isAsyncFunction() {\n    if (!this.isContextual(95)) return false;\n    const next = this.nextTokenStart();\n    return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, \"function\");\n  }\n\n  parseExportDefaultExpression() {\n    const expr = this.startNode();\n    const isAsync = this.isAsyncFunction();\n\n    if (this.match(68) || isAsync) {\n      this.next();\n\n      if (isAsync) {\n        this.next();\n      }\n\n      return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);\n    }\n\n    if (this.match(80)) {\n      return this.parseClass(expr, true, true);\n    }\n\n    if (this.match(26)) {\n      if (this.hasPlugin(\"decorators\") && this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n        this.raise(Errors.DecoratorBeforeExport, {\n          at: this.state.startLoc\n        });\n      }\n\n      this.parseDecorators(false);\n      return this.parseClass(expr, true, true);\n    }\n\n    if (this.match(75) || this.match(74) || this.isLet()) {\n      throw this.raise(Errors.UnsupportedDefaultExport, {\n        at: this.state.startLoc\n      });\n    }\n\n    const res = this.parseMaybeAssignAllowIn();\n    this.semicolon();\n    return res;\n  }\n\n  parseExportDeclaration(node) {\n    return this.parseStatement(null);\n  }\n\n  isExportDefaultSpecifier() {\n    const {\n      type\n    } = this.state;\n\n    if (tokenIsIdentifier(type)) {\n      if (type === 95 && !this.state.containsEsc || type === 99) {\n        return false;\n      }\n\n      if ((type === 126 || type === 125) && !this.state.containsEsc) {\n        const {\n          type: nextType\n        } = this.lookahead();\n\n        if (tokenIsIdentifier(nextType) && nextType !== 97 || nextType === 5) {\n          this.expectOnePlugin([\"flow\", \"typescript\"]);\n          return false;\n        }\n      }\n    } else if (!this.match(65)) {\n      return false;\n    }\n\n    const next = this.nextTokenStart();\n    const hasFrom = this.isUnparsedContextual(next, \"from\");\n\n    if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {\n      return true;\n    }\n\n    if (this.match(65) && hasFrom) {\n      const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));\n      return nextAfterFrom === 34 || nextAfterFrom === 39;\n    }\n\n    return false;\n  }\n\n  parseExportFrom(node, expect) {\n    if (this.eatContextual(97)) {\n      node.source = this.parseImportSource();\n      this.checkExport(node);\n      const assertions = this.maybeParseImportAssertions();\n\n      if (assertions) {\n        node.assertions = assertions;\n      }\n    } else if (expect) {\n      this.unexpected();\n    }\n\n    this.semicolon();\n  }\n\n  shouldParseExportDeclaration() {\n    const {\n      type\n    } = this.state;\n\n    if (type === 26) {\n      this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n\n      if (this.hasPlugin(\"decorators\")) {\n        if (this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n          throw this.raise(Errors.DecoratorBeforeExport, {\n            at: this.state.startLoc\n          });\n        }\n\n        return true;\n      }\n    }\n\n    return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();\n  }\n\n  checkExport(node, checkNames, isDefault, isFrom) {\n    if (checkNames) {\n      if (isDefault) {\n        this.checkDuplicateExports(node, \"default\");\n\n        if (this.hasPlugin(\"exportDefaultFrom\")) {\n          var _declaration$extra;\n\n          const declaration = node.declaration;\n\n          if (declaration.type === \"Identifier\" && declaration.name === \"from\" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {\n            this.raise(Errors.ExportDefaultFromAsIdentifier, {\n              at: declaration\n            });\n          }\n        }\n      } else if (node.specifiers && node.specifiers.length) {\n        for (const specifier of node.specifiers) {\n          const {\n            exported\n          } = specifier;\n          const exportName = exported.type === \"Identifier\" ? exported.name : exported.value;\n          this.checkDuplicateExports(specifier, exportName);\n\n          if (!isFrom && specifier.local) {\n            const {\n              local\n            } = specifier;\n\n            if (local.type !== \"Identifier\") {\n              this.raise(Errors.ExportBindingIsString, {\n                at: specifier,\n                localName: local.value,\n                exportName\n              });\n            } else {\n              this.checkReservedWord(local.name, local.loc.start, true, false);\n              this.scope.checkLocalExport(local);\n            }\n          }\n        }\n      } else if (node.declaration) {\n        if (node.declaration.type === \"FunctionDeclaration\" || node.declaration.type === \"ClassDeclaration\") {\n          const id = node.declaration.id;\n          if (!id) throw new Error(\"Assertion failure\");\n          this.checkDuplicateExports(node, id.name);\n        } else if (node.declaration.type === \"VariableDeclaration\") {\n          for (const declaration of node.declaration.declarations) {\n            this.checkDeclaration(declaration.id);\n          }\n        }\n      }\n    }\n\n    const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    if (currentContextDecorators.length) {\n      throw this.raise(Errors.UnsupportedDecoratorExport, {\n        at: node\n      });\n    }\n  }\n\n  checkDeclaration(node) {\n    if (node.type === \"Identifier\") {\n      this.checkDuplicateExports(node, node.name);\n    } else if (node.type === \"ObjectPattern\") {\n      for (const prop of node.properties) {\n        this.checkDeclaration(prop);\n      }\n    } else if (node.type === \"ArrayPattern\") {\n      for (const elem of node.elements) {\n        if (elem) {\n          this.checkDeclaration(elem);\n        }\n      }\n    } else if (node.type === \"ObjectProperty\") {\n      this.checkDeclaration(node.value);\n    } else if (node.type === \"RestElement\") {\n      this.checkDeclaration(node.argument);\n    } else if (node.type === \"AssignmentPattern\") {\n      this.checkDeclaration(node.left);\n    }\n  }\n\n  checkDuplicateExports(node, exportName) {\n    if (this.exportedIdentifiers.has(exportName)) {\n      if (exportName === \"default\") {\n        this.raise(Errors.DuplicateDefaultExport, {\n          at: node\n        });\n      } else {\n        this.raise(Errors.DuplicateExport, {\n          at: node,\n          exportName\n        });\n      }\n    }\n\n    this.exportedIdentifiers.add(exportName);\n  }\n\n  parseExportSpecifiers(isInTypeExport) {\n    const nodes = [];\n    let first = true;\n    this.expect(5);\n\n    while (!this.eat(8)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.eat(8)) break;\n      }\n\n      const isMaybeTypeOnly = this.isContextual(126);\n      const isString = this.match(129);\n      const node = this.startNode();\n      node.local = this.parseModuleExportName();\n      nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));\n    }\n\n    return nodes;\n  }\n\n  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {\n    if (this.eatContextual(93)) {\n      node.exported = this.parseModuleExportName();\n    } else if (isString) {\n      node.exported = cloneStringLiteral(node.local);\n    } else if (!node.exported) {\n      node.exported = cloneIdentifier(node.local);\n    }\n\n    return this.finishNode(node, \"ExportSpecifier\");\n  }\n\n  parseModuleExportName() {\n    if (this.match(129)) {\n      const result = this.parseStringLiteral(this.state.value);\n      const surrogate = result.value.match(loneSurrogate);\n\n      if (surrogate) {\n        this.raise(Errors.ModuleExportNameHasLoneSurrogate, {\n          at: result,\n          surrogateCharCode: surrogate[0].charCodeAt(0)\n        });\n      }\n\n      return result;\n    }\n\n    return this.parseIdentifier(true);\n  }\n\n  parseImport(node) {\n    node.specifiers = [];\n\n    if (!this.match(129)) {\n      const hasDefault = this.maybeParseDefaultImportSpecifier(node);\n      const parseNext = !hasDefault || this.eat(12);\n      const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);\n      if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);\n      this.expectContextual(97);\n    }\n\n    node.source = this.parseImportSource();\n    const assertions = this.maybeParseImportAssertions();\n\n    if (assertions) {\n      node.assertions = assertions;\n    } else {\n      const attributes = this.maybeParseModuleAttributes();\n\n      if (attributes) {\n        node.attributes = attributes;\n      }\n    }\n\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n\n  parseImportSource() {\n    if (!this.match(129)) this.unexpected();\n    return this.parseExprAtom();\n  }\n\n  shouldParseDefaultImport(node) {\n    return tokenIsIdentifier(this.state.type);\n  }\n\n  parseImportSpecifierLocal(node, specifier, type) {\n    specifier.local = this.parseIdentifier();\n    node.specifiers.push(this.finishImportSpecifier(specifier, type));\n  }\n\n  finishImportSpecifier(specifier, type) {\n    this.checkLVal(specifier.local, {\n      in: specifier,\n      binding: BIND_LEXICAL\n    });\n    return this.finishNode(specifier, type);\n  }\n\n  parseAssertEntries() {\n    const attrs = [];\n    const attrNames = new Set();\n\n    do {\n      if (this.match(8)) {\n        break;\n      }\n\n      const node = this.startNode();\n      const keyName = this.state.value;\n\n      if (attrNames.has(keyName)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, {\n          at: this.state.startLoc,\n          key: keyName\n        });\n      }\n\n      attrNames.add(keyName);\n\n      if (this.match(129)) {\n        node.key = this.parseStringLiteral(keyName);\n      } else {\n        node.key = this.parseIdentifier(true);\n      }\n\n      this.expect(14);\n\n      if (!this.match(129)) {\n        throw this.raise(Errors.ModuleAttributeInvalidValue, {\n          at: this.state.startLoc\n        });\n      }\n\n      node.value = this.parseStringLiteral(this.state.value);\n      this.finishNode(node, \"ImportAttribute\");\n      attrs.push(node);\n    } while (this.eat(12));\n\n    return attrs;\n  }\n\n  maybeParseModuleAttributes() {\n    if (this.match(76) && !this.hasPrecedingLineBreak()) {\n      this.expectPlugin(\"moduleAttributes\");\n      this.next();\n    } else {\n      if (this.hasPlugin(\"moduleAttributes\")) return [];\n      return null;\n    }\n\n    const attrs = [];\n    const attributes = new Set();\n\n    do {\n      const node = this.startNode();\n      node.key = this.parseIdentifier(true);\n\n      if (node.key.name !== \"type\") {\n        this.raise(Errors.ModuleAttributeDifferentFromType, {\n          at: node.key\n        });\n      }\n\n      if (attributes.has(node.key.name)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, {\n          at: node.key,\n          key: node.key.name\n        });\n      }\n\n      attributes.add(node.key.name);\n      this.expect(14);\n\n      if (!this.match(129)) {\n        throw this.raise(Errors.ModuleAttributeInvalidValue, {\n          at: this.state.startLoc\n        });\n      }\n\n      node.value = this.parseStringLiteral(this.state.value);\n      this.finishNode(node, \"ImportAttribute\");\n      attrs.push(node);\n    } while (this.eat(12));\n\n    return attrs;\n  }\n\n  maybeParseImportAssertions() {\n    if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {\n      this.expectPlugin(\"importAssertions\");\n      this.next();\n    } else {\n      if (this.hasPlugin(\"importAssertions\")) return [];\n      return null;\n    }\n\n    this.eat(5);\n    const attrs = this.parseAssertEntries();\n    this.eat(8);\n    return attrs;\n  }\n\n  maybeParseDefaultImportSpecifier(node) {\n    if (this.shouldParseDefaultImport(node)) {\n      this.parseImportSpecifierLocal(node, this.startNode(), \"ImportDefaultSpecifier\");\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseStarImportSpecifier(node) {\n    if (this.match(55)) {\n      const specifier = this.startNode();\n      this.next();\n      this.expectContextual(93);\n      this.parseImportSpecifierLocal(node, specifier, \"ImportNamespaceSpecifier\");\n      return true;\n    }\n\n    return false;\n  }\n\n  parseNamedImportSpecifiers(node) {\n    let first = true;\n    this.expect(5);\n\n    while (!this.eat(8)) {\n      if (first) {\n        first = false;\n      } else {\n        if (this.eat(14)) {\n          throw this.raise(Errors.DestructureNamedImport, {\n            at: this.state.startLoc\n          });\n        }\n\n        this.expect(12);\n        if (this.eat(8)) break;\n      }\n\n      const specifier = this.startNode();\n      const importedIsString = this.match(129);\n      const isMaybeTypeOnly = this.isContextual(126);\n      specifier.imported = this.parseModuleExportName();\n      const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === \"type\" || node.importKind === \"typeof\", isMaybeTypeOnly);\n      node.specifiers.push(importSpecifier);\n    }\n  }\n\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {\n    if (this.eatContextual(93)) {\n      specifier.local = this.parseIdentifier();\n    } else {\n      const {\n        imported\n      } = specifier;\n\n      if (importedIsString) {\n        throw this.raise(Errors.ImportBindingIsString, {\n          at: specifier,\n          importName: imported.value\n        });\n      }\n\n      this.checkReservedWord(imported.name, specifier.loc.start, true, true);\n\n      if (!specifier.local) {\n        specifier.local = cloneIdentifier(imported);\n      }\n    }\n\n    return this.finishImportSpecifier(specifier, \"ImportSpecifier\");\n  }\n\n  isThisParam(param) {\n    return param.type === \"Identifier\" && param.name === \"this\";\n  }\n\n}\n\nclass Parser extends StatementParser {\n  constructor(options, input) {\n    options = getOptions(options);\n    super(options, input);\n    this.options = options;\n    this.initializeScopes();\n    this.plugins = pluginsMap(this.options.plugins);\n    this.filename = options.sourceFilename;\n  }\n\n  getScopeHandler() {\n    return ScopeHandler;\n  }\n\n  parse() {\n    this.enterInitialScopes();\n    const file = this.startNode();\n    const program = this.startNode();\n    this.nextToken();\n    file.errors = null;\n    this.parseTopLevel(file, program);\n    file.errors = this.state.errors;\n    return file;\n  }\n\n}\n\nfunction pluginsMap(plugins) {\n  const pluginMap = new Map();\n\n  for (const plugin of plugins) {\n    const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];\n    if (!pluginMap.has(name)) pluginMap.set(name, options || {});\n  }\n\n  return pluginMap;\n}\n\nfunction parse(input, options) {\n  var _options;\n\n  if (((_options = options) == null ? void 0 : _options.sourceType) === \"unambiguous\") {\n    options = Object.assign({}, options);\n\n    try {\n      options.sourceType = \"module\";\n      const parser = getParser(options, input);\n      const ast = parser.parse();\n\n      if (parser.sawUnambiguousESM) {\n        return ast;\n      }\n\n      if (parser.ambiguousScriptDifferentAst) {\n        try {\n          options.sourceType = \"script\";\n          return getParser(options, input).parse();\n        } catch (_unused) {}\n      } else {\n        ast.program.sourceType = \"script\";\n      }\n\n      return ast;\n    } catch (moduleError) {\n      try {\n        options.sourceType = \"script\";\n        return getParser(options, input).parse();\n      } catch (_unused2) {}\n\n      throw moduleError;\n    }\n  } else {\n    return getParser(options, input).parse();\n  }\n}\nfunction parseExpression(input, options) {\n  const parser = getParser(options, input);\n\n  if (parser.options.strictMode) {\n    parser.state.strict = true;\n  }\n\n  return parser.getExpression();\n}\n\nfunction generateExportedTokenTypes(internalTokenTypes) {\n  const tokenTypes = {};\n\n  for (const typeName of Object.keys(internalTokenTypes)) {\n    tokenTypes[typeName] = getExportedToken(internalTokenTypes[typeName]);\n  }\n\n  return tokenTypes;\n}\n\nconst tokTypes = generateExportedTokenTypes(tt);\n\nfunction getParser(options, input) {\n  let cls = Parser;\n\n  if (options != null && options.plugins) {\n    validatePlugins(options.plugins);\n    cls = getParserClass(options.plugins);\n  }\n\n  return new cls(options, input);\n}\n\nconst parserClassCache = {};\n\nfunction getParserClass(pluginsFromOptions) {\n  const pluginList = mixinPluginNames.filter(name => hasPlugin(pluginsFromOptions, name));\n  const key = pluginList.join(\"/\");\n  let cls = parserClassCache[key];\n\n  if (!cls) {\n    cls = Parser;\n\n    for (const plugin of pluginList) {\n      cls = mixinPlugins[plugin](cls);\n    }\n\n    parserClassCache[key] = cls;\n  }\n\n  return cls;\n}\n\nexports.parse = parse;\nexports.parseExpression = parseExpression;\nexports.tokTypes = tokTypes;\n//# sourceMappingURL=index.js.map\n"],"names":["_objectWithoutPropertiesLoose","source","excluded","key","i","target","sourceKeys","Object","keys","length","indexOf","Position","constructor","line","col","index","this","column","SourceLocation","start","end","filename","identifierName","createPositionWithColumnOffset","position","columnOffset","ParseErrorCodes","freeze","SyntaxError","SourceTypeModuleError","reflect","last","get","reduce","object","set","value","item","NodeDescriptions","ArrayPattern","AssignmentExpression","AssignmentPattern","ArrowFunctionExpression","ConditionalExpression","ForOfStatement","ForInStatement","ForStatement","FormalParameters","Identifier","ObjectPattern","ParenthesizedExpression","RestElement","UpdateExpression","true","false","VariableDeclarator","YieldExpression","toNodeDescription","type","prefix","String","UnparenthesizedPipeBodyDescriptions","Set","_excluded$1","toParseErrorConstructor","_ref","toMessage","properties","loc","details","descriptors","map","filter","descriptor","enumerable","assign","split","instance","defineProperty","configurable","instantiate","clone","overrides","message","pos","missingPlugin","toParseErrorCredentials","toMessageOrMessage","credentials","ParseErrorEnum","argument","syntaxPlugin","Array","isArray","toParseErrorCredentialsMap","partialCredentials","ParseErrorConstructors","reasonCode","code","Errors","_","ImportMetaOutsideModule","ImportOutsideModule","AccessorIsGenerator","kind","ArgumentsInClass","AsyncFunctionInSingleStatementContext","AwaitBindingIdentifier","AwaitBindingIdentifierInStaticBlock","AwaitExpressionFormalParameter","AwaitNotInAsyncContext","AwaitNotInAsyncFunction","BadGetterArity","BadSetterArity","BadSetterRestParameter","ConstructorClassField","ConstructorClassPrivateField","ConstructorIsAccessor","ConstructorIsAsync","ConstructorIsGenerator","DeclarationMissingInitializer","DecoratorBeforeExport","DecoratorConstructor","DecoratorExportClass","DecoratorSemicolon","DecoratorStaticBlock","DeletePrivateField","DestructureNamedImport","DuplicateConstructor","DuplicateDefaultExport","DuplicateExport","exportName","DuplicateProto","DuplicateRegExpFlags","ElementAfterRest","EscapedCharNotAnIdentifier","ExportBindingIsString","localName","ExportDefaultFromAsIdentifier","ForInOfLoopInitializer","ForOfAsync","ForOfLet","GeneratorInSingleStatementContext","IllegalBreakContinue","IllegalLanguageModeDirective","IllegalReturn","ImportBindingIsString","importName","ImportCallArgumentTrailingComma","ImportCallArity","maxArgumentCount","ImportCallNotNewExpression","ImportCallSpreadArgument","IncompatibleRegExpUVFlags","InvalidBigIntLiteral","InvalidCodePoint","InvalidCoverInitializedName","InvalidDecimal","InvalidDigit","radix","InvalidEscapeSequence","InvalidEscapeSequenceTemplate","InvalidEscapedReservedWord","reservedWord","InvalidIdentifier","InvalidLhs","ancestor","InvalidLhsBinding","InvalidNumber","InvalidOrMissingExponent","InvalidOrUnexpectedToken","unexpected","InvalidParenthesizedAssignment","InvalidPrivateFieldResolution","InvalidPropertyBindingPattern","InvalidRecordProperty","InvalidRestAssignmentPattern","LabelRedeclaration","labelName","LetInLexicalBinding","LineTerminatorBeforeArrow","MalformedRegExpFlags","MissingClassName","MissingEqInAssignment","MissingSemicolon","MissingPlugin","name","JSON","stringify","join","MissingOneOfPlugins","MissingUnicodeEscape","MixingCoalesceWithLogical","ModuleAttributeDifferentFromType","ModuleAttributeInvalidValue","ModuleAttributesWithDuplicateKeys","ModuleExportNameHasLoneSurrogate","surrogateCharCode","toString","ModuleExportUndefined","MultipleDefaultsInSwitch","NewlineAfterThrow","NoCatchOrFinally","NumberIdentifier","NumericSeparatorInEscapeSequence","ObsoleteAwaitStar","OptionalChainingNoNew","OptionalChainingNoTemplate","OverrideOnConstructor","ParamDupe","PatternHasAccessor","PatternHasMethod","PrivateInExpectedIn","PrivateNameRedeclaration","RecordExpressionBarIncorrectEndSyntaxType","RecordExpressionBarIncorrectStartSyntaxType","RecordExpressionHashIncorrectStartSyntaxType","RecordNoProto","RestTrailingComma","SloppyFunction","StaticPrototype","SuperNotAllowed","SuperPrivateField","TrailingDecorator","TupleExpressionBarIncorrectEndSyntaxType","TupleExpressionBarIncorrectStartSyntaxType","TupleExpressionHashIncorrectStartSyntaxType","UnexpectedArgumentPlaceholder","UnexpectedAwaitAfterPipelineBody","UnexpectedDigitAfterHash","UnexpectedImportExport","UnexpectedKeyword","keyword","UnexpectedLeadingDecorator","UnexpectedLexicalDeclaration","UnexpectedNewTarget","UnexpectedNumericSeparator","UnexpectedPrivateField","UnexpectedReservedWord","UnexpectedSuper","UnexpectedToken","expected","UnexpectedTokenUnaryExponentiation","UnsupportedBind","UnsupportedDecoratorExport","UnsupportedDefaultExport","UnsupportedImport","UnsupportedMetaProperty","onlyValidPropertyName","UnsupportedParameterDecorator","UnsupportedPropertyDecorator","UnsupportedSuper","UnterminatedComment","UnterminatedRegExp","UnterminatedString","UnterminatedTemplate","VarRedeclaration","YieldBindingIdentifier","YieldInParameter","ZeroDigitNumericSeparator","StrictDelete","StrictEvalArguments","referenceName","StrictEvalArgumentsBinding","bindingName","StrictFunction","StrictNumericEscape","StrictOctalLiteral","StrictWith","PipeBodyIsTighter","PipeTopicRequiresHackPipes","PipeTopicUnbound","PipeTopicUnconfiguredToken","token","PipeTopicUnused","PipeUnparenthesizedBody","PipelineBodyNoArrow","PipelineBodySequenceExpression","PipelineHeadSequenceExpression","PipelineTopicUnused","PrimaryTopicNotAllowed","PrimaryTopicRequiresSmartPipeline","toUnenumerable","toESTreeLocation","node","TokContext","preserveSpace","types","brace","j_oTag","j_cTag","j_expr","template","beforeExpr","startsExpr","isLoop","isAssign","ExportedTokenType","label","conf","rightAssociative","postfix","binop","updateContext","keywords$1","Map","createKeyword","options","createToken","createBinop","tokenTypeCounter","tokenTypes","tokenLabels","tokenBinops","tokenBeforeExprs","tokenStartsExprs","tokenPrefixes","_options$binop","_options$beforeExpr","_options$startsExpr","_options$prefix","push","createKeywordLike","_options$binop2","_options$beforeExpr2","_options$startsExpr2","_options$prefix2","tt","bracketL","bracketHashL","bracketBarL","bracketR","bracketBarR","braceL","braceBarL","braceHashL","braceR","braceBarR","parenL","parenR","comma","semi","colon","doubleColon","dot","question","questionDot","arrow","ellipsis","backQuote","dollarBraceL","templateTail","templateNonTail","at","hash","interpreterDirective","eq","slashAssign","xorAssign","moduloAssign","incDec","bang","tilde","doubleCaret","doubleAt","pipeline","nullishCoalescing","logicalOR","logicalAND","bitwiseOR","bitwiseXOR","bitwiseAND","equality","lt","gt","relational","bitShift","bitShiftL","bitShiftR","plusMin","modulo","star","slash","exponent","_in","_instanceof","_break","_case","_catch","_continue","_debugger","_default","_else","_finally","_function","_if","_return","_switch","_throw","_try","_var","_const","_with","_new","_this","_super","_class","_extends","_export","_import","_null","_true","_false","_typeof","_void","_delete","_do","_for","_while","_as","_assert","_async","_await","_from","_get","_let","_meta","_of","_sent","_set","_static","_yield","_asserts","_checks","_exports","_global","_implements","_intrinsic","_infer","_is","_mixins","_proto","_require","_keyof","_readonly","_unique","_abstract","_declare","_enum","_module","_namespace","_interface","_type","_opaque","string","num","bigint","decimal","regexp","privateName","eof","jsxName","jsxText","jsxTagStart","jsxTagEnd","placeholder","tokenIsIdentifier","tokenIsKeywordOrIdentifier","tokenIsLiteralPropertyName","tokenCanStartExpression","tokenIsFlowInterfaceOrTypeOrOpaque","tokenIsKeyword","tokenLabelName","tokenOperatorPrecedence","tokenIsTemplate","getExportedToken","context","pop","nonASCIIidentifierStartChars","nonASCIIidentifierChars","nonASCIIidentifierStart","RegExp","nonASCIIidentifier","astralIdentifierStartCodes","astralIdentifierCodes","isInAstralSet","isIdentifierStart","test","fromCharCode","isIdentifierChar","reservedWords","keywords","reservedWordsStrictSet","reservedWordsStrictBindSet","isReservedWord","word","inModule","isStrictReservedWord","has","isStrictBindOnlyReservedWord","isStrictBindReservedWord","reservedWordLikeSet","SCOPE_CLASS","SCOPE_TS_MODULE","SCOPE_VAR","SCOPE_PROGRAM","BIND_FLAGS_CLASS","BIND_FLAGS_TS_EXPORT_ONLY","BIND_FLAGS_FLOW_DECLARE_FN","BIND_NONE","setTrailingComments","comments","undefined","trailingComments","unshift","setInnerComments","innerComments","adjustInnerComments","elements","commentWS","lastElement","lineBreak","lineBreakG","isNewLine","skipWhiteSpace","skipWhiteSpaceToLineBreak","isWhitespace","State","strict","curLine","lineStart","startLoc","endLoc","errors","potentialArrowAt","noArrowAt","noArrowParamsConversionAt","maybeInArrowParameters","inType","noAnonFunctionType","hasFlowComment","isAmbientContext","inAbstractClass","inDisallowConditionalTypesContext","topicContext","maxNumOfResolvableTopics","maxTopicIndex","soloAwait","inFSharpPipelineDirectBody","labels","decoratorStack","commentStack","lastTokEndLoc","lastTokStartLoc","lastTokStart","canStartJSXElement","containsEsc","strictErrors","tokensLength","init","strictMode","sourceType","startLine","startColumn","curPosition","skipArrays","state","val","slice","_excluded","_excluded2","_isDigit","VALID_REGEX_FLAGS","forbiddenNumericSeparatorSiblings","decBinOct","hex","isAllowedNumericSeparatorSibling","bin","ch","oct","dec","Token","Scope","flags","var","lexical","functions","ScopeHandler","parser","scopeStack","undefinedExports","inFunction","currentVarScopeFlags","allowSuper","currentThisScopeFlags","allowDirectSuper","inClass","inClassAndNotInNonArrowFunction","inStaticBlock","inNonArrowFunction","treatFunctionsAsVar","treatFunctionsAsVarInScope","currentScope","createScope","enter","exit","scope","declareName","bindingType","checkRedeclarationInScope","add","maybeExportDefined","delete","isRedeclaredInScope","raise","values","next","checkLocalExport","id","topLevelScope","FlowScope","args","super","declareFunctions","FlowScopeHandler","arguments","ClassScope","privateNames","loneAccessors","undefinedPrivateNames","ClassScopeHandler","stack","current","oldClassScope","from","declarePrivateName","elementType","redefined","CLASS_ELEMENT_KIND_GETTER","accessor","oldStatic","newStatic","usePrivateName","classScope","ExpressionScope","canBeArrowParameterDeclaration","isCertainlyParameterDeclaration","ArrowHeadParsingScope","declarationErrors","recordDeclarationError","ParsingErrorClass","clearDeclarationError","iterateErrors","iterator","forEach","ExpressionScopeHandler","recordParameterInitializerError","toParseError","origin","recordArrowParemeterBindingError","error","recordAsyncArrowParametersError","validateAsPattern","newExpressionScope","ProductionParameterHandler","stacks","currentFlags","hasAwait","hasYield","hasReturn","hasIn","functionFlags","isAsync","isGenerator","ExpressionErrors","shorthandAssignLoc","doubleProtoLoc","privateKeyLoc","optionalParametersLoc","Node","ranges","range","NodePrototype","prototype","cloneIdentifier","extra","cloned","create","expectedNode","cloneStringLiteral","clonePlaceholder","raw","__clone","newNode","reservedTypes","FlowErrors","AmbiguousConditionalArrow","AmbiguousDeclareModuleKind","AssignReservedType","reservedType","DeclareClassElement","DeclareClassFieldInitializer","DuplicateDeclareModuleExports","EnumBooleanMemberNotInitialized","memberName","enumName","EnumDuplicateMemberName","EnumInconsistentMemberValues","EnumInvalidExplicitType","invalidEnumType","EnumInvalidExplicitTypeUnknownSupplied","EnumInvalidMemberInitializerPrimaryType","explicitType","EnumInvalidMemberInitializerSymbolType","EnumInvalidMemberInitializerUnknownType","EnumInvalidMemberName","suggestion","EnumNumberMemberNotInitialized","EnumStringMemberInconsistentlyInitailized","GetterMayNotHaveThisParam","ImportTypeShorthandOnlyInPureImport","InexactInsideExact","InexactInsideNonObject","InexactVariance","InvalidNonTypeImportInDeclareModule","MissingTypeParamDefault","NestedDeclareModule","NestedFlowComment","PatternIsOptional","SetterMayNotHaveThisParam","SpreadVariance","ThisParamAnnotationRequired","ThisParamBannedInConstructor","ThisParamMayNotBeOptional","ThisParamMustBeFirst","ThisParamNoDefault","TypeBeforeInitializer","TypeCastInPattern","UnexpectedExplicitInexactInObject","UnexpectedReservedType","UnexpectedReservedUnderscore","UnexpectedSpaceBetweenModuloChecks","UnexpectedSpreadType","UnexpectedSubtractionOperand","UnexpectedTokenAfterTypeParameter","UnexpectedTypeParameterBeforeAsyncArrowFunction","UnsupportedDeclareExportKind","unsupportedExportKind","UnsupportedStatementInDeclareModule","UnterminatedFlowComment","hasTypeImportKind","importKind","isMaybeDefaultImport","exportSuggestions","const","let","interface","FLOW_PRAGMA_REGEX","entities","__proto__","quot","amp","apos","nbsp","iexcl","cent","pound","curren","yen","brvbar","sect","uml","copy","ordf","laquo","not","shy","reg","macr","deg","plusmn","sup2","sup3","acute","micro","para","middot","cedil","sup1","ordm","raquo","frac14","frac12","frac34","iquest","Agrave","Aacute","Acirc","Atilde","Auml","Aring","AElig","Ccedil","Egrave","Eacute","Ecirc","Euml","Igrave","Iacute","Icirc","Iuml","ETH","Ntilde","Ograve","Oacute","Ocirc","Otilde","Ouml","times","Oslash","Ugrave","Uacute","Ucirc","Uuml","Yacute","THORN","szlig","agrave","aacute","acirc","atilde","auml","aring","aelig","ccedil","egrave","eacute","ecirc","euml","igrave","iacute","icirc","iuml","eth","ntilde","ograve","oacute","ocirc","otilde","ouml","divide","oslash","ugrave","uacute","ucirc","uuml","yacute","thorn","yuml","OElig","oelig","Scaron","scaron","Yuml","fnof","circ","Alpha","Beta","Gamma","Delta","Epsilon","Zeta","Eta","Theta","Iota","Kappa","Lambda","Mu","Nu","Xi","Omicron","Pi","Rho","Sigma","Tau","Upsilon","Phi","Chi","Psi","Omega","alpha","beta","gamma","delta","epsilon","zeta","eta","theta","iota","kappa","lambda","mu","nu","xi","omicron","pi","rho","sigmaf","sigma","tau","upsilon","phi","chi","psi","omega","thetasym","upsih","piv","ensp","emsp","thinsp","zwnj","zwj","lrm","rlm","ndash","mdash","lsquo","rsquo","sbquo","ldquo","rdquo","bdquo","dagger","Dagger","bull","hellip","permil","prime","Prime","lsaquo","rsaquo","oline","frasl","euro","image","weierp","real","trade","alefsym","larr","uarr","rarr","darr","harr","crarr","lArr","uArr","rArr","dArr","hArr","forall","part","exist","empty","nabla","isin","notin","ni","prod","sum","minus","lowast","radic","prop","infin","ang","and","or","cap","cup","int","there4","sim","cong","asymp","ne","equiv","le","ge","sub","sup","nsub","sube","supe","oplus","otimes","perp","sdot","lceil","rceil","lfloor","rfloor","lang","rang","loz","spades","clubs","hearts","diams","JsxErrors","AttributeIsEmpty","MissingClosingTagElement","openingTagName","MissingClosingTagFragment","UnexpectedSequenceExpression","HTMLEntity","UnsupportedJsxValue","UnterminatedJsxContent","UnwrappedAdjacentJSXElements","isFragment","getQualifiedJSXName","namespace","property","Error","TypeScriptScope","enums","constEnums","classes","exportOnlyBindings","TypeScriptScopeHandler","assert","x","tsTokenCanStartExpression","tokenIsBinaryOperator","TSErrors","AbstractMethodHasImplementation","methodName","AbstractPropertyHasInitializer","propertyName","AccesorCannotDeclareThisParameter","AccesorCannotHaveTypeParameters","CannotFindName","ClassMethodHasDeclare","ClassMethodHasReadonly","ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference","ConstructorHasTypeParameters","DeclareAccessor","DeclareClassFieldHasInitializer","DeclareFunctionHasImplementation","DuplicateAccessibilityModifier","modifier","DuplicateModifier","EmptyHeritageClauseType","EmptyTypeArguments","EmptyTypeParameters","ExpectedAmbientAfterExportDeclare","ImportAliasHasImportType","IncompatibleModifiers","modifiers","IndexSignatureHasAbstract","IndexSignatureHasAccessibility","IndexSignatureHasDeclare","IndexSignatureHasOverride","IndexSignatureHasStatic","InitializerNotAllowedInAmbientContext","InvalidModifierOnTypeMember","InvalidModifierOnTypeParameter","InvalidModifierOnTypeParameterPositions","InvalidModifiersOrder","orderedModifiers","InvalidTupleMemberLabel","MissingInterfaceName","MixedLabeledAndUnlabeledElements","NonAbstractClassHasAbstractMethod","NonClassMethodPropertyHasAbstractModifer","OptionalTypeBeforeRequired","OverrideNotInSubClass","PrivateElementHasAbstract","PrivateElementHasAccessibility","ReadonlyForMethodSignature","ReservedArrowTypeParam","ReservedTypeAssertion","SetAccesorCannotHaveOptionalParameter","SetAccesorCannotHaveRestParameter","SetAccesorCannotHaveReturnType","SingleTypeParameterWithoutTrailingComma","typeParameterName","StaticBlockCannotHaveModifier","TypeAnnotationAfterAssign","TypeImportCannotSpecifyDefaultAndNamed","TypeModifierIsUsedInTypeExports","TypeModifierIsUsedInTypeImports","UnexpectedParameterModifier","UnexpectedReadonly","UnexpectedTypeAnnotation","UnexpectedTypeCastInParameter","UnsupportedImportTypeArgument","UnsupportedParameterPropertyKind","UnsupportedSignatureParameterKind","tsIsAccessModifier","tsIsVarianceAnnotations","isPossiblyLiteralEnum","expression","computed","expressions","isUncomputedMemberExpressionChain","PlaceholderErrors","ClassNameIsRequired","UnexpectedSpace","hasPlugin","plugins","expectedConfig","expectedName","expectedOptions","expectedKeys","expectedOptionsIsEmpty","some","p","pluginName","pluginOptions","getPluginOption","option","plugin","find","PIPELINE_PROPOSALS","TOPIC_TOKENS","RECORD_AND_TUPLE_SYNTAX_TYPES","mixinPlugins","estree","superClass","parse","file","tokens","parseRegExpLiteral","pattern","regex","e","estreeParseLiteral","parseBigIntLiteral","bigInt","BigInt","_unused","parseDecimalLiteral","parseLiteral","parseStringLiteral","parseNumericLiteral","parseNullLiteral","parseBooleanLiteral","directiveToStmt","directive","directiveLiteral","stmt","startNodeAt","expressionValue","finishNodeAt","initFunction","checkDeclaration","isObjectProperty","getObjectOrClassMethodParams","method","params","isValidDirective","_stmt$expression$extr","parenthesized","parseBlockBody","directiveStatements","directives","d","body","concat","pushClassMethod","classBody","isConstructor","allowsDirectSuper","parseMethod","typeParameters","parsePrivateName","convertPrivateNameToPrivateIdentifier","getPrivateNameSV","isPrivateName","parseFunctionBody","allowExpression","isMethod","inClassScope","funcNode","startNode","finishNode","parseClassProperty","propertyNode","parseClassPrivateProperty","parseObjectMethod","isPattern","isAccessor","shorthand","parseObjectProperty","startPos","refExpressionErrors","isValidLVal","rest","isAssignable","isBinding","toAssignable","isLHS","toAssignableObjectExpressionProp","finishCallExpression","optional","callee","_node$arguments$","attributes","toReferencedArguments","parseExport","exported","specifiers","parseSubscript","base","noCalls","optionalChainMember","substring","stop","chain","startNodeAtNode","hasPropertyAsPrivateName","isOptionalChain","isObjectMethod","resetStartLocation","resetEndLocation","jsx","jsxReadToken","out","chunkStart","input","charCodeAt","finishToken","getTokenFromCode","jsxReadEntity","jsxReadNewLine","normalizeCRLF","jsxReadString","quote","codePointAtPos","codePoint","readInt","fromCodePoint","count","desc","entity","jsxReadWord","jsxParseIdentifier","match","jsxParseNamespacedName","eat","jsxParseElementName","jsxParseAttributeValue","setContext","jsxParseExpressionContainer","parseExprAtom","jsxParseEmptyExpression","jsxParseSpreadChild","parseExpression","expect","previousContext","jsxParseAttribute","parseMaybeAssignAllowIn","jsxParseOpeningElementAt","jsxParseOpeningElementAfterName","selfClosing","jsxParseClosingElementAt","jsxParseElementAt","children","openingElement","closingElement","contents","openingFragment","closingFragment","jsxParseElement","newContext","replaceToken","skipSpace","curContext","prevType","splice","flow","flowPragma","getScopeHandler","shouldParseTypes","shouldParseEnums","addComment","comment","matches","exec","flowParseTypeInitialiser","tok","oldInType","flowParseType","flowParsePredicate","moduloLoc","expectContextual","flowParseTypeAndPredicateInitialiser","predicate","flowParseDeclareClass","flowParseInterfaceish","flowParseDeclareFunction","parseIdentifier","typeNode","typeContainer","flowParseTypeParameterDeclaration","tmp","flowParseFunctionTypeParams","returnType","typeAnnotation","semicolon","flowParseDeclare","insideModule","flowParseDeclareVariable","eatContextual","flowParseDeclareModuleExports","flowParseDeclareModule","isContextual","flowParseDeclareTypeAlias","flowParseDeclareOpaqueType","flowParseDeclareInterface","flowParseDeclareExportDeclaration","flowParseTypeAnnotatableIdentifier","BIND_KIND_VALUE","bodyNode","parseImport","hasModuleExport","bodyElement","declaration","isEsModuleType","default","isLet","exportKind","flowParseTypeAnnotation","flowParseTypeAlias","flowParseOpaqueType","isClass","flowParseRestrictedIdentifier","extends","implements","mixins","flowParseInterfaceExtends","flowParseObjectType","allowStatic","allowExact","allowSpread","allowProto","allowInexact","flowParseQualifiedTypeIdentifier","flowParseTypeParameterInstantiation","flowParseInterface","checkNotUnderscore","checkReservedType","liberal","right","declare","supertype","impltype","flowParseTypeParameter","requireDefault","nodeStartLoc","variance","flowParseVariance","ident","bound","defaultRequired","typeParameter","oldNoAnonFunctionType","flowParseTypeParameterInstantiationCallOrNew","flowParseTypeOrImplicitInstantiation","flowParseInterfaceType","flowParseObjectPropertyKey","flowParseObjectTypeIndexer","isStatic","static","lookahead","flowParseObjectTypeInternalSlot","flowParseObjectTypeMethodish","flowParseFunctionTypeParam","flowParseObjectTypeCallProperty","valueNode","nodeStart","endDelim","exact","callProperties","indexers","internalSlots","inexact","protoStartLoc","inexactStartLoc","propOrInexact","flowParseObjectTypeProperty","flowObjectTypeSemicolon","proto","flowCheckGetterSetterParams","paramCount","node2","qualification","flowParseGenericType","flowParseTypeofType","flowParsePrimaryType","flowParseTupleType","first","lh","isThis","reinterpretTypeAsFunctionTypeParam","flowIdentToTypeAnnotation","isGroupedType","parseLiteralAtNode","createIdentifier","flowParsePostfixType","seenOptionalIndexedAccess","canInsertSemicolon","objectType","indexType","flowParsePrefixType","flowParseAnonFunctionWithoutParens","param","flowParseIntersectionType","flowParseUnionType","allowPrimitiveOverride","typeCastToParameter","allowExpressionBody","forwardNoArrowParamsConversionAt","parseFunctionBodyAndFinish","parseStatement","topLevel","flowParseEnumDeclaration","parseExpressionStatement","expr","shouldParseExportDeclaration","isExportDefaultSpecifier","parseExportDefaultExpression","parseConditional","nextCh","lookaheadCharCode","setOptionalParametersError","originalNoArrowAt","consequent","failed","tryParseConditionalConsequent","valid","invalid","getArrowLikeExpressions","alternate","parseMaybeAssign","disallowInvalid","arrows","finishArrowValidation","list","list1","list2","partition","every","_node$extra","toAssignableList","trailingCommaLoc","SCOPE_FUNCTION","checkParams","result","parseParenItem","typeCastNode","assertModuleNodeAllowed","decl","parseExportDeclaration","declarationNode","parseExportSpecifiers","parseExportFrom","eatExportStar","maybeParseExportNamespaceSpecifier","hasNamespace","parseClassId","isStatement","optionalId","parseClassMember","member","parseClassMemberFromModifier","isIterator","readIterator","readWord1","fullWord","finishOp","next2","isIteratorStart","left","exprList","toReferencedList","isParenthesizedExpr","_expr$extra","parseArrayLike","close","canBePattern","isTuple","isClassMethod","isClassProperty","isNonstaticConstructor","isThisParam","pushClassPrivateMethod","parseClassSuper","superTypeParameters","implemented","checkGetterSetterParams","parsePropertyNamePrefixOperator","parseObjPropValue","parseAssignableListItemTypes","parseMaybeDefault","shouldParseDefaultImport","parseImportSpecifierLocal","specifier","local","finishImportSpecifier","maybeParseDefaultImportSpecifier","parseImportSpecifier","importedIsString","isInTypeOnlyImport","isMaybeTypeOnly","firstIdent","imported","specifierTypeKind","isLookaheadContextual","as_ident","specifierIsTypeImport","checkReservedWord","parseBindingAtom","parseFunctionParams","allowModifiers","parseVarId","parseAsyncArrowFromCallExpression","call","shouldParseAsyncArrow","afterLeftParse","_jsx","tryParse","currentContext","_jsx2","_jsx3","abort","_arrowExpression$extr","arrowExpression","resetStartLocationFromNode","maybeUnwrapTypeCastExpression","aborted","async","failState","thrown","parseArrow","shouldParseArrow","setArrowFunctionParameters","allowDuplicates","isArrowFunction","parseParenAndDistinguishExpression","canBeArrow","parseSubscripts","parseCallExpressionArguments","parseAsyncArrowWithTypeParameters","subscriptState","isLookaheadToken_lt","typeArguments","parseNewCallee","targs","parseArrowExpression","readToken_mult_modulo","nextToken","readToken_pipe_amp","parseTopLevel","program","fileNode","skipBlockComment","skipFlowComment","hasFlowCommentCompletion","shiftToFirstNonWhiteSpace","includes","ch2","ch3","flowEnumErrorBooleanMemberNotInitialized","flowEnumErrorInvalidMemberInitializer","enumContext","flowEnumErrorNumberMemberNotInitialized","flowEnumErrorStringMemberInconsistentlyInitailized","flowEnumMemberInit","endOfInit","literal","flowEnumMemberRaw","flowEnumCheckExplicitTypeMismatch","expectedType","flowEnumMembers","seenNames","members","booleanMembers","numberMembers","stringMembers","defaultedMembers","hasUnknownMembers","memberNode","toUpperCase","flowEnumStringMembers","initializedMembers","flowEnumParseExplicitType","flowEnumBody","nameLoc","boolsLen","numsLen","strsLen","defaultedLen","nextTokenStart","afterNext","typescript","tsIsIdentifier","tsTokenCanFollowModifier","isLiteralPropertyName","hasPrecedingLineBreak","tsNextTokenCanFollowModifier","tsParseModifier","allowedModifiers","stopOnStartOfClassStaticBlock","tsIsStartOfStaticBlocks","tsTryParse","bind","tsParseModifiers","modified","disallowedModifiers","errorTemplate","enforceOrder","before","after","incompatible","mod1","mod2","accessibility","hasOwnProperty","tsIsListTerminator","tsParseList","parseElement","tsParseDelimitedList","refTrailingCommaPos","nonNull","tsParseDelimitedListWorker","expectSuccess","trailingCommaPos","element","tsParseBracketedList","bracket","skipFirstToken","tsParseImportType","qualifier","tsParseEntityName","tsParseTypeArguments","allowReservedWords","tsParseTypeReference","typeName","tsParseThisTypePredicate","lhs","parameterName","tsParseTypeAnnotation","asserts","tsParseThisTypeNode","tsParseTypeQuery","exprName","tsParseInOutModifiers","tsParseNoneModifiers","tsParseTypeParameter","parseModifiers","tsParseTypeParameterName","constraint","tsEatThenParseType","tsTryParseTypeParameters","tsParseTypeParameters","addExtra","tsTryNextParseConstantContext","typeReference","tsFillSignature","returnToken","signature","returnTokenRequired","tsParseBindingListForSignature","tsParseTypeOrTypePredicateAnnotation","parseBindingList","tsParseTypeMemberSemicolon","isLineTerminator","tsParseSignatureMember","tsIsUnambiguouslyIndexSignature","tsTryParseIndexSignature","tsLookAhead","parameters","tsTryParseTypeAnnotation","tsParsePropertyOrMethodSignature","readonly","nodeAny","paramsKey","returnTypeKey","firstParameter","tsParseTypeMember","idx","parsePropertyName","tsParseTypeLiteral","tsParseObjectTypeMembers","tsIsStartOfMappedType","tsParseMappedTypeParameter","tsExpectThenParseType","tsParseMappedType","nameType","tsParseType","tsTryParseType","tsParseTupleType","elementTypes","tsParseTupleElementType","seenOptionalElement","labeledElements","elementNode","_labeledElements","isLabeled","labeledNode","optionalTypeNode","restNode","tsParseParenthesizedType","tsParseFunctionOrConstructorType","abstract","tsInAllowConditionalTypesContext","tsParseLiteralTypeNode","tsParseTemplateLiteralType","parseTemplate","parseTemplateSubstitution","tsParseThisTypeOrThisTypePredicate","thisKeyword","tsParseNonArrayType","parseMaybeUnary","nodeType","keywordTypeFromName","tsParseArrayTypeOrHigher","tsParseTypeOperator","operator","tsParseTypeOperatorOrHigher","tsCheckTypeAnnotationForReadOnly","tsParseInferType","tsParseConstraintForInferType","tsInDisallowConditionalTypesContext","tsParseUnionOrIntersectionType","parseConstituentType","hasLeadingOperator","tsParseIntersectionTypeOrHigher","tsParseUnionTypeOrHigher","tsIsStartOfFunctionType","tsIsUnambiguouslyStartOfFunctionType","tsSkipParameterStart","previousErrorCount","parseObjectLike","_unused2","tsInType","t","tsParseTypePredicateAsserts","thisTypePredicate","typePredicateVariable","tsParseTypePredicatePrefix","tsTryParseTypeOrTypePredicateAnnotation","eatColon","tsParseNonConditionalType","checkType","extendsType","trueType","falseType","isAbstractConstructorSignature","tsParseTypeAssertion","tsNextThenParseType","tsParseHeritageClause","originalStartLoc","delimitedList","tsParseInterfaceDeclaration","hasFollowingLineBreak","checkIdentifier","tsParseTypeAliasDeclaration","tsInNoContext","cb","oldContext","oldInDisallowConditionalTypesContext","tsDoThenParseType","tsParseEnumMember","initializer","tsParseEnumDeclaration","BIND_TS_ENUM","tsParseModuleBlock","parseBlockOrModuleBlockBody","tsParseModuleOrNamespaceDeclaration","nested","inner","prodParam","tsParseAmbientExternalModuleDeclaration","global","tsParseImportEqualsDeclaration","isExport","moduleReference","tsParseModuleReference","tsIsExternalModuleReference","tsParseExternalModuleReference","f","res","tsTryParseAndCatch","tsTryParseDeclare","nany","starttype","tsInAmbientContext","parseFunctionStatement","parseClass","parseVarStatement","tsParseDeclaration","tsTryParseExportDeclaration","tsParseExpressionStatement","mod","tsCheckLineTerminator","tsParseAbstractDeclaration","tsTryParseGenericAsyncArrowFunction","oldMaybeInArrowParameters","tsParseTypeArgumentsInExpression","reScan_lt","tsIsDeclarationStart","parseAssignableListItem","decorators","override","elt","pp","parameter","isSimpleParameter","bodilessType","registerFunctionStatementId","tsCheckForInvalidTypeCasts","items","isInParens","nonNullExpression","isOptionalCall","missingParenErrorLoc","atPossibleAsyncArrow","asyncArrowFn","parseTaggedTemplateExpression","_callee$extra","parseExprOp","leftStartPos","leftStartLoc","minPrec","reScan_lt_gt","checkKeywords","checkDuplicateExports","ahead","importNode","isAbstractClass","cls","allowMissingInitializer","declarations","parseStatementContent","parseAccessModifier","tsHasSomeModifiers","callParseClassMemberWithIsStatic","parseClassStaticBlock","parseClassMemberWithIsStatic","hadSuperClass","parsePostMemberNameModifiers","methodOrProp","isDeclare","parseClassPropertyAnnotation","definite","declareClassPrivateMethodInScope","_typeCast","_typeCast2","_jsx4","_typeCast3","typeCast","_typeParameters","reportReservedArrowTypeParam","trailingComma","toAssignableParenthesizedExpression","expressionScope","checkToRestConversion","allowPattern","isUnparenthesizedInAssign","binding","TSTypeCastExpression","TSParameterProperty","TSNonNullExpression","TSAsExpression","TSTypeAssertion","parseMaybeDecoratorArguments","checkCommaAfterRest","readToken_lt","readToken_gt","canHaveLeadingDecorator","getGetterSetterExpectedParamCount","baseCount","firstParam","parseCatchClauseParam","oldIsAmbientContext","oldInAbstractClass","shouldParseAsAmbientContext","getExpression","parseExportSpecifier","isString","isInTypeExport","parseTypeOnlyImportExportSpecifier","isImport","isInTypeOnlyImportExport","leftOfAsKey","rightOfAsKey","rightOfAs","leftOfAs","hasTypeSpecifier","canParseAsKeyword","firstAs","secondAs","parseModuleExportName","v8intrinsic","parseV8Intrinsic","v8IntrinsicStartLoc","parseIdentifierName","identifier","placeholders","parsePlaceholder","assertNoSpace","finishPlaceholder","isFinished","verifyBreakContinue","parseBlock","parseFunctionId","takeDecorators","oldStrict","parseClassBody","expectPlugin","isUnparsedContextual","startsWith","nextTokenStartSince","maybeParseExportDefaultSpecifier","checkExport","maybeParseStarImportSpecifier","parseNamedImportSpecifiers","parseImportSource","mixinPluginNames","defaultOptions","sourceFilename","allowAwaitOutsideFunction","allowReturnOutsideFunction","allowImportExportEverywhere","allowSuperOutsideMethod","allowUndeclaredExports","createParenthesizedExpressions","errorRecovery","attachComment","unwrapParenthesizedExpression","loopLabel","switchLabel","loneSurrogate","keywordRelationalOperator","Parser","sawUnambiguousESM","ambiguousScriptDifferentAst","pluginConfig","actualOptions","_this$plugins$get","processComment","commentStackLength","lastCommentWS","leadingNode","commentEnd","trailingNode","containingNode","finalizeComment","leadingComments","setLeadingComments","commentStart","finalizeRemainingComments","resetPreviousNodeTrailingComments","takeSurroundingComments","isLookahead","pushToken","checkKeywordEscapes","createLookaheadState","old","curr","lastIndex","cp","trail","setStrict","clear","skipLineComment","startSkip","spaceStart","loop","CommentWhitespace","readToken_numberSign","readToken_interpreter","nextPos","readToken_dot","readNumber","readToken_slash","width","readToken_caret","proposal","topicToken","codePointAt","readToken_atSign","readToken_plus_min","size","readToken_eq_excl","readToken_question","readTemplateToken","readRadixNumber","readString","readWord","str","readRegexp","escaped","content","mods","char","len","forceLen","allowNumSeparator","forbiddenSiblings","isAllowedSibling","total","Infinity","prev","Number","isNaN","isBigInt","replace","startsWithDot","isFloat","isDecimal","hasExponent","isOctal","hasLeadingZero","integer","recordStrictModeErrors","underscorePos","parseInt","parseFloat","readCodePoint","throwOnInvalid","readHexChar","readEscapedChar","readTemplateContinuation","containsInvalid","inTemplate","codePos","octalStr","octal","codeLoc","n","firstCode","escStart","identifierCheck","esc","raiseProperties","raiseOverwrite","expectOnePlugin","pluginNames","nameStart","nameEnd","allowAsi","fn","oldState","abortSignal","checkExpressionErrors","andThrow","initializeScopes","oldLabels","oldExportedIdentifiers","exportedIdentifiers","oldInModule","oldScope","oldProdParam","oldExpressionScope","enterInitialScopes","paramFlags","checkDestructuringPrivate","locationNode","_node$extra3","_node$extra2","isLast","arg","toReferencedListDeep","parseSpread","refNeedsArrowPos","parseRestBinding","closeCharCode","allowEmpty","elts","parseDecorator","parseBindingRestProperty","parseBindingProperty","_startLoc","_startPos","_left","ObjectProperty","checkLVal","in","checkClashes","strictModeChanged","allowingSloppyLetBinding","hasParenthesizedAncestor","_expression$extra","validity","ParseErrorClass","isParenthesizedExpression","nextAncestor","child","allowLetBinding","declareNameFromIdentifier","checkProto","isRecord","protoRef","used","shouldExitDescending","disallowIn","disallowInAnd","parseExpressionBase","allowInAnd","parseMaybeAssignDisallowIn","resultError","_resultError$loc","parseYield","ownExpressionErrors","parseMaybeConditional","parseExprOps","parseMaybeUnaryOrPrivate","op","prec","checkPipelineAtInfixOperator","logical","coalesce","parseExprOpRightExpr","nextOp","withTopicBindingContext","parseHackPipeBody","parseSmartPipelineBodyInStyle","parseExprOpBaseRightExpr","withSoloAwaitPermittingContext","parseFSharpPipelineBody","_body$extra","topicReferenceWasUsedInCurrentContext","checkExponentialAfterUnary","sawUnary","isAwait","isAwaitAllowed","parseAwait","update","isDelete","parseUpdate","isAmbiguousAwait","parseExprSubscripts","maybeAsyncArrow","parseBind","parseCoverCallAndAsyncArrowHead","parseMember","parseNoCallExpr","tag","quasi","dynamicImport","allowPlaceholder","nodeForExtra","oldInFSharpPipelineDirectBody","addTrailingCommaExtraToNode","parseExprListItem","_call$extra","parseSuper","parseImportMetaProperty","parseDo","parseFunctionOrFunctionSent","parseDecorators","parseNewOrNewTarget","parseTopicReferenceThenEqualsSign","parseTopicReference","pipeProposal","lookaheadCh","parseModuleExpression","parseFunction","parseAsyncArrowUnaryFunction","topicTokenType","topicTokenValue","tokenType","finishTopicReference","testTopicReferenceConfiguration","topicReferenceIsAllowedInCurrentContext","registerTopicReference","meta","parseMetaProperty","innerStartPos","innerStartLoc","spreadStartLoc","optionalCommaStartLoc","spreadNodeStartPos","spreadNodeStartLoc","innerEndLoc","arrowNode","wrapParenthesis","parenExpression","metaProp","parseNew","parseExprList","parseTemplateElement","isTagged","elemStart","elem","isTail","endOffset","elemEnd","cooked","tail","curElt","quasis","propHash","parsePropertyDefinition","maybeAsyncOrAccessorProp","keyName","_params","generator","isExpression","hasStrictModeDirective","nonSimple","isSimpleParamList","formalParameters","canBeReservedWord","isKeyword","delegating","delegate","childExpr","isSimpleReference","checkSmartPipeTopicBodyEarlyErrors","callback","outerContextTopicState","withSmartMixTopicForbiddingContext","outerContextSoloAwaitState","ret","revertScopes","parseProgram","hashEndPos","hashEndLoc","backquoteEnd","backquoteEndLoc","startToken","templateValue","templateElementEnd","templateElementEndLoc","endToken","babel7CompatTokens","interpreter","parseInterpreterDirective","stmtToDirective","isLetKeyword","endCh","parseBreakContinueStatement","parseDebuggerStatement","parseDoStatement","parseForStatement","parseIfStatement","parseReturnStatement","parseSwitchStatement","parseThrowStatement","parseTryStatement","parseWhileStatement","parseWithStatement","parseEmptyStatement","nextTokenCharCode","isAsyncFunction","maybeName","parseLabeledStatement","allowExport","currentContextDecorators","decorator","isBreak","lab","parseHeaderExpression","awaitAt","parseFor","startsWithLet","parseVar","parseForIn","startsWithAsync","isForOf","declarationPosition","discriminant","cases","cur","sawDefault","isCase","simple","block","handler","clause","finalizer","statementStart","allowDirectives","createNewLexicalScope","afterBlockParse","parsedNonDirective","isForIn","await","isFor","statement","isHangingStatement","requireId","hadConstructor","publicMethod","privateMethod","publicProp","privateProp","accessorProp","publicMember","parseClassElementName","isPrivate","maybeQuestionTokenStartLoc","pushClassPrivateProperty","pushClassProperty","pushClassAccessorProperty","_member$decorators","parseClassAccessorProperty","CLASS_ELEMENT_KIND_SETTER","parseInitializer","hasDefault","parseAfterDefault","hasStar","parseAfterNamespace","isFromRequired","hasSpecifiers","maybeParseExportNamedSpecifiers","hasDeclaration","maybeParseExportDeclaration","isTypeExport","assertions","FUNC_STATEMENT","nextType","hasFrom","nextAfterFrom","maybeParseImportAssertions","checkNames","isDefault","isFrom","_declaration$extra","nodes","surrogate","parseNext","maybeParseModuleAttributes","parseAssertEntries","attrs","attrNames","importSpecifier","opts","getOptions","pluginMap","pluginsMap","tokTypes","internalTokenTypes","generateExportedTokenTypes","getParser","decoratorsBeforeExport","proposalList","tupleSyntaxIsHash","syntaxType","tokenList","missingPlugins","validatePlugins","pluginsFromOptions","pluginList","parserClassCache","getParserClass","exports","_options","ast","moduleError"],"sourceRoot":""}